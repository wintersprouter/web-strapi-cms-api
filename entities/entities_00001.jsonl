{"type":"plugin::upload.file","id":1,"data":{"documentId":"obaz040bf0k02thgf584jmvd","name":"360855.jpg","alternativeText":null,"caption":null,"width":1477,"height":1108,"formats":{"thumbnail":{"name":"thumbnail_360855.jpg","hash":"thumbnail_360855_ab16fa33ef","ext":".jpg","mime":"image/jpg","path":null,"width":208,"height":156,"size":12.02,"sizeInBytes":12017,"url":"/uploads/thumbnail_360855_ab16fa33ef.jpg"},"small":{"name":"small_360855.jpg","hash":"small_360855_ab16fa33ef","ext":".jpg","mime":"image/jpg","path":null,"width":500,"height":375,"size":55.12,"sizeInBytes":55119,"url":"/uploads/small_360855_ab16fa33ef.jpg"},"medium":{"name":"medium_360855.jpg","hash":"medium_360855_ab16fa33ef","ext":".jpg","mime":"image/jpg","path":null,"width":750,"height":563,"size":109.79,"sizeInBytes":109786,"url":"/uploads/medium_360855_ab16fa33ef.jpg"},"large":{"name":"large_360855.jpg","hash":"large_360855_ab16fa33ef","ext":".jpg","mime":"image/jpg","path":null,"width":1000,"height":750,"size":176.78,"sizeInBytes":176775,"url":"/uploads/large_360855_ab16fa33ef.jpg"}},"hash":"360855_ab16fa33ef","ext":".jpg","mime":"image/jpg","size":299.58,"url":"/uploads/360855_ab16fa33ef.jpg","previewUrl":null,"provider":"local","provider_metadata":null,"folderPath":"/1","createdAt":"2025-08-16T08:54:50.649Z","updatedAt":"2025-08-16T08:54:50.649Z","publishedAt":"2025-08-16T08:54:50.650Z","locale":null}}
{"type":"plugin::upload.file","id":2,"data":{"documentId":"dren1gxp09dt51dha69yj5ts","name":"360855.jpg","alternativeText":null,"caption":null,"width":1477,"height":1108,"formats":{"thumbnail":{"name":"thumbnail_360855.jpg","hash":"thumbnail_360855_f9a50924f5","ext":".jpg","mime":"image/jpg","path":null,"width":208,"height":156,"size":12.02,"sizeInBytes":12017,"url":"/uploads/thumbnail_360855_f9a50924f5.jpg"},"small":{"name":"small_360855.jpg","hash":"small_360855_f9a50924f5","ext":".jpg","mime":"image/jpg","path":null,"width":500,"height":375,"size":55.12,"sizeInBytes":55119,"url":"/uploads/small_360855_f9a50924f5.jpg"},"medium":{"name":"medium_360855.jpg","hash":"medium_360855_f9a50924f5","ext":".jpg","mime":"image/jpg","path":null,"width":750,"height":563,"size":109.79,"sizeInBytes":109786,"url":"/uploads/medium_360855_f9a50924f5.jpg"},"large":{"name":"large_360855.jpg","hash":"large_360855_f9a50924f5","ext":".jpg","mime":"image/jpg","path":null,"width":1000,"height":750,"size":176.78,"sizeInBytes":176775,"url":"/uploads/large_360855_f9a50924f5.jpg"}},"hash":"360855_f9a50924f5","ext":".jpg","mime":"image/jpg","size":299.58,"url":"/uploads/360855_f9a50924f5.jpg","previewUrl":null,"provider":"local","provider_metadata":null,"folderPath":"/1","createdAt":"2025-08-16T08:55:59.714Z","updatedAt":"2025-08-16T08:55:59.714Z","publishedAt":"2025-08-16T08:55:59.714Z","locale":null}}
{"type":"plugin::upload.file","id":3,"data":{"documentId":"wqb628o5jb6l0djpiay9147e","name":"360855.jpg","alternativeText":null,"caption":null,"width":1477,"height":1108,"formats":{"thumbnail":{"name":"thumbnail_360855.jpg","hash":"thumbnail_360855_bedccdbe1b","ext":".jpg","mime":"image/jpg","path":null,"width":208,"height":156,"size":12.02,"sizeInBytes":12017,"url":"/uploads/thumbnail_360855_bedccdbe1b.jpg"},"small":{"name":"small_360855.jpg","hash":"small_360855_bedccdbe1b","ext":".jpg","mime":"image/jpg","path":null,"width":500,"height":375,"size":55.12,"sizeInBytes":55119,"url":"/uploads/small_360855_bedccdbe1b.jpg"},"medium":{"name":"medium_360855.jpg","hash":"medium_360855_bedccdbe1b","ext":".jpg","mime":"image/jpg","path":null,"width":750,"height":563,"size":109.79,"sizeInBytes":109786,"url":"/uploads/medium_360855_bedccdbe1b.jpg"},"large":{"name":"large_360855.jpg","hash":"large_360855_bedccdbe1b","ext":".jpg","mime":"image/jpg","path":null,"width":1000,"height":750,"size":176.78,"sizeInBytes":176775,"url":"/uploads/large_360855_bedccdbe1b.jpg"}},"hash":"360855_bedccdbe1b","ext":".jpg","mime":"image/jpg","size":299.58,"url":"/uploads/360855_bedccdbe1b.jpg","previewUrl":null,"provider":"local","provider_metadata":null,"folderPath":"/1","createdAt":"2025-08-16T10:20:07.812Z","updatedAt":"2025-08-16T10:20:07.812Z","publishedAt":"2025-08-16T10:20:07.812Z","locale":null}}
{"type":"plugin::upload.file","id":4,"data":{"documentId":"zy5ogb4wq97g38ballrw1qyt","name":"cover.png","alternativeText":null,"caption":null,"width":2514,"height":1648,"formats":{"thumbnail":{"name":"thumbnail_cover.png","hash":"thumbnail_cover_7f1baf43b2","ext":".png","mime":"image/png","path":null,"width":238,"height":156,"size":17.1,"sizeInBytes":17103,"url":"/uploads/thumbnail_cover_7f1baf43b2.png"},"small":{"name":"small_cover.png","hash":"small_cover_7f1baf43b2","ext":".png","mime":"image/png","path":null,"width":500,"height":328,"size":49.04,"sizeInBytes":49036,"url":"/uploads/small_cover_7f1baf43b2.png"},"medium":{"name":"medium_cover.png","hash":"medium_cover_7f1baf43b2","ext":".png","mime":"image/png","path":null,"width":750,"height":492,"size":91.94,"sizeInBytes":91941,"url":"/uploads/medium_cover_7f1baf43b2.png"},"large":{"name":"large_cover.png","hash":"large_cover_7f1baf43b2","ext":".png","mime":"image/png","path":null,"width":1000,"height":656,"size":147.08,"sizeInBytes":147078,"url":"/uploads/large_cover_7f1baf43b2.png"}},"hash":"cover_7f1baf43b2","ext":".png","mime":"image/png","size":140.71,"url":"/uploads/cover_7f1baf43b2.png","previewUrl":null,"provider":"local","provider_metadata":null,"folderPath":"/1","createdAt":"2025-08-16T10:20:08.270Z","updatedAt":"2025-08-16T10:20:08.270Z","publishedAt":"2025-08-16T10:20:08.270Z","locale":null}}
{"type":"plugin::upload.file","id":5,"data":{"documentId":"zm12lnftgf0wf2vn8p2zwhup","name":"20230811_131223.jpg","alternativeText":null,"caption":null,"width":1477,"height":1108,"formats":{"thumbnail":{"name":"thumbnail_20230811_131223.jpg","hash":"thumbnail_20230811_131223_5be0451343","ext":".jpg","mime":"image/jpg","path":null,"width":208,"height":156,"size":7.44,"sizeInBytes":7440,"url":"/uploads/thumbnail_20230811_131223_5be0451343.jpg"},"small":{"name":"small_20230811_131223.jpg","hash":"small_20230811_131223_5be0451343","ext":".jpg","mime":"image/jpg","path":null,"width":500,"height":375,"size":35.24,"sizeInBytes":35242,"url":"/uploads/small_20230811_131223_5be0451343.jpg"},"large":{"name":"large_20230811_131223.jpg","hash":"large_20230811_131223_5be0451343","ext":".jpg","mime":"image/jpg","path":null,"width":1000,"height":750,"size":116.27,"sizeInBytes":116274,"url":"/uploads/large_20230811_131223_5be0451343.jpg"},"medium":{"name":"medium_20230811_131223.jpg","hash":"medium_20230811_131223_5be0451343","ext":".jpg","mime":"image/jpg","path":null,"width":750,"height":563,"size":71.22,"sizeInBytes":71223,"url":"/uploads/medium_20230811_131223_5be0451343.jpg"}},"hash":"20230811_131223_5be0451343","ext":".jpg","mime":"image/jpg","size":238.86,"url":"/uploads/20230811_131223_5be0451343.jpg","previewUrl":null,"provider":"local","provider_metadata":null,"folderPath":"/1","createdAt":"2025-08-16T10:20:08.393Z","updatedAt":"2025-08-16T10:20:08.393Z","publishedAt":"2025-08-16T10:20:08.393Z","locale":null}}
{"type":"plugin::upload.folder","id":1,"data":{"documentId":"bxt9j92qebbh4e5qxs4822th","name":"API Uploads","pathId":1,"path":"/1","createdAt":"2025-08-16T08:52:10.700Z","updatedAt":"2025-08-16T08:52:10.700Z","publishedAt":"2025-08-16T08:52:10.701Z","locale":null}}
{"type":"plugin::i18n.locale","id":1,"data":{"documentId":"qqcqcqyp5lova08tv3gvowdn","name":"English (en)","code":"en","createdAt":"2025-08-16T07:51:38.109Z","updatedAt":"2025-08-16T07:51:38.109Z","publishedAt":"2025-08-16T07:51:38.110Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":1,"data":{"documentId":"xbubvny1t8npikls4up7humf","action":"plugin::users-permissions.user.me","createdAt":"2025-08-16T07:51:38.122Z","updatedAt":"2025-08-16T07:51:38.122Z","publishedAt":"2025-08-16T07:51:38.122Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":2,"data":{"documentId":"i6pc434wem234l9lgm80b4rj","action":"plugin::users-permissions.auth.changePassword","createdAt":"2025-08-16T07:51:38.122Z","updatedAt":"2025-08-16T07:51:38.122Z","publishedAt":"2025-08-16T07:51:38.122Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":3,"data":{"documentId":"cd9061rlsnavzel8mdumfzdo","action":"plugin::users-permissions.auth.callback","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":4,"data":{"documentId":"lc9q8n5ah4g8th27rkuxvsar","action":"plugin::users-permissions.auth.connect","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":5,"data":{"documentId":"rv5dnt6swbzrgne4ohd0x045","action":"plugin::users-permissions.auth.forgotPassword","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":6,"data":{"documentId":"rp4ac1thj99xcl8a222n4730","action":"plugin::users-permissions.auth.resetPassword","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":7,"data":{"documentId":"n0cic1kb05fdn8yrl8bfk1ty","action":"plugin::users-permissions.auth.register","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":8,"data":{"documentId":"f7lpcwjschtqyx62652emu3o","action":"plugin::users-permissions.auth.emailConfirmation","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":9,"data":{"documentId":"vwm3kclk8a5a1ttgr76uhugh","action":"plugin::users-permissions.auth.sendEmailConfirmation","createdAt":"2025-08-16T07:51:38.125Z","updatedAt":"2025-08-16T07:51:38.125Z","publishedAt":"2025-08-16T07:51:38.125Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":10,"data":{"documentId":"uogkpu0dbkj4n6ya2i68iob2","action":"api::post.post.find","createdAt":"2025-08-16T10:35:48.717Z","updatedAt":"2025-08-16T10:35:48.717Z","publishedAt":"2025-08-16T10:35:48.717Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":11,"data":{"documentId":"tmucy7grnlcicvajwqulbqc5","action":"api::post.post.findOne","createdAt":"2025-08-16T10:35:48.720Z","updatedAt":"2025-08-16T10:35:48.720Z","publishedAt":"2025-08-16T10:35:48.721Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":12,"data":{"documentId":"sdy7wmd865lg4yos1bs05xsa","action":"api::tag.tag.find","createdAt":"2025-08-16T10:35:48.722Z","updatedAt":"2025-08-16T10:35:48.722Z","publishedAt":"2025-08-16T10:35:48.722Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":13,"data":{"documentId":"lgoeepg3zsj1nzxm4ravu6ap","action":"api::tag.tag.findOne","createdAt":"2025-08-16T10:35:48.723Z","updatedAt":"2025-08-16T10:35:48.723Z","publishedAt":"2025-08-16T10:35:48.723Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":14,"data":{"documentId":"b8v6m73eew0x3phx0n5etey6","action":"api::keyword.keyword.find","createdAt":"2025-08-16T10:35:48.725Z","updatedAt":"2025-08-16T10:35:48.725Z","publishedAt":"2025-08-16T10:35:48.725Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":15,"data":{"documentId":"zmn15iuxevehi2651dwd1yuc","action":"api::keyword.keyword.findOne","createdAt":"2025-08-16T10:35:48.726Z","updatedAt":"2025-08-16T10:35:48.726Z","publishedAt":"2025-08-16T10:35:48.726Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":16,"data":{"documentId":"ej2ifl1bq3v2a60ezcyqwwsk","action":"api::category.category.find","createdAt":"2025-08-16T10:35:48.727Z","updatedAt":"2025-08-16T10:35:48.727Z","publishedAt":"2025-08-16T10:35:48.727Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":17,"data":{"documentId":"obtad7vmf1gqzb9eqkpgco2y","action":"api::category.category.findOne","createdAt":"2025-08-16T10:35:48.728Z","updatedAt":"2025-08-16T10:35:48.728Z","publishedAt":"2025-08-16T10:35:48.728Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":18,"data":{"documentId":"ow85un6jll0kaa8dn9wvbv6r","action":"api::subcategory.subcategory.find","createdAt":"2025-08-16T10:35:48.729Z","updatedAt":"2025-08-16T10:35:48.729Z","publishedAt":"2025-08-16T10:35:48.729Z","locale":null}}
{"type":"plugin::users-permissions.permission","id":19,"data":{"documentId":"e3d7rpi3cy648wcee87vweex","action":"api::subcategory.subcategory.findOne","createdAt":"2025-08-16T10:35:48.731Z","updatedAt":"2025-08-16T10:35:48.731Z","publishedAt":"2025-08-16T10:35:48.731Z","locale":null}}
{"type":"plugin::users-permissions.role","id":1,"data":{"documentId":"zzz68ruuhsgaz52j04n524bb","name":"Authenticated","description":"Default role given to authenticated user.","type":"authenticated","createdAt":"2025-08-16T07:51:38.120Z","updatedAt":"2025-08-16T07:51:38.120Z","publishedAt":"2025-08-16T07:51:38.120Z","locale":null}}
{"type":"plugin::users-permissions.role","id":2,"data":{"documentId":"txzs3lyl9fmmc0taaecile6g","name":"Public","description":"Default role given to unauthenticated user.","type":"public","createdAt":"2025-08-16T07:51:38.120Z","updatedAt":"2025-08-16T07:51:38.120Z","publishedAt":"2025-08-16T07:51:38.121Z","locale":null}}
{"type":"api::category.category","id":1,"data":{"documentId":"af04iqecra001hk5t1egpgn6","name":"前端技術","slug":"frontend","createdAt":"2025-08-16T08:18:00.540Z","updatedAt":"2025-08-16T08:18:00.540Z","publishedAt":null,"locale":null}}
{"type":"api::category.category","id":2,"data":{"documentId":"af04iqecra001hk5t1egpgn6","name":"前端技術","slug":"frontend","createdAt":"2025-08-16T08:18:00.540Z","updatedAt":"2025-08-16T08:18:00.540Z","publishedAt":"2025-08-16T08:18:00.543Z","locale":null}}
{"type":"api::keyword.keyword","id":1,"data":{"documentId":"g13ofh40tmxu67rpzb3y8bmx","name":"2023 WebConf","slug":"2023-webconf","createdAt":"2025-08-16T08:31:27.353Z","updatedAt":"2025-08-16T08:31:27.353Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":2,"data":{"documentId":"g13ofh40tmxu67rpzb3y8bmx","name":"2023 WebConf","slug":"2023-webconf","createdAt":"2025-08-16T08:31:27.353Z","updatedAt":"2025-08-16T08:31:27.353Z","publishedAt":"2025-08-16T08:31:27.354Z","locale":null}}
{"type":"api::keyword.keyword","id":3,"data":{"documentId":"g2y4ebt2nyjo3ouicgc0azx4","name":"Web","slug":"web","createdAt":"2025-08-16T08:31:27.362Z","updatedAt":"2025-08-16T08:31:27.362Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":4,"data":{"documentId":"g2y4ebt2nyjo3ouicgc0azx4","name":"Web","slug":"web","createdAt":"2025-08-16T08:31:27.362Z","updatedAt":"2025-08-16T08:31:27.362Z","publishedAt":"2025-08-16T08:31:27.362Z","locale":null}}
{"type":"api::keyword.keyword","id":5,"data":{"documentId":"l9arxxdhv9vcenf2cixf2mmy","name":"front-end","slug":"front-end","createdAt":"2025-08-16T08:31:27.370Z","updatedAt":"2025-08-16T08:31:27.370Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":6,"data":{"documentId":"l9arxxdhv9vcenf2cixf2mmy","name":"front-end","slug":"front-end","createdAt":"2025-08-16T08:31:27.370Z","updatedAt":"2025-08-16T08:31:27.370Z","publishedAt":"2025-08-16T08:31:27.370Z","locale":null}}
{"type":"api::keyword.keyword","id":7,"data":{"documentId":"t95rzbx3n314uzgszfzutewi","name":"2023iT鐵人賽","slug":"2023it","createdAt":"2025-08-16T08:34:19.060Z","updatedAt":"2025-08-16T08:34:19.060Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":8,"data":{"documentId":"t95rzbx3n314uzgszfzutewi","name":"2023iT鐵人賽","slug":"2023it","createdAt":"2025-08-16T08:34:19.060Z","updatedAt":"2025-08-16T08:34:19.060Z","publishedAt":"2025-08-16T08:34:19.061Z","locale":null}}
{"type":"api::keyword.keyword","id":9,"data":{"documentId":"s2tqoi5ijxrbsp3fneoldr93","name":"2024 ReactConf","slug":"2024-reactconf","createdAt":"2025-08-16T08:34:19.127Z","updatedAt":"2025-08-16T08:34:19.127Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":10,"data":{"documentId":"s2tqoi5ijxrbsp3fneoldr93","name":"2024 ReactConf","slug":"2024-reactconf","createdAt":"2025-08-16T08:34:19.127Z","updatedAt":"2025-08-16T08:34:19.127Z","publishedAt":"2025-08-16T08:34:19.129Z","locale":null}}
{"type":"api::keyword.keyword","id":11,"data":{"documentId":"i171bk49zovp8siuk7saslr2","name":"React Native","slug":"react-native","createdAt":"2025-08-16T08:34:19.154Z","updatedAt":"2025-08-16T08:34:19.154Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":12,"data":{"documentId":"i171bk49zovp8siuk7saslr2","name":"React Native","slug":"react-native","createdAt":"2025-08-16T08:34:19.154Z","updatedAt":"2025-08-16T08:34:19.154Z","publishedAt":"2025-08-16T08:34:19.157Z","locale":null}}
{"type":"api::keyword.keyword","id":13,"data":{"documentId":"oru43dic3t20bcz9exr10sir","name":"2024iT鐵人賽","slug":"2024it","createdAt":"2025-08-16T08:34:19.208Z","updatedAt":"2025-08-16T08:34:19.208Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":14,"data":{"documentId":"oru43dic3t20bcz9exr10sir","name":"2024iT鐵人賽","slug":"2024it","createdAt":"2025-08-16T08:34:19.208Z","updatedAt":"2025-08-16T08:34:19.208Z","publishedAt":"2025-08-16T08:34:19.209Z","locale":null}}
{"type":"api::keyword.keyword","id":15,"data":{"documentId":"lgvwg7tsvbc8uca4mivhox7x","name":"2024 WebConf","slug":"2024-webconf","createdAt":"2025-08-16T08:34:19.252Z","updatedAt":"2025-08-16T08:34:19.252Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":16,"data":{"documentId":"lgvwg7tsvbc8uca4mivhox7x","name":"2024 WebConf","slug":"2024-webconf","createdAt":"2025-08-16T08:34:19.252Z","updatedAt":"2025-08-16T08:34:19.252Z","publishedAt":"2025-08-16T08:34:19.253Z","locale":null}}
{"type":"api::keyword.keyword","id":17,"data":{"documentId":"j9v2f37pkbsd9u6de21bjtzv","name":"css","slug":"css","createdAt":"2025-08-16T08:43:45.720Z","updatedAt":"2025-08-16T08:43:45.720Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":18,"data":{"documentId":"j9v2f37pkbsd9u6de21bjtzv","name":"css","slug":"css","createdAt":"2025-08-16T08:43:45.720Z","updatedAt":"2025-08-16T08:43:45.720Z","publishedAt":"2025-08-16T08:43:45.721Z","locale":null}}
{"type":"api::keyword.keyword","id":19,"data":{"documentId":"epyohai6j3qf4xa9jh86xp8j","name":"translate","slug":"translate","createdAt":"2025-08-16T08:43:45.727Z","updatedAt":"2025-08-16T08:43:45.727Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":20,"data":{"documentId":"epyohai6j3qf4xa9jh86xp8j","name":"translate","slug":"translate","createdAt":"2025-08-16T08:43:45.727Z","updatedAt":"2025-08-16T08:43:45.727Z","publishedAt":"2025-08-16T08:43:45.728Z","locale":null}}
{"type":"api::keyword.keyword","id":21,"data":{"documentId":"el1mpaciz7vbtv0yyltyf824","name":"reflow\"","slug":"reflow","createdAt":"2025-08-16T08:43:45.734Z","updatedAt":"2025-08-16T08:43:45.734Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":22,"data":{"documentId":"el1mpaciz7vbtv0yyltyf824","name":"reflow\"","slug":"reflow","createdAt":"2025-08-16T08:43:45.734Z","updatedAt":"2025-08-16T08:43:45.734Z","publishedAt":"2025-08-16T08:43:45.735Z","locale":null}}
{"type":"api::keyword.keyword","id":23,"data":{"documentId":"pwsjff3yfxzw9zvtph3r9wyb","name":"getElementsByClassName","slug":"getelementsbyclassname","createdAt":"2025-08-16T08:43:45.795Z","updatedAt":"2025-08-16T08:43:45.795Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":24,"data":{"documentId":"pwsjff3yfxzw9zvtph3r9wyb","name":"getElementsByClassName","slug":"getelementsbyclassname","createdAt":"2025-08-16T08:43:45.795Z","updatedAt":"2025-08-16T08:43:45.795Z","publishedAt":"2025-08-16T08:43:45.795Z","locale":null}}
{"type":"api::keyword.keyword","id":25,"data":{"documentId":"hbqbxiwozfgoarumxjyobx09","name":"DOM","slug":"dom","createdAt":"2025-08-16T08:43:45.802Z","updatedAt":"2025-08-16T08:43:45.802Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":26,"data":{"documentId":"hbqbxiwozfgoarumxjyobx09","name":"DOM","slug":"dom","createdAt":"2025-08-16T08:43:45.802Z","updatedAt":"2025-08-16T08:43:45.802Z","publishedAt":"2025-08-16T08:43:45.803Z","locale":null}}
{"type":"api::keyword.keyword","id":27,"data":{"documentId":"kljdlpv9ffi7soattzht93hg","name":"JavaScript","slug":"javascript","createdAt":"2025-08-16T08:43:45.809Z","updatedAt":"2025-08-16T08:43:45.809Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":28,"data":{"documentId":"kljdlpv9ffi7soattzht93hg","name":"JavaScript","slug":"javascript","createdAt":"2025-08-16T08:43:45.809Z","updatedAt":"2025-08-16T08:43:45.809Z","publishedAt":"2025-08-16T08:43:45.809Z","locale":null}}
{"type":"api::keyword.keyword","id":29,"data":{"documentId":"fpc3rk1z52hjy98nvd7qz9hg","name":"recursion","slug":"recursion","createdAt":"2025-08-16T08:43:45.815Z","updatedAt":"2025-08-16T08:43:45.815Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":30,"data":{"documentId":"fpc3rk1z52hjy98nvd7qz9hg","name":"recursion","slug":"recursion","createdAt":"2025-08-16T08:43:45.815Z","updatedAt":"2025-08-16T08:43:45.815Z","publishedAt":"2025-08-16T08:43:45.816Z","locale":null}}
{"type":"api::keyword.keyword","id":31,"data":{"documentId":"j8ux0fghzum01djarl9ixe1u","name":"getElementsByTagName","slug":"getelementsbytagname","createdAt":"2025-08-16T08:43:45.903Z","updatedAt":"2025-08-16T08:43:45.903Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":32,"data":{"documentId":"j8ux0fghzum01djarl9ixe1u","name":"getElementsByTagName","slug":"getelementsbytagname","createdAt":"2025-08-16T08:43:45.903Z","updatedAt":"2025-08-16T08:43:45.903Z","publishedAt":"2025-08-16T08:43:45.904Z","locale":null}}
{"type":"api::keyword.keyword","id":33,"data":{"documentId":"s1yhavq6i08ix0ug3fshpiln","name":"hosting","slug":"hosting","createdAt":"2025-08-16T08:43:45.958Z","updatedAt":"2025-08-16T08:43:45.958Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":34,"data":{"documentId":"s1yhavq6i08ix0ug3fshpiln","name":"hosting","slug":"hosting","createdAt":"2025-08-16T08:43:45.958Z","updatedAt":"2025-08-16T08:43:45.958Z","publishedAt":"2025-08-16T08:43:45.959Z","locale":null}}
{"type":"api::keyword.keyword","id":35,"data":{"documentId":"dnicwrrqnf9d1k9ttdn3megh","name":"variables","slug":"variables","createdAt":"2025-08-16T08:43:46.040Z","updatedAt":"2025-08-16T08:43:46.040Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":36,"data":{"documentId":"dnicwrrqnf9d1k9ttdn3megh","name":"variables","slug":"variables","createdAt":"2025-08-16T08:43:46.040Z","updatedAt":"2025-08-16T08:43:46.040Z","publishedAt":"2025-08-16T08:43:46.040Z","locale":null}}
{"type":"api::keyword.keyword","id":37,"data":{"documentId":"abjor1zdtuujf1484317jto9","name":"let","slug":"let","createdAt":"2025-08-16T08:43:46.050Z","updatedAt":"2025-08-16T08:43:46.050Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":38,"data":{"documentId":"abjor1zdtuujf1484317jto9","name":"let","slug":"let","createdAt":"2025-08-16T08:43:46.050Z","updatedAt":"2025-08-16T08:43:46.050Z","publishedAt":"2025-08-16T08:43:46.051Z","locale":null}}
{"type":"api::keyword.keyword","id":39,"data":{"documentId":"fewcdxtd66372y29un2bdqvb","name":"var","slug":"var","createdAt":"2025-08-16T08:43:46.060Z","updatedAt":"2025-08-16T08:43:46.060Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":40,"data":{"documentId":"fewcdxtd66372y29un2bdqvb","name":"var","slug":"var","createdAt":"2025-08-16T08:43:46.060Z","updatedAt":"2025-08-16T08:43:46.060Z","publishedAt":"2025-08-16T08:43:46.061Z","locale":null}}
{"type":"api::keyword.keyword","id":41,"data":{"documentId":"v9jwm3kt9v6r9v3svq6oieks","name":"const","slug":"const","createdAt":"2025-08-16T08:43:46.070Z","updatedAt":"2025-08-16T08:43:46.070Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":42,"data":{"documentId":"v9jwm3kt9v6r9v3svq6oieks","name":"const","slug":"const","createdAt":"2025-08-16T08:43:46.070Z","updatedAt":"2025-08-16T08:43:46.070Z","publishedAt":"2025-08-16T08:43:46.071Z","locale":null}}
{"type":"api::keyword.keyword","id":43,"data":{"documentId":"y3fflpfrytlwb5txoeoyjs3r","name":"operator","slug":"operator","createdAt":"2025-08-16T08:43:46.146Z","updatedAt":"2025-08-16T08:43:46.146Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":44,"data":{"documentId":"y3fflpfrytlwb5txoeoyjs3r","name":"operator","slug":"operator","createdAt":"2025-08-16T08:43:46.146Z","updatedAt":"2025-08-16T08:43:46.146Z","publishedAt":"2025-08-16T08:43:46.147Z","locale":null}}
{"type":"api::keyword.keyword","id":45,"data":{"documentId":"xcywlnur1f1ttit7xe3ajyfy","name":"type coercion","slug":"type-coercion","createdAt":"2025-08-16T08:43:46.153Z","updatedAt":"2025-08-16T08:43:46.153Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":46,"data":{"documentId":"xcywlnur1f1ttit7xe3ajyfy","name":"type coercion","slug":"type-coercion","createdAt":"2025-08-16T08:43:46.153Z","updatedAt":"2025-08-16T08:43:46.153Z","publishedAt":"2025-08-16T08:43:46.154Z","locale":null}}
{"type":"api::keyword.keyword","id":47,"data":{"documentId":"tuqf4gghfuxe9q2xbzhu0fef","name":"equality","slug":"equality","createdAt":"2025-08-16T08:43:46.163Z","updatedAt":"2025-08-16T08:43:46.163Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":48,"data":{"documentId":"tuqf4gghfuxe9q2xbzhu0fef","name":"equality","slug":"equality","createdAt":"2025-08-16T08:43:46.163Z","updatedAt":"2025-08-16T08:43:46.163Z","publishedAt":"2025-08-16T08:43:46.164Z","locale":null}}
{"type":"api::keyword.keyword","id":49,"data":{"documentId":"hwndynendssv9z4sdf6ceahb","name":"strict equality","slug":"strict-equality","createdAt":"2025-08-16T08:43:46.172Z","updatedAt":"2025-08-16T08:43:46.172Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":50,"data":{"documentId":"hwndynendssv9z4sdf6ceahb","name":"strict equality","slug":"strict-equality","createdAt":"2025-08-16T08:43:46.172Z","updatedAt":"2025-08-16T08:43:46.172Z","publishedAt":"2025-08-16T08:43:46.173Z","locale":null}}
{"type":"api::keyword.keyword","id":51,"data":{"documentId":"smwvfqls37o6ihxk08q57pm7","name":"event-loop","slug":"event-loop","createdAt":"2025-08-16T08:43:46.226Z","updatedAt":"2025-08-16T08:43:46.226Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":52,"data":{"documentId":"smwvfqls37o6ihxk08q57pm7","name":"event-loop","slug":"event-loop","createdAt":"2025-08-16T08:43:46.226Z","updatedAt":"2025-08-16T08:43:46.226Z","publishedAt":"2025-08-16T08:43:46.227Z","locale":null}}
{"type":"api::keyword.keyword","id":53,"data":{"documentId":"k8x0sdwdbammy5efqtgkkooe","name":"event delegation","slug":"event-delegation","createdAt":"2025-08-16T08:43:46.274Z","updatedAt":"2025-08-16T08:43:46.274Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":54,"data":{"documentId":"k8x0sdwdbammy5efqtgkkooe","name":"event delegation","slug":"event-delegation","createdAt":"2025-08-16T08:43:46.274Z","updatedAt":"2025-08-16T08:43:46.274Z","publishedAt":"2025-08-16T08:43:46.275Z","locale":null}}
{"type":"api::keyword.keyword","id":55,"data":{"documentId":"vcqfnb8pu6myq5hs1x0efqhy","name":"this","slug":"this","createdAt":"2025-08-16T08:43:46.329Z","updatedAt":"2025-08-16T08:43:46.329Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":56,"data":{"documentId":"vcqfnb8pu6myq5hs1x0efqhy","name":"this","slug":"this","createdAt":"2025-08-16T08:43:46.329Z","updatedAt":"2025-08-16T08:43:46.329Z","publishedAt":"2025-08-16T08:43:46.330Z","locale":null}}
{"type":"api::keyword.keyword","id":57,"data":{"documentId":"lfsgvmhpsw3f6qbvhn9oo5lg","name":"cookie","slug":"cookie","createdAt":"2025-08-16T08:43:46.401Z","updatedAt":"2025-08-16T08:43:46.401Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":58,"data":{"documentId":"lfsgvmhpsw3f6qbvhn9oo5lg","name":"cookie","slug":"cookie","createdAt":"2025-08-16T08:43:46.401Z","updatedAt":"2025-08-16T08:43:46.401Z","publishedAt":"2025-08-16T08:43:46.402Z","locale":null}}
{"type":"api::keyword.keyword","id":59,"data":{"documentId":"aq8ll5peel95xt5xvjq8wbdt","name":"localStorage","slug":"localstorage","createdAt":"2025-08-16T08:43:46.407Z","updatedAt":"2025-08-16T08:43:46.407Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":60,"data":{"documentId":"aq8ll5peel95xt5xvjq8wbdt","name":"localStorage","slug":"localstorage","createdAt":"2025-08-16T08:43:46.407Z","updatedAt":"2025-08-16T08:43:46.407Z","publishedAt":"2025-08-16T08:43:46.408Z","locale":null}}
{"type":"api::keyword.keyword","id":61,"data":{"documentId":"u02csb1aw8bnxhul9pq61l5j","name":"sessionStorage","slug":"sessionstorage","createdAt":"2025-08-16T08:43:46.413Z","updatedAt":"2025-08-16T08:43:46.413Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":62,"data":{"documentId":"u02csb1aw8bnxhul9pq61l5j","name":"sessionStorage","slug":"sessionstorage","createdAt":"2025-08-16T08:43:46.413Z","updatedAt":"2025-08-16T08:43:46.413Z","publishedAt":"2025-08-16T08:43:46.414Z","locale":null}}
{"type":"api::keyword.keyword","id":63,"data":{"documentId":"iraxetc3g4ix5gzcck3pphdp","name":"browser","slug":"browser","createdAt":"2025-08-16T08:43:46.419Z","updatedAt":"2025-08-16T08:43:46.419Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":64,"data":{"documentId":"iraxetc3g4ix5gzcck3pphdp","name":"browser","slug":"browser","createdAt":"2025-08-16T08:43:46.419Z","updatedAt":"2025-08-16T08:43:46.419Z","publishedAt":"2025-08-16T08:43:46.420Z","locale":null}}
{"type":"api::keyword.keyword","id":65,"data":{"documentId":"nxkezzr5ak0zqgwgn9yo36qp","name":"script","slug":"script","createdAt":"2025-08-16T08:43:46.477Z","updatedAt":"2025-08-16T08:43:46.477Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":66,"data":{"documentId":"nxkezzr5ak0zqgwgn9yo36qp","name":"script","slug":"script","createdAt":"2025-08-16T08:43:46.477Z","updatedAt":"2025-08-16T08:43:46.477Z","publishedAt":"2025-08-16T08:43:46.478Z","locale":null}}
{"type":"api::keyword.keyword","id":67,"data":{"documentId":"tg6iuj81levm0ibclmecgsqr","name":"defer","slug":"defer","createdAt":"2025-08-16T08:43:46.489Z","updatedAt":"2025-08-16T08:43:46.489Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":68,"data":{"documentId":"tg6iuj81levm0ibclmecgsqr","name":"defer","slug":"defer","createdAt":"2025-08-16T08:43:46.489Z","updatedAt":"2025-08-16T08:43:46.489Z","publishedAt":"2025-08-16T08:43:46.490Z","locale":null}}
{"type":"api::keyword.keyword","id":69,"data":{"documentId":"pqzjaa8ya3wmt5ylgoct80h8","name":"null","slug":"null","createdAt":"2025-08-16T08:43:46.578Z","updatedAt":"2025-08-16T08:43:46.578Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":70,"data":{"documentId":"pqzjaa8ya3wmt5ylgoct80h8","name":"null","slug":"null","createdAt":"2025-08-16T08:43:46.578Z","updatedAt":"2025-08-16T08:43:46.578Z","publishedAt":"2025-08-16T08:43:46.579Z","locale":null}}
{"type":"api::keyword.keyword","id":71,"data":{"documentId":"gx3nsrlym4q6eedi5hudzyb5","name":"undefined","slug":"undefined","createdAt":"2025-08-16T08:43:46.584Z","updatedAt":"2025-08-16T08:43:46.584Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":72,"data":{"documentId":"gx3nsrlym4q6eedi5hudzyb5","name":"undefined","slug":"undefined","createdAt":"2025-08-16T08:43:46.584Z","updatedAt":"2025-08-16T08:43:46.584Z","publishedAt":"2025-08-16T08:43:46.585Z","locale":null}}
{"type":"api::keyword.keyword","id":73,"data":{"documentId":"zt0gqi07n4j8jb60osswt8nt","name":"undeclared","slug":"undeclared","createdAt":"2025-08-16T08:43:46.597Z","updatedAt":"2025-08-16T08:43:46.597Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":74,"data":{"documentId":"zt0gqi07n4j8jb60osswt8nt","name":"undeclared","slug":"undeclared","createdAt":"2025-08-16T08:43:46.597Z","updatedAt":"2025-08-16T08:43:46.597Z","publishedAt":"2025-08-16T08:43:46.598Z","locale":null}}
{"type":"api::keyword.keyword","id":75,"data":{"documentId":"xxrbctbb769o49l1rmtstcxr","name":"call","slug":"call","createdAt":"2025-08-16T08:43:46.647Z","updatedAt":"2025-08-16T08:43:46.647Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":76,"data":{"documentId":"xxrbctbb769o49l1rmtstcxr","name":"call","slug":"call","createdAt":"2025-08-16T08:43:46.647Z","updatedAt":"2025-08-16T08:43:46.647Z","publishedAt":"2025-08-16T08:43:46.647Z","locale":null}}
{"type":"api::keyword.keyword","id":77,"data":{"documentId":"gb9pze30dmwvtfsno23cmpww","name":"apply","slug":"apply","createdAt":"2025-08-16T08:43:46.653Z","updatedAt":"2025-08-16T08:43:46.653Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":78,"data":{"documentId":"gb9pze30dmwvtfsno23cmpww","name":"apply","slug":"apply","createdAt":"2025-08-16T08:43:46.653Z","updatedAt":"2025-08-16T08:43:46.653Z","publishedAt":"2025-08-16T08:43:46.653Z","locale":null}}
{"type":"api::keyword.keyword","id":79,"data":{"documentId":"npr0nt6ubvza2mj29xmp3oip","name":"closure","slug":"closure","createdAt":"2025-08-16T08:43:46.703Z","updatedAt":"2025-08-16T08:43:46.703Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":80,"data":{"documentId":"npr0nt6ubvza2mj29xmp3oip","name":"closure","slug":"closure","createdAt":"2025-08-16T08:43:46.703Z","updatedAt":"2025-08-16T08:43:46.703Z","publishedAt":"2025-08-16T08:43:46.704Z","locale":null}}
{"type":"api::keyword.keyword","id":81,"data":{"documentId":"dhyvr91xocy59ncj5ds6365z","name":"prototype","slug":"prototype","createdAt":"2025-08-16T08:43:46.755Z","updatedAt":"2025-08-16T08:43:46.755Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":82,"data":{"documentId":"dhyvr91xocy59ncj5ds6365z","name":"prototype","slug":"prototype","createdAt":"2025-08-16T08:43:46.755Z","updatedAt":"2025-08-16T08:43:46.755Z","publishedAt":"2025-08-16T08:43:46.755Z","locale":null}}
{"type":"api::keyword.keyword","id":83,"data":{"documentId":"p5q6ntwnhog4d0c8xyrg1g8i","name":"prototype chain","slug":"prototype-chain","createdAt":"2025-08-16T08:43:46.762Z","updatedAt":"2025-08-16T08:43:46.762Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":84,"data":{"documentId":"p5q6ntwnhog4d0c8xyrg1g8i","name":"prototype chain","slug":"prototype-chain","createdAt":"2025-08-16T08:43:46.762Z","updatedAt":"2025-08-16T08:43:46.762Z","publishedAt":"2025-08-16T08:43:46.762Z","locale":null}}
{"type":"api::keyword.keyword","id":85,"data":{"documentId":"wpixg4fq6rr3t1xiorpsug7j","name":"Map","slug":"map","createdAt":"2025-08-16T08:43:46.824Z","updatedAt":"2025-08-16T08:43:46.824Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":86,"data":{"documentId":"wpixg4fq6rr3t1xiorpsug7j","name":"Map","slug":"map","createdAt":"2025-08-16T08:43:46.824Z","updatedAt":"2025-08-16T08:43:46.824Z","publishedAt":"2025-08-16T08:43:46.824Z","locale":null}}
{"type":"api::keyword.keyword","id":87,"data":{"documentId":"m59lttlaef4g5enj0x3cxvzn","name":"WeakMap","slug":"weakmap","createdAt":"2025-08-16T08:43:46.834Z","updatedAt":"2025-08-16T08:43:46.834Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":88,"data":{"documentId":"m59lttlaef4g5enj0x3cxvzn","name":"WeakMap","slug":"weakmap","createdAt":"2025-08-16T08:43:46.834Z","updatedAt":"2025-08-16T08:43:46.834Z","publishedAt":"2025-08-16T08:43:46.835Z","locale":null}}
{"type":"api::keyword.keyword","id":89,"data":{"documentId":"e4ylgee1jac4inv2eyk68o91","name":"Set","slug":"set","createdAt":"2025-08-16T08:43:46.839Z","updatedAt":"2025-08-16T08:43:46.839Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":90,"data":{"documentId":"e4ylgee1jac4inv2eyk68o91","name":"Set","slug":"set","createdAt":"2025-08-16T08:43:46.839Z","updatedAt":"2025-08-16T08:43:46.839Z","publishedAt":"2025-08-16T08:43:46.840Z","locale":null}}
{"type":"api::keyword.keyword","id":91,"data":{"documentId":"czht32dk25s1u8ppum78dnlv","name":"WeakSet","slug":"weakset","createdAt":"2025-08-16T08:43:46.846Z","updatedAt":"2025-08-16T08:43:46.846Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":92,"data":{"documentId":"czht32dk25s1u8ppum78dnlv","name":"WeakSet","slug":"weakset","createdAt":"2025-08-16T08:43:46.846Z","updatedAt":"2025-08-16T08:43:46.846Z","publishedAt":"2025-08-16T08:43:46.846Z","locale":null}}
{"type":"api::keyword.keyword","id":93,"data":{"documentId":"kx5b3ji0dn0i0zfenb22zt85","name":"synchronous","slug":"synchronous","createdAt":"2025-08-16T08:43:54.883Z","updatedAt":"2025-08-16T08:43:54.883Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":94,"data":{"documentId":"kx5b3ji0dn0i0zfenb22zt85","name":"synchronous","slug":"synchronous","createdAt":"2025-08-16T08:43:54.883Z","updatedAt":"2025-08-16T08:43:54.883Z","publishedAt":"2025-08-16T08:43:54.884Z","locale":null}}
{"type":"api::keyword.keyword","id":95,"data":{"documentId":"ma9ml10jvar7foe4qbvsm11b","name":"asynchronous","slug":"asynchronous","createdAt":"2025-08-16T08:43:54.892Z","updatedAt":"2025-08-16T08:43:54.892Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":96,"data":{"documentId":"ma9ml10jvar7foe4qbvsm11b","name":"asynchronous","slug":"asynchronous","createdAt":"2025-08-16T08:43:54.892Z","updatedAt":"2025-08-16T08:43:54.892Z","publishedAt":"2025-08-16T08:43:54.893Z","locale":null}}
{"type":"api::keyword.keyword","id":97,"data":{"documentId":"ucvoai2m2gq3yqcpxaq0hisr","name":"anonymous function","slug":"anonymous-function","createdAt":"2025-08-16T08:43:54.944Z","updatedAt":"2025-08-16T08:43:54.944Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":98,"data":{"documentId":"ucvoai2m2gq3yqcpxaq0hisr","name":"anonymous function","slug":"anonymous-function","createdAt":"2025-08-16T08:43:54.944Z","updatedAt":"2025-08-16T08:43:54.944Z","publishedAt":"2025-08-16T08:43:54.945Z","locale":null}}
{"type":"api::keyword.keyword","id":99,"data":{"documentId":"x7o845xytdjqdjqi1fd0t27s","name":"debounce","slug":"debounce","createdAt":"2025-08-16T08:43:55.006Z","updatedAt":"2025-08-16T08:43:55.006Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":100,"data":{"documentId":"x7o845xytdjqdjqi1fd0t27s","name":"debounce","slug":"debounce","createdAt":"2025-08-16T08:43:55.006Z","updatedAt":"2025-08-16T08:43:55.006Z","publishedAt":"2025-08-16T08:43:55.007Z","locale":null}}
{"type":"api::keyword.keyword","id":101,"data":{"documentId":"n6jj5tb694b1wq4vgs2guupz","name":"throttle","slug":"throttle","createdAt":"2025-08-16T08:43:55.015Z","updatedAt":"2025-08-16T08:43:55.015Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":102,"data":{"documentId":"n6jj5tb694b1wq4vgs2guupz","name":"throttle","slug":"throttle","createdAt":"2025-08-16T08:43:55.015Z","updatedAt":"2025-08-16T08:43:55.015Z","publishedAt":"2025-08-16T08:43:55.016Z","locale":null}}
{"type":"api::keyword.keyword","id":103,"data":{"documentId":"ezo82wji92u2spad1nkbzoev","name":"Typescript","slug":"typescript","createdAt":"2025-08-16T08:43:55.111Z","updatedAt":"2025-08-16T08:43:55.111Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":104,"data":{"documentId":"ezo82wji92u2spad1nkbzoev","name":"Typescript","slug":"typescript","createdAt":"2025-08-16T08:43:55.111Z","updatedAt":"2025-08-16T08:43:55.111Z","publishedAt":"2025-08-16T08:43:55.111Z","locale":null}}
{"type":"api::keyword.keyword","id":105,"data":{"documentId":"yj43y4no19tw48hmj5tweo9q","name":"interface","slug":"interface","createdAt":"2025-08-16T08:43:55.116Z","updatedAt":"2025-08-16T08:43:55.116Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":106,"data":{"documentId":"yj43y4no19tw48hmj5tweo9q","name":"interface","slug":"interface","createdAt":"2025-08-16T08:43:55.116Z","updatedAt":"2025-08-16T08:43:55.116Z","publishedAt":"2025-08-16T08:43:55.116Z","locale":null}}
{"type":"api::keyword.keyword","id":107,"data":{"documentId":"vsyv1c8d80wm9fgjsn8wpeqk","name":"type","slug":"type","createdAt":"2025-08-16T08:43:55.121Z","updatedAt":"2025-08-16T08:43:55.121Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":108,"data":{"documentId":"vsyv1c8d80wm9fgjsn8wpeqk","name":"type","slug":"type","createdAt":"2025-08-16T08:43:55.121Z","updatedAt":"2025-08-16T08:43:55.121Z","publishedAt":"2025-08-16T08:43:55.122Z","locale":null}}
{"type":"api::keyword.keyword","id":109,"data":{"documentId":"yc9dxm9fm2pcok5hwzhtu6cq","name":"React","slug":"react","createdAt":"2025-08-16T08:43:55.312Z","updatedAt":"2025-08-16T08:43:55.312Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":110,"data":{"documentId":"yc9dxm9fm2pcok5hwzhtu6cq","name":"React","slug":"react","createdAt":"2025-08-16T08:43:55.312Z","updatedAt":"2025-08-16T08:43:55.312Z","publishedAt":"2025-08-16T08:43:55.313Z","locale":null}}
{"type":"api::keyword.keyword","id":111,"data":{"documentId":"pu0btugq3mvoy4vr6iz5mexg","name":"useContext","slug":"usecontext","createdAt":"2025-08-16T08:43:55.319Z","updatedAt":"2025-08-16T08:43:55.319Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":112,"data":{"documentId":"pu0btugq3mvoy4vr6iz5mexg","name":"useContext","slug":"usecontext","createdAt":"2025-08-16T08:43:55.319Z","updatedAt":"2025-08-16T08:43:55.319Z","publishedAt":"2025-08-16T08:43:55.330Z","locale":null}}
{"type":"api::keyword.keyword","id":113,"data":{"documentId":"xa2mudnkloxosrwvw1ww96vu","name":"React-MobX","slug":"react-mobx","createdAt":"2025-08-16T08:43:55.359Z","updatedAt":"2025-08-16T08:43:55.359Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":114,"data":{"documentId":"xa2mudnkloxosrwvw1ww96vu","name":"React-MobX","slug":"react-mobx","createdAt":"2025-08-16T08:43:55.359Z","updatedAt":"2025-08-16T08:43:55.359Z","publishedAt":"2025-08-16T08:43:55.361Z","locale":null}}
{"type":"api::keyword.keyword","id":115,"data":{"documentId":"liwqcbsdhlqyqqbx4va96fg4","name":"virtual dom","slug":"virtual-dom","createdAt":"2025-08-16T08:43:55.450Z","updatedAt":"2025-08-16T08:43:55.450Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":116,"data":{"documentId":"liwqcbsdhlqyqqbx4va96fg4","name":"virtual dom","slug":"virtual-dom","createdAt":"2025-08-16T08:43:55.450Z","updatedAt":"2025-08-16T08:43:55.450Z","publishedAt":"2025-08-16T08:43:55.451Z","locale":null}}
{"type":"api::keyword.keyword","id":117,"data":{"documentId":"o60adg5q7fu6scgsdot5vskd","name":"jsx","slug":"jsx","createdAt":"2025-08-16T08:43:55.518Z","updatedAt":"2025-08-16T08:43:55.518Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":118,"data":{"documentId":"o60adg5q7fu6scgsdot5vskd","name":"jsx","slug":"jsx","createdAt":"2025-08-16T08:43:55.518Z","updatedAt":"2025-08-16T08:43:55.518Z","publishedAt":"2025-08-16T08:43:55.519Z","locale":null}}
{"type":"api::keyword.keyword","id":119,"data":{"documentId":"klq59zzm6rltlf6udy1bji10","name":"reconciliation","slug":"reconciliation","createdAt":"2025-08-16T08:43:55.612Z","updatedAt":"2025-08-16T08:43:55.612Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":120,"data":{"documentId":"klq59zzm6rltlf6udy1bji10","name":"reconciliation","slug":"reconciliation","createdAt":"2025-08-16T08:43:55.612Z","updatedAt":"2025-08-16T08:43:55.612Z","publishedAt":"2025-08-16T08:43:55.613Z","locale":null}}
{"type":"api::keyword.keyword","id":121,"data":{"documentId":"m9jui3u59kedw6236qzoa98n","name":"immutable update","slug":"immutable-update","createdAt":"2025-08-16T08:43:55.694Z","updatedAt":"2025-08-16T08:43:55.694Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":122,"data":{"documentId":"m9jui3u59kedw6236qzoa98n","name":"immutable update","slug":"immutable-update","createdAt":"2025-08-16T08:43:55.694Z","updatedAt":"2025-08-16T08:43:55.694Z","publishedAt":"2025-08-16T08:43:55.695Z","locale":null}}
{"type":"api::keyword.keyword","id":123,"data":{"documentId":"mopr22na6uvgagateqz09d9i","name":"shallow clone","slug":"shallow-clone","createdAt":"2025-08-16T08:43:55.700Z","updatedAt":"2025-08-16T08:43:55.700Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":124,"data":{"documentId":"mopr22na6uvgagateqz09d9i","name":"shallow clone","slug":"shallow-clone","createdAt":"2025-08-16T08:43:55.700Z","updatedAt":"2025-08-16T08:43:55.700Z","publishedAt":"2025-08-16T08:43:55.701Z","locale":null}}
{"type":"api::keyword.keyword","id":125,"data":{"documentId":"fnzzg3tyk4zxf8j055ks9m55","name":"deep clone","slug":"deep-clone","createdAt":"2025-08-16T08:43:55.704Z","updatedAt":"2025-08-16T08:43:55.704Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":126,"data":{"documentId":"fnzzg3tyk4zxf8j055ks9m55","name":"deep clone","slug":"deep-clone","createdAt":"2025-08-16T08:43:55.704Z","updatedAt":"2025-08-16T08:43:55.704Z","publishedAt":"2025-08-16T08:43:55.705Z","locale":null}}
{"type":"api::keyword.keyword","id":127,"data":{"documentId":"wqr1hhi6f374rlgsw1k4b1oc","name":"component","slug":"component","createdAt":"2025-08-16T08:43:55.756Z","updatedAt":"2025-08-16T08:43:55.756Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":128,"data":{"documentId":"wqr1hhi6f374rlgsw1k4b1oc","name":"component","slug":"component","createdAt":"2025-08-16T08:43:55.756Z","updatedAt":"2025-08-16T08:43:55.756Z","publishedAt":"2025-08-16T08:43:55.757Z","locale":null}}
{"type":"api::keyword.keyword","id":129,"data":{"documentId":"p3sr4d8tq0ym9835373e4p5w","name":"mount","slug":"mount","createdAt":"2025-08-16T08:43:55.761Z","updatedAt":"2025-08-16T08:43:55.761Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":130,"data":{"documentId":"p3sr4d8tq0ym9835373e4p5w","name":"mount","slug":"mount","createdAt":"2025-08-16T08:43:55.761Z","updatedAt":"2025-08-16T08:43:55.761Z","publishedAt":"2025-08-16T08:43:55.761Z","locale":null}}
{"type":"api::keyword.keyword","id":131,"data":{"documentId":"acjrmgk1z1em5xd1m3yu3qbv","name":"unmount","slug":"unmount","createdAt":"2025-08-16T08:43:55.765Z","updatedAt":"2025-08-16T08:43:55.765Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":132,"data":{"documentId":"acjrmgk1z1em5xd1m3yu3qbv","name":"unmount","slug":"unmount","createdAt":"2025-08-16T08:43:55.765Z","updatedAt":"2025-08-16T08:43:55.765Z","publishedAt":"2025-08-16T08:43:55.766Z","locale":null}}
{"type":"api::keyword.keyword","id":133,"data":{"documentId":"k6nooz1a72brwqq9bkch9zmq","name":"update","slug":"update","createdAt":"2025-08-16T08:43:55.769Z","updatedAt":"2025-08-16T08:43:55.769Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":134,"data":{"documentId":"k6nooz1a72brwqq9bkch9zmq","name":"update","slug":"update","createdAt":"2025-08-16T08:43:55.769Z","updatedAt":"2025-08-16T08:43:55.769Z","publishedAt":"2025-08-16T08:43:55.770Z","locale":null}}
{"type":"api::keyword.keyword","id":135,"data":{"documentId":"v0ma38kzcouhpcb86656tcxh","name":"side-effect","slug":"side-effect","createdAt":"2025-08-16T08:43:55.813Z","updatedAt":"2025-08-16T08:43:55.813Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":136,"data":{"documentId":"v0ma38kzcouhpcb86656tcxh","name":"side-effect","slug":"side-effect","createdAt":"2025-08-16T08:43:55.813Z","updatedAt":"2025-08-16T08:43:55.813Z","publishedAt":"2025-08-16T08:43:55.814Z","locale":null}}
{"type":"api::keyword.keyword","id":137,"data":{"documentId":"s5anwdco1uvwwkdmoru8jcej","name":"useEffect","slug":"useeffect","createdAt":"2025-08-16T08:43:55.818Z","updatedAt":"2025-08-16T08:43:55.818Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":138,"data":{"documentId":"s5anwdco1uvwwkdmoru8jcej","name":"useEffect","slug":"useeffect","createdAt":"2025-08-16T08:43:55.818Z","updatedAt":"2025-08-16T08:43:55.818Z","publishedAt":"2025-08-16T08:43:55.818Z","locale":null}}
{"type":"api::keyword.keyword","id":139,"data":{"documentId":"epky9p21jh3i8ltxa63gbzxa","name":"useCallback","slug":"usecallback","createdAt":"2025-08-16T08:43:55.891Z","updatedAt":"2025-08-16T08:43:55.891Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":140,"data":{"documentId":"epky9p21jh3i8ltxa63gbzxa","name":"useCallback","slug":"usecallback","createdAt":"2025-08-16T08:43:55.891Z","updatedAt":"2025-08-16T08:43:55.891Z","publishedAt":"2025-08-16T08:43:55.891Z","locale":null}}
{"type":"api::keyword.keyword","id":141,"data":{"documentId":"recf7q5ix5goj27tqe8ha91r","name":"useMemo","slug":"usememo","createdAt":"2025-08-16T08:43:55.895Z","updatedAt":"2025-08-16T08:43:55.895Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":142,"data":{"documentId":"recf7q5ix5goj27tqe8ha91r","name":"useMemo","slug":"usememo","createdAt":"2025-08-16T08:43:55.895Z","updatedAt":"2025-08-16T08:43:55.895Z","publishedAt":"2025-08-16T08:43:55.896Z","locale":null}}
{"type":"api::keyword.keyword","id":143,"data":{"documentId":"tw2k6nizjc0lgdshy5eechog","name":"useRef","slug":"useref","createdAt":"2025-08-16T08:43:55.925Z","updatedAt":"2025-08-16T08:43:55.925Z","publishedAt":null,"locale":null}}
{"type":"api::keyword.keyword","id":144,"data":{"documentId":"tw2k6nizjc0lgdshy5eechog","name":"useRef","slug":"useref","createdAt":"2025-08-16T08:43:55.925Z","updatedAt":"2025-08-16T08:43:55.925Z","publishedAt":"2025-08-16T08:43:55.925Z","locale":null}}
{"type":"api::post.post","id":16,"data":{"documentId":"um9uhccsuzjp2vws27hnpw2i","slug":"2023-web-conf","title":"Web Conf 2023 心得與收穫","date":"2025-08-16T08:43:53.949Z","description":" 一直以來沒有參加過這種大型付費的 conference，又聽說這是睽違十年後再次舉辦 的 webConf ，所以就算現在幾乎都在開發 APP 還是想來看看，畢竟 Web 領域是我剛轉職時主要學的。況且學習前端技術的過程中，讀過不少這次議程講者的書籍或文章，甚至是課程，參加這個活動某種程度上是偶像見面會的概念（？另外，就是想透過這次的 conf 知道現在外面主流開發的方式與技術是什麼？","content":"\n---\n\n![2023 Web Conf](./20230811_131223.jpg)\n\n## 參加的動機\n\n一直以來沒有參加過這種大型付費的 conference，又聽說這是睽違十年後再次舉辦 的 webConf ，所以就算現在幾乎都在開發 APP 還是想來看看，畢竟 Web 領域是我剛轉職時主要學的。況且學習前端技術的過程中，讀過不少這次議程講者的書籍或文章，甚至是課程，參加這個活動某種程度上是偶像見面會的概念（？另外，就是想透過這次的 conf 知道現在外面主流開發的方式與技術是什麼？\n\n<!--truncate-->\n\n![2023 Web Conf](./20230811_084509.jpg)\n\n![](./20230813_162936.jpg)\n\n<small>\n  剛好之前買過的書都有擔任這次活動的講者，另外 PJ 、Summer\n  的文章在我學習前端的過程中也幫助我不少\n</small>\n\n---\n\n## 會後的感受\n\n_可以說是既興奮又焦慮，但焦慮的部分多了一些。_\n\n得到了很多新的觀點跟技術，以及開發想法的啟發，這些都讓我感到很興奮，前端的講者都很有料！3400 元值回票價！但同時又覺得憂慮，這兩天議程下來得到技術和工具超多，越知道更多的新知識，越覺得自己對這個領域的認知好渺小（能力也是，一時之間不知道可不可以吸收完這些大神的精華？AI 目前在程式開發的應用，所增進的開發體驗有限，但未來的發展可以說是指日可待，會不會哪一天就不需要工程師了？哇～原來別的開發團隊原來都是利用這些 CICD工具去提升開發的效率，增進團隊溝通，為啥自己待的開發團隊什麼都沒做？\n\n---\n\n## 收穫\n\n### 前端工程師的不同樣貌\n\n雖然職稱都掛著前端工程師，但每一個前端工程師所著重的技術都不太一樣，在這次議程的主講者中，有的就是著重於網頁互動設計、WebGL、動態特效 ; 有的著重於 Frontend Infra 前端基礎建設，也就是前端架構師 ; 有的則是網頁產品開發 ; 我自己也算是個蠻異類的前端，主要的技能樹都點在 React Native APP 跨平台開發。\n\n### 開發者體驗(Dev Experience)的重要性\n\n兩天的議程下來，不同的講者分別都強調了開發者體驗的重要性，很多時候我們在開發產品時很重視使用者體驗(User Experience)，往往忽略了開發者體驗(Dev Experience) ，然而開發者體驗可以帶給開發團隊的好處是提升開發效率和產品產量，當然也可以減少重複造輪子。在 Kyle 和 PJ 的分享中分享了不少關於如何在產品開發的過程中加入工具去提升團隊開發的品質，例如：CI/CD pipeline 優化的工具、利用透過 Script 或 Hooks 去自動化團隊專案的 Coding Style 讓機器人去擋下不符合規範的提交，也可以減少直接對人糾正的尷尬。在 Summer 的分享中則是怎麼樣去衡量網頁效能，並且利用 Sentry 去追蹤與記錄問題、觀察使用者的操作情況，進而打造一個自動化的效能系統，提升產品的穩定度。（以上的內容都很精彩，詳細的分享文章我整理在下方。）\n\n不過，要如何去應用這些工具和制定流程，主要還是要看開發團隊的文化和業務情況，依照不同的情境導入相對合適的工具，才會對整體開發體驗產生良好的影響，否則就失去了提升開發效率的美意了。\n我也要好好的去思考有哪些工具可以放入我的專案中了～\n\n### 前端技術迭代速度好快，快到學不動了\n\n剛轉職時有寫過一段時間的 Vue2 + Vuex ，後來都在寫 React 就快把 Vue 忘光了，趁著這次 Kuro 分享 Vue.js 的狀態管理模式，稍微的快速複習了 Vue ，發現 Vue 3 的 compostion api 在處理狀態和重用邏輯的部分與 React 的 hook 相似，看起來貌似比 Vue2 好寫多了。在狀態管理的部分以前用 Vuex 處理全域狀態都要透過從 Vuex 的 store state 拿出存放資料拿出來至vue compomnent => 若有非同步處理則還需要從 compomnent 更新觸發 Action =>Action 函數中調用 commit 方法來觸發 Mutations=> 更新 Vuex 中的狀態，一連串的要更新一個狀態需要很多繁瑣的步驟，反之，在 Vue 3 官文文件中直接將全域的狀態更新工具改成了 Pinia ，語法操作更簡單，取消了 mutation，跟 TypeScript 整合度更好。真是感嘆前端技術迭代太快了～沒想到不到兩年的時間又有更新更好用的東西，也不知道多久後又會有新的技術出來取而代之呢？\n\n剛好聽到幾個講者在講十年前專精於 Flash 的技術（老實說我是第一次聽到，原來十年前的前端是要點的技能是這個），但現在的瀏覽器的都不支援了，就更有感。或許，身為開發者都要有這樣的覺悟：這一行本來就是沒辦法只學某幾種技術就能一輩子以此為生，也不是說舊的技術不好，一定會有公司需要人維護（除非就像 flash 死透了），但如果能 open mind 去學習新的技術，在職涯的路上選擇會比較寬闊。\n\n### 原生 HTML element + Web api + CSS 就很好用\n\n做表單 Form 一直是我覺得前端處理很麻煩的部分，又要透過 DOM 取值做資料驗證，又要顧及使用者體驗。Paul 在分享中，展示了許多用 HTML 原生 element 、CSS 、web api 的就可以處理的功能。例如：\n\n- [CSS: accent-color](https://developer.mozilla.org/en-US/docs/Web/CSS/accent-color) 可以直接改某些 HTML element 的顏色\n\n```html title=\"HTML\"\n<input type=\"checkbox\" />\n<input type=\"range\" />\n<progress></progress>\n```\n\n- form 驗證可以使用[ValidityState web api](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState)處理\n\n- [CSS > :has()](https://developer.mozilla.org/en-US/docs/Web/CSS/:has)可以判斷是否顯示 element ，不需要透過 Javascript event 監聽\n\nHTML 本身的屬性就可以做到基本 Type 檢查，搭配 Web api ，就可以避免使用 Javascript 去處理，減少效能浪費，更讚的是，可以輕鬆的延續使用者的體驗。\n\n---\n\n## 逛攤位的戰利品\n\n![](./20230811_132426.JPG)\n\n我蠻喜歡去搜集貼紙的，趁機搜刮了一些貼紙～還在六角的攤位玩了一個心理測驗，測出來的結果是：\n\n![](./20230811_130550.jpg)\n\n![](./20230813_165751.jpg)\n\n在天瓏的攤位用便宜的價錢入手了這本書，對這本書的印象是在星巴哥的技術專欄上看到有關這本書重構技巧的分享，希望我有時間可以看完它。\n\n---\n\n最後，分享覺得整場最有道理的一句話：\n\n## ![](./20230811_155716.jpg)\n\n---\n\n## 講者分享連結整理\n\n- [大會共筆](https://hackmd.io/@webconf/BkImQ0Ds3/%2FwHBNj8NPQamxPecU9VXoHQ)\n\n- [Will 保哥/活用 GitHub Copilot 開發 Web 應用程式 PPT](https://drive.google.com/file/d/1W7KZ2vwsZyyIC_iMdCxgadXWodWkrU6u/view?fbclid=IwAR0lAS-jXIksFcd08w9gGWJnZGPvHKTN_7n_z1fQDf8koHyQ52EiRawRpmk)\n\n- [Ruddy 老師/AI 驅動下的開發者體驗 PPT](https://onedrive.live.com/?authkey=%21APB1fAuO9FcMusg&id=68B24674607C69D9%21349589&cid=68B24674607C69D9)\n\n- [奶綠茶/WebComponent 的好，用過的都知道 PPT](https://speakerdeck.com/milkmidi/webcomponent)\n- [莫力全(Kyle Mo)/成為前端建築師吧！透過 Frontend Infra 為前端應用打造穩健且高效率的開發體驗 PPT](https://slides.com/oldmo860617/minimal)、[文章](https://oldmo860617.medium.com/%E6%88%90%E7%82%BA%E5%89%8D%E7%AB%AF%E5%BB%BA%E7%AF%89%E5%B8%AB%E5%90%A7-%E9%80%8F%E9%81%8E-frontend-infra-%E7%82%BA%E5%89%8D%E7%AB%AF%E6%87%89%E7%94%A8%E6%89%93%E9%80%A0%E7%A9%A9%E5%81%A5%E4%B8%94%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E9%96%8B%E7%99%BC%E9%AB%94%E9%A9%97-21566b5c95d3)\n- [李明/穿越互動特效網站演化的軌跡 參考文章](https://blockstudio.tw/blog/blog-web-animation-sop)\n- [Paul Li / 鳳‧極意？！](https://blog.lalacube.com/mei/Reveal_phoenix_the_gokui.php?page=1)\n- [Summer Tang/從零打造前端效能監測系統逐字稿](https://www.cythilya.tw/2023/08/12/build-front-end-performance-monitoring-mechanism-from-scratch-webconf-tw-2023/)\n- [小賴/【工作坊】Docker Container 是什麼？可以吃嗎？](https://hackmd.io/@webconf/BkImQ0Ds3/%2FhOq4Qte_TnSy0z8-dcCuig?utm_source=badge&utm_medium=badge&utm_campaign=webconf2023&fbclid=IwAR2DzggADz_M6lyBoJl8Bd87iJmjTYbzJeFvL-wJj3k3YuuszgxdmwSc4rc)\n- [Soking/資訊架構設計新體驗：在需求情境中運用領域事件分析描述結構化內容](https://drive.google.com/file/d/1MXtx08mLPB4_VTRmMr6Bp9pRKY3V2fWm/view?ck_subscriber_id=2283616400&pli=1)\n  以上是我自己有聽的場次＆講者有分享資料的\n\n:::note\n\n本篇文章原先發佈於[Medium](https://wwwwwwwe.medium.com/2023-web-conf-%E5%BF%83%E5%BE%97%E8%88%87%E6%94%B6%E7%A9%AB-e1dba2cb5909)，之後會陸續將 Medium 撰寫的內容慢慢遷移到這個網站。\n","createdAt":"2025-08-16T08:43:45.489Z","updatedAt":"2025-08-16T10:26:29.700Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":18,"data":{"documentId":"g2k3tkcck36qwnm72lwm2ko9","slug":"2023-ironman-event","title":"2023 iThome 鐵人賽頒獎典禮後記","date":"2025-08-16T08:43:53.992Z","description":"第一次參加了而且完成了 it 鐵人賽的挑戰，雖然這次沒有得獎，但好奇頒獎典禮拿獎的都會是什麼樣的人，還有會有什麼有趣的內容、再加上這次組隊的朋友拿獎了，就決定去頒獎典禮看看。 地點好像跟之前幾屆的一樣在輔大的百鍊廳，從校門口走到百鍊廳有點距離，~~想當初上次來輔大還只是個高中生~~ 開箱：鐵人鍊成獎＋團隊鍊成獎 到了報到處，拿到了一個神秘的紙袋，裡面包含了頒獎典禮的與會吊牌，還有鐵人賽的獎狀、跟個人完賽與團賽的獎牌跟一個鐵人鍊成的紀念卡套，喔，如果有得獎的話，鐵人鍊成獎牌就要上台領獎的時候才會拿到有包含獎項名字的獎牌。（基本上，如果沒得獎的話領完就可以走了（？","content":"\n第一次參加了而且完成了 it 鐵人賽的挑戰，雖然這次沒有得獎，但好奇頒獎典禮拿獎的都會是什麼樣的人，還有會有什麼有趣的內容、再加上這次組隊的朋友拿獎了，就決定去頒獎典禮看看。\n\n![](./20240106_134049.jpg)\n\n<!--truncate-->\n\n地點好像跟之前幾屆的一樣在輔大的百鍊廳，從校門口走到百鍊廳有點距離，~~想當初上次來輔大還只是個高中生~~\n\n![](./20240106_134000.jpg)\n\n## 開箱：鐵人鍊成獎＋團隊鍊成獎\n\n到了報到處，拿到了一個神秘的紙袋，裡面包含了頒獎典禮的與會吊牌，還有鐵人賽的獎狀、跟個人完賽與團賽的獎牌跟一個鐵人鍊成的紀念卡套，喔，如果有得獎的話，鐵人鍊成獎牌就要上台領獎的時候才會拿到有包含獎項名字的獎牌。（基本上，如果沒得獎的話領完就可以走了（？\n\n![](./20240106_172410.jpg)\n\n![](./20240107_155321.jpg)\n\n很特別的是卡套的裡面放了一張卡片，掃了 QRcode 就可以連結到自己的鐵人賽文章。\n\n## 頒獎典禮入場\n\n場地不大，有點糟的是裡面完全收不到訊號，沒網路好焦慮～\n開場後就是一些重要的嘉賓致詞、評審致詞、然後冠軍得獎者致詞以下省略...\n\n![](./20240106_140200.jpg)\n\n![頒發佳作獎](./20240106_154646.jpg)\n\n## 收穫\n\n整場頒獎典禮下來，對我來說最有用的就是評審與一些得獎者講述了**撰寫鐵人賽的幾個重要的技巧**:\n\n- 1.平常的時候就可以多搜集幾個素材，就可以此畫出一個架構延伸內容。\n- 2.文章寫完一定要重新讀過一遍。\n- 3.圖片的比例大小會影響閱讀文章的感受。\n- 4.文章是要寫給別人閱讀的，所以字字句句需要能夠清楚表達所要傳達資訊。\n- 5.最棒的題材就是你的實務經驗。\n\n蠻有趣的是，評審有提到這次有用 ChatGpt 分析參賽者的文章做為評分的參考 XD 也有人提到他們可以辨別文章是不是 ChatGpt\n寫的，方法就是看看文章有沒有錯別字，因為 it 人國文都不太好，文章多少都會有錯別字 XD\n\n## 感想\n\n看完頒獎典禮，真心的覺得這些得獎的人真的好強，好幾個人同時報了兩組還都有拿到獎，不禁懷疑這些人都不用睡嗎？！也有人第一次參賽就拿冠軍的超厲害！\n\n老實說，我覺得要連續不中斷寫 30 天文章(而且能兼顧文章品質的)真的太痛苦了～幸好這次是組團參加，不然我一定撐不下去的，但是藉由這次的經驗讓我好好重新把過去開發時沒弄清楚的觀念重新整理過，也是個很不錯的收穫！\n\n下一屆如果要參加的話，我應該會先把整體的架構先理清楚，早一點把一些內容整理好，希望到時候我可以有時間參加。\n\n這麼『痛苦』的經驗，我推薦各位工程師有機會務必要體驗一下哈哈，除了體驗將知識內化的過程，還有提升自己寫能**讓別人看得懂**的文件的能力。\n","createdAt":"2025-08-16T08:43:45.526Z","updatedAt":"2025-08-16T10:25:14.789Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":20,"data":{"documentId":"n4tfyed6eyx968i9qhh4g4kj","slug":"2024-react-conf","title":"從 2024 React Conf 看 React Native 發展","date":"2025-08-16T08:43:54.020Z","description":"從 2024 React Conf 看 React Native 發展 今年的 React Conf 除了眾所矚目的 React 19 ，同時以 meta 開發團隊開發的 React Native 也帶來了不少亮點。有關於 React Native 的討論都集中在第二天的議程。 New Architecture 上 beta 了 截至 2024 年 3 月 React Native 的在 npm 上的每週下載數突破了220萬，越來越多的開發者使用;同時 React Native 開發團隊也宣布 New Architecture 終於上 beta 了，從 0.68 版本 2022 年 3 月在...","content":"\n# 從 2024 React Conf 看 React Native 發展\n\n今年的 React Conf 除了眾所矚目的 React 19 ，同時以 meta 開發團隊開發的 React Native 也帶來了不少亮點。有關於 React Native 的討論都集中在[第二天的議程](https://www.youtube.com/watch?v=0ckOUBiuxVY)。\n\n### New Architecture 上 beta 了\n\n截至 2024 年 3 月 React Native 的在 npm 上的每週下載數突破了220萬，越來越多的開發者使用;同時 React Native 開發團隊也宣布 New Architecture 終於上 beta 了，從 0.68 版本 2022 年 3 月在 React Native 加入了 New Architecture 到現在升級到 0.74 版本後使用 react-native-cli 可以分別在 Android 的 `gradle.properties` 啟用、iOS 則是在 iOS 的位置執行 `bundle install && RCT_NEW_ARCH_ENABLED=1 bundle exec pod install`、使用 Expo 則可以 Expo 51 的設定檔案分別開啟 iOS 跟 Android 是否支援 New Architecture。官方是建議大家可以先玩看看新架構，然後如果有遇到問題的話幫忙回報一下 issue。\n\n<!--truncate-->\n\n至於為什麼要改整個大改呢？這就要回歸到現在 React Native 的架構，目前的 Javascript 用 bridge 的方式和原生構通，透過 JSON 反序列化和序列化經由 bridge 來傳遞訊息，但使用 bridge 來溝通一次只能有一端通過，而且每傳遞一次就要用 JSON 反序列化和序列化來轉換資料，是相當耗費的效能的。\n\n那麼 New Architecture 是如何改善這個問題呢？主要使用 JavaScript Interface（簡稱 JSI ）讓 JavaScript 與原生進行溝通，JSI 是用 C++ 寫的，他使用 memory sharing 的方式讓 JavaScript 層與 native 層溝通，也可以讓 JavaScript 同步運行在 native 層，直接讓 JavaScript 程式碼呼叫原生程式碼的函數，更有效率地去直接溝通原生層。\n\n### 官方建議使用 React native framework - Expo\n\n這次官方也宣布他們改了 [React native 的官網](https://reactnative.dev/docs/environment-setup)，從 0.75 開始版本開始，直接建議開發者使用 Framework 來開發，例如：Expo，先針對先前對於 Expo 的原生支援度不足等原因而採用 react-native-cli 作為開發選項的痛點，Expo 這次更新了一些功能以提升開發者體驗：\n\n#### 原生的支援\n\n對於原生的支援 Expo 提供了\n\n- Expo sdk : 提供了一些原生的 api，例如：camera、location、notification...等\n  ![Expo sdk ](./expo-sdk.png)\n\n- Expo module api : 使用 Expo module api 可以寫自己原生 kotlin、swift 的 module 引入 React-Native 專案\n\n![Expo module api](./expo-module-api.png)\n\n#### expo router\n\n採取 file system-based routing 的設計，分別針對 iOS 跟 Android、web 、 tv OS 給出不同的 UX 設計。\n\n#### 管理原生程式碼\n\n使用 continuous native generation 管理原生程式碼\n![cng](./cng.png)\n\n整體看下來，如果 Expo 這些功能可以解決原生支援度不足、可以整合自己寫原生的引入專案、再加上整合 build 跟 deploy 的平台，整體的開發者體驗相較使用 react-native-cli 來的好很多，如果有用過 Xcode build ipa 檔案或 android command line build apk 檔案、aab 檔案就可以心領神會其中的痛苦～但是我覺得這背後有一個隱憂就是 Expo 是一間私人的公司，會不會當使用者累積到一個量後，使用 Expo 的服務就會新增一些要考量的開發成本？\n\n順道一提，React Conf 的 App 就是使用了 Expo 開發的，當然也有包含上方提及的新功能，都可以在 https://github.com/expo/react-conf-app 的 repo 中看到實際的應用。\n\n### 多元的開發應用\n\nReact native 除了可開發出支援 iOS 、 Android、 Mac OS 、Window 系統的應用程式，React 可以開發這麼多不同的系統，就是基於 react 可以在 Render 階段則是將 Reconciler 時定義好的描述結構轉換使用專屬的 Render 去轉成 Native 的元件。\n\n在這一次的 conf 中可以看到 React native 也可以開發出支援 Apple vision pro 的應用程式，又 Amazon 的工程師也分享了如何 React native 去開發支援 TV OS 系統應用程式的經驗。\n\n### React native 未來的發展\n\n最後 Meta 的 React native 開發團隊分享了未來十年 React native 的開發藍圖：提升 React native 與 Web 的相容性與一致性，確保在不同的平台都有相同開發的體驗，以降低學習曲線。例如：ˋflexboxˋ 這個屬性在 React native 的 styleSheet 跟 CSS 在 web 瀏覽器的應用有一些不同。\n\n![](./1.png)\n\n#### React Native core\n\n現行的 React Native 使用 React Native Core 將 React Element 轉換成原生的元素。\n\n![](./2.png)\n\n在 React Native core 中，Yoga 這個 layout 引擎負責計算 React Native layout 跟 styling 位置，後經過 React Native Runtime 後交由 React Native Renderer 去負責渲染各個平台的視圖，例如： Webview 、UI kit 、 Android ...等。\n\n#### React DOM\n\n![](./3.png)\n\nReact 則是使用 React DOM 將 React Element 繪製成瀏覽器實際 DOM 元素。\n\n#### React strict DOM\n\n![React strict DOM](./4.png)\n\n為了要提升 React code sharing 以整合 codebase 在 UI 上支援 web 瀏覽器和 VR 介面...等，React strict DOM 就是基於這個目的而開發的，它可以整合 React Native 和 React ，讓 web api 也可以在 React Native 中使用。\n\n例如：\n\n##### Unified Styling\n\n```jsx\nimport { css } from \"react-strict-dom\";\nconst styles = css.create({\n  container: { borderTopWidth: 1 },\n  h1: {\n    padding: 10,\n    backgroundColor: \"#EEE\",\n  },\n  content: {\n    padding: 10,\n  },\n  div: {\n    paddingTop: 50,\n    backgroundColor: \"#000\",\n  },\n});\n```\n\n可以把 web css api 支援到 React Native ，像是偽元素、 media query。\n\n##### Unified markup\n\n```jsx\nimport { html } from \"react-strict-dom\";\n<html.div style={style.container}>\n  <html.h1 style={style.h1}>{title}</html.h1>\n  <html.div style={style.content}>{children}</html.div>\n</html.div>;\n```\n\n可以在 React Native 中去使用 HTML 開發 web 。\n\n![](https://user-images.githubusercontent.com/239676/205388313-e58f8793-51cd-4a6e-86e7-89425fd2d0e1.png)\n\n#### 結論\n\nReact strict DOM 最終的目的是讓 codebase 整合成一個，但是共享整個 codebase 跨平台並非主要的目標，應該是合理的去共享這些 code，這樣才可以花更多時間在處理各個平台的不同 UI 細節，而未來新的 web 功能將隨著時間的推移發佈到 React Native ，以提升 web 的相容性。\n\n目前使用 React 開發 web 跟使用 React Native 開發 app 的體驗是截然不同的，在樣式方面 web 使用 css api、React Native 則是使用 styleSheet；同樣是寫 JSX 的標籤 react 不需要引用、React Native 則是需要從 React Native module 引入 component ，再加上其實有很多支援瀏覽器的屬性現階段在 React Native 是不支援的。\n\n透過 React strict DOM 的開發可以看見開發團隊欲將 React 的生態系整合的決心，如果真的可以將 web 的 api 都可以整合到 React Native 中，那麼就可以真正的實踐 Learn once, write anywhere. ，目前看起來整合的複雜度很高、要解決的問題也不少，還需要一段時間等待。\n\n有關於 React strict DOM 的討論可以參考這個 [RFC: React DOM for Native (reduce API fragmentation) ]https://github.com/react-native-community/discussions-and-proposals/pull/496\n","createdAt":"2025-08-16T08:43:45.570Z","updatedAt":"2025-08-16T10:25:15.225Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":22,"data":{"documentId":"z0vua2p52z8jwz174ekzp9bc","slug":"2024-iroman","title":"2024 iThome 鐵人賽得獎心得","date":"2025-08-16T08:43:54.057Z","description":"2024 年是我第二次參加 iThome 舉辦的鐵人賽，這次居然入選了 佛心分享組的佳作，看到自己的作品被放到 得獎名單 的網站上，真是感到非常意外啊！ 這次選擇參加佛心分享組就是沒想要跟別人比賽，這樣寫起來壓力比較不會那麼大，雖然還是有連續 30 天發文的壓力，但是主要還是想聚焦於自己，把參加的過程當成一個練習。 參賽的初衷就只是想要加強自己前端技能，想要更清楚的把過去不太懂的知識點再加強，重新梳理一遍，練習用自己的話寫出來，大概就是一個跟自己比賽的過程，因為我很常半途而廢，能完成就覺得很不錯了，更何況得了一個小小的獎，實在是受寵若驚（？","content":"\n![](./2024120902.png)\n2024 年是我第二次參加 iThome 舉辦的鐵人賽，這次居然入選了 **佛心分享組的佳作**，看到自己的作品被放到 [得獎名單](https://ithelp.ithome.com.tw/2024ironman/reward) 的網站上，真是感到非常意外啊！\n\n<!--truncate-->\n\n![](./2024120901.png)\n\n這次選擇參加佛心分享組就是沒想要跟別人比賽，這樣寫起來壓力比較不會那麼大，雖然還是有連續 30 天發文的壓力，但是主要還是想聚焦於自己，把參加的過程當成一個練習。\n\n參賽的初衷就只是想要加強自己前端技能，想要更清楚的把過去不太懂的知識點再加強，重新梳理一遍，練習用自己的話寫出來，大概就是一個跟自己比賽的過程，因為我很常半途而廢，能完成就覺得很不錯了，更何況得了一個小小的獎，實在是受寵若驚（？）\n\n這次鐵人賽的作品：\nhttps://ithelp.ithome.com.tw/users/20162496/ironman/7698\n\n同時也有整理在這邊：\nhttps://wintersprouter.github.io/frontend-notes/docs/tags/2024-i-t鐵人賽\n\n這次好像有得到一個 2024 賽季紀念品，等到時候收到再分享上來。\n","createdAt":"2025-08-16T08:43:45.603Z","updatedAt":"2025-08-16T10:25:14.802Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":24,"data":{"documentId":"jzv0a8xos3p4x49azm7ghxvt","slug":"2024-web-conf","title":"Web Conf 2024 心得與回顧","date":"2025-08-16T08:43:54.083Z","description":" 第二次 參加 Web Conf ，這次的議程一樣精彩豐富，甚至有幾個議程同時排在一起讓我一時難以抉擇。兩天的聽完的心得大致上是覺得有些收穫的，對於技術迭代的知識焦慮倒是還好，因為平常就有在看這些東西，所以這次議程有些內容對我來說也算是複習，當然也還是有得到一些新的知識與觀點。 回顧 以下就我有聽的議程且較有印象的內容做一個回顧： !2024 WebConf 1. 有限狀態機與 RxJS - 奶綠茶 有限狀態機與 RxJS 這兩個題目剛好我都不熟。","content":"\nimport { HTMLPreview } from \"../../src/components/mdx/index.js\";\n\n![2024 WebConf](./360855.jpg)\n\n## 2024 WebConf\n\n第二次 參加 Web Conf ，這次的議程一樣精彩豐富，甚至有幾個議程同時排在一起讓我一時難以抉擇。兩天的聽完的心得大致上是覺得有些收穫的，對於技術迭代的知識焦慮倒是還好，因為平常就有在看這些東西，所以這次議程有些內容對我來說也算是複習，當然也還是有得到一些新的知識與觀點。\n\n<!--truncate-->\n\n![](./360858.jpg)\n\n## 回顧\n\n以下就我有聽的議程且較有印象的內容做一個回顧：\n\n![2024 WebConf](./360856.jpg)\n\n### 1. 有限狀態機與 RxJS - 奶綠茶\n\n有限狀態機與 RxJS 這兩個題目剛好我都不熟。\n在前端的開發中很常會需要實作狀態的管理，在這個議程中講者用紅綠燈的案例很清楚的說明了什麼是有限狀態機。\n\n有限狀態機（Finite State Machine, FSM）包括以下幾個特色：\n\n- 同一時間點，只會出存在一種狀態\n- 有限數量的狀態 state\n- 有限數量的事件 event 一定在時間內轉換到下一個狀態\n- 一個 initial state\n- 一個轉換的函式，傳入當下事件跟狀態去轉換狀態\n- n 個 final state\n\n就紅綠燈來說基本上同時間只會有一個狀態，綠、黃、紅，而且燈號的轉換事件數量是有限的且有規則可循的。\n\n使用有限狀態機的目的就是用來收斂需求的規格，讓狀態結構更加清晰，提升可維護性，而且使用現成的有限狀態機 library [xstate](https://github.com/statelyai/xstate)可以讓狀態圖易於視覺化，有助於工程師與設計師理解整個邏輯流程。\n\n[RxJS](https://rxjs.dev/) 則是一個基於 functional programming 精神設計的 library，透過 Observable 來處理複雜的非同步事件流，可以將多個運算符組合再一起，讓程式碼更加簡潔，也更容易閱讀。\n\n適合用來實作拖拉的功能，例如：拖拉的過程中會有 mousemove 事件，這個事件會不斷觸發，透過 RxJS 可以很容易的處理這個事件流，並且可以透過運算符來過濾掉不必要的事件。\n\n稍微看了一下 RxJS 文件，看起來要使用需要花一點時間學習，感覺有點複雜。對了，除了技術上的知識，講者有提到建議大家去閱讀熱門開源專案的程式碼。\n\n### 2. 個人專案到產品：善用 AI 工具打造可盈利產品 - 王鵬傑 PJ Wang\n\n這場是 Explian this 的作者，我很常閱讀他們家的文章，甚至曾有想付費訂閱，但是覺得要讀的東西太多，感覺負荷不了就作罷。講者分享他們怎麼去選擇 side project 的題目，還有打造產品的流程與思路。\n\n[product hunt](https://www.producthunt.com/) 是個適合參考選題的地方。\n\n雖然我沒有要做 side project 的打算，但是整場我必須說最有共鳴的應該是寫 side project 還是要找價值觀跟個性接近的同伴一起，當然不只是寫 side project ，很多時候都是。\n\n### 3. 如何撰寫具彈性的測試程式 - Summer\n\n[如何撰寫具彈性的測試程式逐字稿](https://www.cythilya.tw/2024/12/27/webconf2024-ui-causes-testing-to-fail/)\n\n這場內容本身很棒，但是這些內容已經有在他的書裡面寫過，我也剛好讀過了...。\n\n### 4. 十年回首：React 的過去、現在與未來發展 - Zet\n\n[簡報](https://slides.com/tz5514/react-webconf2024)\n\n這場我覺得有點可惜的是前面講者花了太多時間在描述 React 的渲染策略，這些他的書裡面都有，我也讀過了:[《React 思維進化》讀書筆記](https://wintersprouter.github.io/frontend-notes/docs/category/react-%E6%80%9D%E7%B6%AD%E9%80%B2%E5%8C%96%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98)\n。\n\n最有收穫的部分是 React Fiber 底層架構，由於多任務處理能力的需求增加：CPU、data data fetch，在改成 React Fiber 之前，React component 在 render 階段會產生的一個遞迴 stack 的 virtual dom tree，這個過程是不可中斷的，又 Javascript 是單執行緒的，所以當 React component 在 render 階段遇到一個很大的 component 就會佔用瀏覽器的 main thread，這樣就會造成瀏覽器的畫面卡住。\n\n在有了 React Fiber 之後，React component 在 render 階段改成使用 Linked list 代替一般的樹狀結構的儲存畫面結構，而且可以透過 scheduler 機制去調度產生畫面的流程。\n\n至於 Server Components 的部分，因為一直沒有機會實作，所以對於這個部分的內容還是有點模糊，這就留到以後有時間再來研究吧。\n\n後面談到了一些今年發表的 React 19 和 React Compiler 的部分，剛好今年 react conf 我剛好有看完，所以焦慮感沒那麼重 ＸＤ ，react conf 的內容很精彩關於新的特性講了非常多細節，這邊就不多贅述了。\n\n### 5. 《天下》如何思考數位敘事？從流程到技術大公開 - 李郁欣／楊時鈞 Steven Yeo\n\n這場主要是分享天下雜誌他們家的前端怎麼應用 blender 3d 建模將圖資結合新聞敘述打造一篇數位的專題報導，他們的專題報導是真的蠻炫砲的，完全是跟我不同的前端領域，聽完我就在想這樣的產生一篇新聞的成本好重，可是敘事的手法真的很不錯。\n\n當然除了技術上覺得佩服，還有一個是我覺得厲害的地方，就是需要跟中央的研究單位專家索取適合應用在 3D 建模的資料，那中間的溝通真的很難，通常外部的人不太懂前端技術上需要的資料結構，還必續要花時間去解釋。\n\n### 6. 從商業策略出發的產品、服務體驗設計：以 USPACE 產品為例 - 郭丞哲 Doppler kuo\n\n這家做的產品跟我現在做的很雷同，聽完覺得果然痛點都差不多，但某些想法是可以參考的。\n\n### 7. AI+商業思維：軟體工程師如何擁抱趨勢，提升職場價值 - 游舒帆\n\n[AI+商業思維：軟體工程師如何擁抱趨勢，提升職場價值](https://gipi.tw/webconf-2024-ai-and-business-thinking/?fbclid=PAZXh0bgNhZW0CMTEAAaY5PcBALpCOpZD5RzIadmhqLa7Kf_7frPdLOImYHiSh5HZhTYYRSgtnJo4_aem_Fc3cQo6Us5KC8MXHxoa5Lw)\n\n比較軟一點的職涯分享內容，講的蠻好的，讓人重新思考在自己職涯與市場的定位，雖然這些內容我好像在以前在曼陀號聽過。\n\n### 8. 擁抱漸進式體驗 — 設計驅動企業改革動能 - 郭藺瑩 Lydia Kuo\n\n很精彩的一場，無論是敘事或是簡報設計都是很舒服的一場，前面開頭分享了很多小故事很吸引人，透過這些故事讓人了解到只有實際走入使用者的生活，才能夠設計出動人人心的產品。接著是我覺得最有幫助的是改版專案，專案改版其實是實務上很常見的狀況，講者以改版 Yahoo! 股市 APP 為例，分享他們團隊進行 APP 改版的思路。\n\n![擁抱漸進式體驗 — 設計驅動企業改革動能 ](./1.png)\n\n透過前期的使用者訪談研究，先盤點出 APP 功能對使用者重要性的順序，接著從中度使用頻率的功能而且影響營收的功能進行改版，除了讓使用者可以漸漸接受改版，進而藉由改版後的營收彰顯改版的成效，讓專案可以獲得穩定的投資與支持，才有資源接著下一階段的改版，畢竟能活下去是才是最重要的。\n\n另外一個有收穫的地方是，講者提到一個可以幫助設計師與前端工程師提升開發效率的工具，就是使用 figma 的 Global token，讓設計的 UI 可以被清楚的定義好規格，再加上 [style-dictionary](https://github.com/amzn/style-dictionary?tab=readme-ov-file#installation) 可以把定義好的 JSON 規格檔案轉換成相對應的 CSS、SCSS、或者 Android 、IOS程式碼，這樣就可以讓設計師與前端工程師之間的溝通更加順暢，也可以節省掉前期定義設計規格的時間，更重要的是，當設計需要改版時只要調整前面的定義規格檔案，就可以自動更新到所有的程式碼，節省了很多時間，讓工程師與設計師可以更專注於開發與設計上。\n\n### 9. ESLint One for All Made Easy - Anthony Fu\n\n[ESLint One for All Made Easy 簡報](https://talks.antfu.me/2024/webconf-tw/1)\n他的簡報超酷，除了簡報內容本身，還有為簡報講解開發的功能。\n\nEslint Flat Config 是 eslint 9.0.0 版本重大的改版，在聽到這場之前我已經花了一些時間把目前維護的專案的 eslint 遷移到 Flat Config，所以對我來說還算是不陌生，但是在聽完這場後有發現更多可以玩的東西。\n\n![Eslint Flat Config](./2.png)\n\nFlat Config 相較傳統的設定檔好處在於扁平化的設定大大的提升靈活性與可以擴展化的彈性，讓多個專案可以共享同一份設定檔，覆蓋所有不同類型的專案。\n\n![Eslint Flat Config](./3.png)\n後面講者介紹了一些 library 、還有一些 eslint 9.0.0 的功能。\n\n![Eslint Flat Config](./4.png)\nESLint Config Inspector 這個工具超酷，可以幫你把目前專案的 eslint 設定檔轉換成可視化的開發工具，檢視目前專案哪些檔案應用了哪些規則，哪些規則已經被棄用。\n\n#### eslint 應用多樣性\n\n1. linter\n2. 遷移工具： [eslint-plugin-command](https://github.com/antfu/eslint-plugin-command)\n3. 格式化工具: [ESLint Stylistic](https://eslint.style/)\n4. 多種語言的 linter\n\n### 10. Flex out！ CSS Grid 玩起來！ - 李建杭 Amos\n\n[簡報下載](https://drive.google.com/file/d/1ZgN-oDsIazHd3kYt-bPWM1tOap7VGBLF/view)\n\nGrid 其實對我來說不陌生，有時候用 Grid 排版超好用，當然還是有一些我不知道 CSS 技巧，以下就講者的提供範例做一個回顧：\n\n[範例程式碼](https://drive.google.com/file/d/1aaH7wncnXp1ydu-C_V9_ez19oPG_j08D/view)\n\n#### 使用 details 製作純 CSS 手風琴式版面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>keywords auto height transition - by Amos</title>\n    <style>\n      :root {\n        interpolate-size: allow-keywords;\n      }\n      .accordion-item {\n        margin: 30px;\n        border: 1px solid #aaa;\n      }\n      .accordion-item .detail-title {\n        background-color: #ccc;\n        padding: 10px;\n      }\n      .accordion-item .detail-title::marker {\n        content: \"\";\n      }\n      .accordion-item .detail-content {\n        padding: 10px;\n      }\n      /* Animation */\n\n      /* 選擇所有具有 accordion-item 類別的元素內的 details-content 偽元素。 */\n      .accordion-item::details-content {\n        /* 設定 height 和 content-visibility 屬性的過渡效果，持續時間為 0.5 秒，使用 ease 過渡效果。 */\n        transition:\n          height 0.5s ease,\n          content-visibility 0.5s ease allow-discrete;\n        height: 0;\n        /* 內容超出範圍時裁剪。 */\n        overflow: clip;\n        /* 強制內容可見。 */\n        content-visibility: visible !important;\n      }\n      /* 選擇所有具有 accordion-item 類別且有 open 屬性的元素內的 details-content 偽元素。 */\n      .accordion-item[open]::details-content {\n        /* details-content 偽元素的高度設為 auto，並使用 calc-size(auto) 來計算自動高度。 */\n        height: auto;\n        height: calc-size(auto);\n      }\n      /* 這樣當 accordion-item 被打開時，details-content 的高度會從 0 過渡到自動計算的高度，實現手風琴效果的展開動畫。 */\n    </style>\n  </head>\n  <body>\n    <h1>使用 details 製作純 CSS 手風琴式版面</h1>\n\n    <div class=\"accordion\">\n      <details class=\"accordion-item\" name=\"item\">\n        <summary class=\"detail-title\">Q : 金魚都能懂什麼？</summary>\n        <div class=\"detail-content\">\n          <p>\n            「金魚都能懂」的教學系列是由 Amos\n            創立，目的是為了讓大家在學習過程可以更加輕鬆自在且愉快...\n          </p>\n        </div>\n      </details>\n      <details class=\"accordion-item\" name=\"item\">\n        <summary class=\"detail-title\">Q : 這段秀什麼？</summary>\n        <div class=\"detail-content\">\n          <p>\n            這段展現「不」使用 grid 也能夠實現不確定容器高度時的動畫轉換效果\n          </p>\n          <p>\n            使用 HTML Details 和 interpolate-size: allow-keywords; 實現 height\n            auto。\n          </p>\n        </div>\n      </details>\n      <details class=\"accordion-item\" name=\"item\">\n        <summary class=\"detail-title\">\n          Q : 實現自動高度動畫真的不難，對吧\n        </summary>\n        <div class=\"detail-content\">\n          <p>來個長假文吧</p>\n          <p>\n            我個人認為義大利麵就應該拌42號混泥土，因為這個螺絲釘\n            的長度很容易直接影響到挖掘機的扭矩。你往裡砸的時候，一瞬間它就會產生大量\n            的高能蛋白，俗稱UFO，會嚴重影響經濟的發展，以至於對整個太平洋，和充電器的核污\n            染。再或者說透過這勾股定理很容易推斷出人工飼養的東條英雞，他是可以捕獲野生\n            的三角函數，所以說不管這秦始皇的切面是否具有放射性，川普的N次方是否有沈澱物，\n            都不會影響到沃爾瑪跟維爾康在南極匯合。\n          </p>\n        </div>\n      </details>\n    </div>\n  </body>\n</html>\n```\n\n<HTMLPreview\nshowCode={false}\n\ncode={`     <h1>使用 details 製作純 CSS 手風琴式版面</h1>\n    <div class=\"accordion\">\n        <details class=\"accordion-item\" name=\"item\">\n            <summary class=\"detail-title\">Q : 金魚都能懂什麼？</summary>\n            <div class=\"detail-content\">\n                <p>「金魚都能懂」的教學系列是由 Amos 創立，目的是為了讓大家在學習過程可以更加輕鬆自在且愉快...</p>\n            </div>\n        </details>\n        <details class=\"accordion-item\" name=\"item\">\n            <summary class=\"detail-title\">Q : 這段秀什麼？</summary>\n            <div class=\"detail-content\">\n                <p>這段展現「不」使用 grid 也能夠實現不確定容器高度時的動畫轉換效果</p>\n                <p>使用 HTML Details 和 interpolate-size: allow-keywords; 實現 height auto。</p>\n            </div>\n        </details>\n        <details class=\"accordion-item\" name=\"item\">\n            <summary class=\"detail-title\">Q : 實現自動高度動畫真的不難，對吧</summary>\n            <div class=\"detail-content\">\n                <p>來個長假文吧</p>\n                <p>我個人認為義大利麵就應該拌42號混泥土，因為這個螺絲釘 的長度很容易直接影響到挖掘機的扭矩。你往裡砸的時候，一瞬間它就會產生大量 的高能蛋白，俗稱UFO，會嚴重影響經濟的發展，以至於對整個太平洋，和充電器的核污 染。再或者說透過這勾股定理很容易推斷出人工飼養的東條英雞，他是可以捕獲野生 的三角函數，所以說不管這秦始皇的切面是否具有放射性，川普的N次方是否有沈澱物， 都不會影響到沃爾瑪跟維爾康在南極匯合。</p>\n            </div>\n        </details>\n    </div>\n  `}\n\nstyle={ `\n        :root{\n            interpolate-size: allow-keywords;\n        }\n        .accordion-item {\n            margin: 30px;\n            border: 1px solid #aaa;\n        }\n        .accordion-item .detail-title {\n            background-color: #ccc;\n            padding: 10px;\n        }\n        .accordion-item .detail-title::marker {\n            content: '';\n        }\n        .accordion-item .detail-content {\n            padding: 10px;\n        }\n        /* Animation */\n        .accordion-item::details-content {\n            transition: height 0.5s ease, content-visibility 0.5s ease allow-discrete;\n            height: 0;\n            overflow: clip;\n            content-visibility: visible!important;\n        }\n        .accordion-item[open]::details-content {\n            height: auto;\n            height: calc-size(auto);\n        }` }\nheight=\"300px\"\n/>\n\n##### [interpolate-size](https://developer.mozilla.org/en-US/docs/Web/CSS/interpolate-size)\n\n```css\n:root {\n  interpolate-size: allow-keywords;\n}\n```\n\n是一個 實驗性 CSS 屬性，它允許在 length-percentage（例如具體數值如 50% 或 200px）和內在尺寸值（例如 auto、fit-content 或 max-content）之間進行動畫或過渡（interpolation）。\n\nallow-keywords：\n開啟 length-percentage 和內在尺寸值（例如 auto）之間的插值動畫。\n適用於動畫場景，例如容器在「折疊（closed）」和「展開（open）」狀態之間平滑過渡。\n\n##### [details](https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/details)\n\ndetails 元素，可以用來包裹一段內容，並且可以透過 summary 元素來控制內容的顯示與隱藏。\n\n#### 使用 ch 代替 em 讓尺寸控制更精確\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>CSS Grid table - by Amos</title>\n    <style>\n      .table {\n        display: grid;\n        /* 第一列的寬度為 calc(3em + 9ch)，即 3 個字母寬度加上 9 個字符寬度。\n接下來的兩列寬度為 1fr，即各佔剩餘空間的 1 份。*/\n        grid-template-columns: calc(3em + 9ch) repeat(2, 1fr);\n        /* grid-template-columns: 12em repeat(2, 1fr); */\n        gap: 2px;\n      }\n      .row {\n        display: grid;\n        /* 使用 subgrid 來繼承父網格容器（即 .table）的列定義。*/\n        grid-template-columns: subgrid;\n        grid-column: 1/-1;\n      }\n      .col {\n        border: 1px solid #aaa;\n        /* 設定內邊距為上下 1ex（字體高度的 x 高度），左右 1em（字母寬度）。*/\n        padding: 1ex 1em;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>使用 ch 代替 em 讓尺寸控制更精確</h1>\n    <div class=\"table\">\n      <div class=\"row\">\n        <div class=\"col\">A123456789</div>\n        <div class=\"col\">Amos</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">K123456789</div>\n        <div class=\"col\">Alvee</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">G123456789</div>\n        <div class=\"col\">Ray</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">M123456789</div>\n        <div class=\"col\">Eason</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n<HTMLPreview\nshowCode={false}\ncode={`\n\n    <h1>使用 ch 代替 em 讓尺寸控制更精確</h1>\n\n    <div class=\"table\">\n        <div class=\"row\">\n            <div class=\"col\">A123456789</div>\n            <div class=\"col\">Amos</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col\">K123456789</div>\n            <div class=\"col\">Alvee</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col\">G123456789</div>\n            <div class=\"col\">Ray</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col\">M123456789</div>\n            <div class=\"col\">Eason</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n    </div>\n\n`}\n    style={\n    ` .table {\ndisplay: grid;\ngrid-template-columns: calc(3em + 9ch) repeat(2, 1fr);\ngap: 2px;\n}\n.row {\ndisplay: grid;\ngrid-template-columns: subgrid;\ngrid-column: 1/-1;\n}\n.col {\nborder: 1px solid #aaa;\npadding: 1ex 1em;\n}` }\nheight=\"300px\"\n/>\n\n##### em\n\n是相對於父元素的字體大小，英文字母最寬的寬度。\n\n##### ex\n\n是一種相對單位，表示相對於當前元素字體中小寫字母 \"x\" 的高度（也稱為 \"x-height\"）。（字體高度的 x 高度）。\n\n##### ch\n\n是一種相對長度單位，用於表示與字體中數字 \"0\" 的寬度相關的尺寸。這個單位主要用於設計需要字寬基準的布局，例如表格、輸入框或排版。\n\n#### color-mix 函式 - by Amos\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>color-mix 函式 - by Amos</title>\n    <style>\n      :root {\n        --btn-bg: #fa0;\n        --btn-hover-bg: #fff;\n      }\n      html,\n      body {\n        height: 100%;\n        place-content: center;\n        text-align: center;\n      }\n      .btn {\n        display: inline-block;\n        padding: 1ex 3em;\n        background-color: var(--btn-bg);\n        color: #fff;\n        font-size: 22px;\n        margin: 6px;\n        border: none;\n      }\n      .btn:nth-child(1):hover {\n        background-color: color-mix(\n          in srgb,\n          var(--btn-bg),\n          var(--btn-hover-bg) 20%\n        );\n      }\n      .btn:nth-child(2):hover {\n        background-color: color-mix(\n          in srgb,\n          var(--btn-bg),\n          var(--btn-hover-bg) 50%\n        );\n      }\n      .btn:nth-child(3):hover {\n        background-color: color-mix(\n          in srgb,\n          var(--btn-bg),\n          var(--btn-hover-bg) 80%\n        );\n      }\n    </style>\n  </head>\n  <body>\n    <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n  </body>\n</html>\n```\n\n<HTMLPreview\nshowCode={false}\n\ncode={`     <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n  `}\n\nstyle={ `:root {\n            --btn-bg: #fa0;\n            --btn-hover-bg: #fff;\n        }\n        html,body{\n            height: 100%;\n            place-content: center;\n            text-align: center;\n        }\n        .btn {\n            display: inline-block;\n            padding: 1ex 3em;\n            background-color: var(--btn-bg);\n            color: #fff;\n            font-size: 22px;\n            margin: 6px;\n            border: none;\n        }\n        .btn:nth-child(1):hover {\n            background-color: color-mix(in srgb, var(--btn-bg), var(--btn-hover-bg) 20%);\n        }\n        .btn:nth-child(2):hover {\n            background-color: color-mix(in srgb, var(--btn-bg), var(--btn-hover-bg) 50%);\n        }\n        .btn:nth-child(3):hover {\n            background-color: color-mix(in srgb, var(--btn-bg), var(--btn-hover-bg) 80%);\n        }` }\nheight=\"300px\"\n/>\n\n##### [color-mix](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix)\n\n用於混合兩種顏色，根據指定的比例生成一種新的顏色。這個函式對於設計需要漸變、對比或平滑過渡效果的場景非常有用。\n\n### 11. 當 Vue 與 View 分手之後⋯ - Kuro Hsu\n\n講者在這場介紹了 Vue 的一個實驗性的功能: **Vue Vapor Mode**\n\n現行的 Vue 更新渲染策略是生成 Virtual Dom ，可以避免開發者直接去修改 DOM element，但是這樣同時也產生一些缺點，產生 Virtual Dom 會影響記憶體與執行的效率，也會增加了打包後的大小，在大型的專案特別明顯。\n\n![Vue Vapor Mode](./6.png)\n\nVue Vapor Mode 是可以讓 Vue 不用生成 Virtual Dom，而是直接使用 DOM API 去更新畫面，如此一來可以讓 Vue 更快更輕量。\n\n- Vue Vapor Mode 實作 template 模板\n\n[vuejs/vue-vapor 原始碼](https://github.com/vuejs/vue-vapor/blob/db140a1e37f89590e52d788a8d12308f53c7f3f1/packages/runtime-vapor/src/dom/template.ts)\n\n```js\n/*! #__NO_SIDE_EFFECTS__ */\nexport function template(html: string) {\n  let node: ChildNode\n  const create = () => {\n    // eslint-disable-next-line no-restricted-globals\n    //highlight-next-line\n    const t = document.createElement('template')\n    //這裡可以看到 Template 是一個使用 DOM API document.createElement('template') 的實例\n    t.innerHTML = html\n    return t.content.firstChild!\n  }\n  return () => (node || (node = create())).cloneNode(true)\n}\n```\n\n- Vue Vapor Mode 實作 \\_setText 和 \\_setHtml\n\n[vuejs/vue-vapor 原始碼](https://github.com/vuejs/vue-vapor/blob/db140a1e37f89590e52d788a8d12308f53c7f3f1/packages/runtime-vapor/src/dom/prop.ts#L188)\n\n簡單來說就是透過檢查舊的 DOM 節點的值，如果新的值和舊的值不同，就更新 DOM 節點的值。\n\n```js\nexport function setText(el: Node, ...values: any[]) {\n  const text = values.map(v => toDisplayString(v)).join('')\n  //舊的 textContent 值 oldVal\n  const oldVal = recordPropMetadata(el, 'textContent', text)\n  if (text !== oldVal) {\n    //更新 el.textContent 為新的 text 值\n    el.textContent = text\n  }\n}\n\nexport function setHtml(el: Element, value: any) {\n  //舊的 innerHTML 值 oldVal\n  const oldVal = recordPropMetadata(el, 'innerHTML', value)\n  if (value !== oldVal) {\n    el.innerHTML = value\n  }\n}\n```\n\n![Vue Vapor Mode](./5.png)\n\nVue Vapor Mode 的實作是基於 @vue/reactivity ，@vue/reactivity 則是由 vue 將其響應式系統抽出來變成獨立套件，即使沒有安裝 Vue 也可以使用響應式的api，甚至可以在後端處理 websocket 事件的狀態管理，更支援深層物件結構。\n\n響應式系統核心在於首次使用 effect 函式時會去自動追蹤內部所有響應式狀態，狀態被修改時，更新並且執行 side effect 並且移除 render()。\n\n至於無 virtual dom 的會不會是前端的趨勢?我個人覺得除非 React 使用量被 Vue 超越很多或哪天 react 放棄了 react native，不然 virtual dom 對於 react 來說是很重要的，畢竟 react 同時要支援多個跨平台 ex: android、ios、web，而 virtual dom 連接跨平台原生元件的重要橋樑。\n\n不過說真的如果 Vue 的 Vapor Mode 真的上線之後，看起來效能會比 React 好很多。\n","createdAt":"2025-08-16T08:43:45.669Z","updatedAt":"2025-08-16T10:26:08.868Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":26,"data":{"documentId":"chbr8aan2a16owyena95y8el","slug":"translate","title":"為什麼實作 CSS 動畫位移效果使用 translate() 比 absolute 絕對定位更好？","date":"2025-08-16T08:43:54.116Z","description":"為什麼實作 CSS 動畫位移效果使用 translate() 比 absolute 絕對定位更好？ 剛好在最近工作上有遇到這個問題，在這裡我們會討論到 translate() 和 absolute 的差異，以及為什麼我們應該使用 translate() 來移動元素。 translate()的優勢 translate() 是 CSS transform 的一個屬性，用來移動元素的位置。它是一個 2D 或 3D 的函數，可以在 x, y, z 軸上移動元素。","content":"\n# 為什麼實作 CSS 動畫位移效果使用 `translate()` 比 `absolute` 絕對定位更好？\n\n剛好在最近工作上有遇到這個問題，在這裡我們會討論到 `translate()` 和 `absolute` 的差異，以及為什麼我們應該使用 `translate()` 來移動元素。\n\n## `translate()`的優勢\n\n`translate()` 是 CSS `transform` 的一個屬性，用來移動元素的位置。它是一個 2D 或 3D 的函數，可以在 x, y, z 軸上移動元素。\n\n```css\n.element {\n  position: relative;\n  transform: translate(100px, 100px);\n}\n```\n\n當使用 `translate()` 移動元素的時候，元素仍然保持在原本的位置，只是視覺上移動了，瀏覽器不會重新計算元素的佈局，也就是說，不會觸發 `reflow`。取而代之的是，`translate()` 只會觸發瀏覽器的 合成階段（compositing），這是在 GPU 而非主執行緒中執行的操作，因此效能更佳，並能產生流暢的動畫效果。\n\n## `absolute` 絕對定位的問題\n\n絕對定位會將元素超脫原來的頁面流，並且會根據最近的父元素或是 `body` 來定位。\n\n```css\n.element {\n  position: absolute;\n  top: 100px;\n  left: 100px;\n}\n```\n\n使用 `absolute` 絕對定位該元素然後透過 `top` 、 `left`、 `bottom`、`right` 來移動元素，但是當元素被移動後會觸發 **reflow**，這樣會造成效能問題，這個過程會導致瀏覽器重新繪製 (repaint) 整個畫面或部分畫面，從而增加效能負擔，尤其在複雜的網頁中，這可能會導致畫面卡頓或掉幀。\n\n## 瀏覽器的渲染過程\n\n這要從瀏覽器如渲染出一個網頁開始：\n\n### (一)、解析階段\n\n1. 瀏覽器會解析 HTML 並建立 DOM Tree\n2. 瀏覽器會解析 CSS Link tag 並建立 CSSOM Tree\n\n### (二)、Render 階段\n\n1. 在主執行緒中，DOM Tree 和 CSSOM Tree 會合併成 Render Tree。\n2. **Layout**: 在主執行緒中，瀏覽器根據 **Render Tree** 生成 **Layout Tree**，計算每個元素的位置和大小。\n\n   - 這個過程瀏覽器會將頁面進行分層產生 **Layer tree**，每一層都是一個獨立的圖層。\n   - 在這個階段瀏覽器會計算每個圖層的位置和大小，產生一個繪製的指令與塗層疊加的順序。\n   - 最終這些圖層疊加在一起會形成頁面。\n   - **Reflow 回流**：當元素的幾何位置和大小發生變化時，瀏覽器會重新計算 Layout Tree中的元素物理屬性，這個過程稱為 Reflow，例如：\n     height、padding、position...等。\n\n3. **Paint**: 在主執行緒中，瀏覽器根據 Layout Tree 進行繪製。\n   - **Repaint 重繪**：當元素的外觀發生變化時，瀏覽器會重新繪製元素，這個過程稱為 Repaint，例如：\n     color、background-color...等。\n4. **合成 Compositing**：在 Compositor thread 和 Raster thread 中，瀏覽器將繪製好的圖層進行合成。\n   - 各個 Layer 圖層會進行柵格化 rasterize，將圖層轉換成 Pixel 顯示在螢幕上。\n   - 在 Compositor thread 將這些經過柵格化的圖層進行合成，將這些圖層合成一個整體的畫面。\n   - Compositor thread 會將 layer 切成一個個的 tile，然後將這些 tile 送到 Raster thread，將tile 進行柵格化後存到瀏覽器的 GPU 。\n   - Compositor thread 根據 draw quads 資訊產生 Compositor frame，然後將這些 Compositor frame 送到 browser 階段 。\n\n### (三) Browser 階段\n\n1. 瀏覽器將 Compositor frame 送到 GPU 。\n2. 瀏覽器將渲染好的畫面顯示在螢幕上。\n\n無論是 Reflow 或 Repaint ，當觸發了上方渲染的某一個階段後，後續的階段也都會跟著被觸發。\n\n## 總結\n\n所以回到這個問題的本質，當使用 `absolute` 絕對定位移動元素時，會觸發 **reflow**，這時候瀏覽器會重新計算元素的位置然後產生新的 Layout Tree，接著進行 Repaint 和 Compositing。\n但是使用 `translate()` 移動元素時，不會觸發 **reflow** 和 **repaint**，只會觸發合成階段。此外還有另外一個好處是合成階段不是在主執行緒中進行的，這樣就不會影響到主執行緒的效能，因此使用 `translate()` 移動元素的效果比 `absolute` 絕對定位更可以縮短瀏覽器繪製的時間，還能讓動畫在 GPU 上進行處理讓動畫更加流暢。\n","createdAt":"2025-08-16T08:43:45.743Z","updatedAt":"2025-08-16T10:25:15.136Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":28,"data":{"documentId":"lsmz17dpsvvar7hbz1lve7pt","slug":"getelementsbyclassname","title":"getElementsByClassName() 手寫實作","date":"2025-08-16T08:43:54.154Z","description":"","content":"\n# getElementsByClassName() 手寫實作\n\n`getElementsByClassName()` 是一個 DOM API，可以用來取得指定 class 名稱的 DOM 元素，並且會回傳一個 HTMLCollection 物件。\n\n## 輸入參數\n\n- 一個 element 作為起始搜尋的根節點。\n- 一個 classNames 字串，包含要搜尋的 class 名稱，可以是單個或多個，用空白分隔。\n\n## 功能需求\n\n- 搜尋 element 的所有後代（不包含自身）是否包含指定的 class 名稱。\n- 如果節點的 classList 包含了所有指定的 class 名稱，就將其加入結果陣列中。\n- 最終返回一個陣列（`Array<Element>`），而非類陣列（`HTMLCollection`）。\n- 不使用 `document.querySelectorAll()`\n\n## 範例\n\n```js\nconst doc = new DOMParser().parseFromString(\n  `<div class=\"foo bar baz\">\n    <span class=\"bar baz\">Span</span>\n    <p class=\"foo baz\">Paragraph</p>\n    <div class=\"foo bar\"></div>\n  </div>`,\n  \"text/html\",\n);\n\ngetElementsByClassName(doc.body, \"foo bar\");\n// [div.foo.bar.baz, div.foo.bar]\n```\n\n## 實作思路\n\n由於 DOM 是樹狀結構，透過 **遞迴** 進行可以方便地遍歷所有的子節點及其後代，並將符合條件的節點加入陣列中。\n\n搜尋的 className 字串可能包含多個 class 名稱，因此需要將其拆分為多個 class 名稱，並逐一檢查是否為目標節點的子集合。\n\n```ts\n//透過 Array.from(a) 將 Set 轉為陣列，並用 every 方法逐一檢查 classList.contains(value) 是否為 true ，就可以確認是否為要找尋的目標 class name。\nfunction isSubset(a: Set<string>, b: DOMTokenList) {\n  return Array.from(a).every((value) => b.contains(value));\n}\n\nexport default function getElementsByClassName(\n  element: Element,\n  //一個 classNames 字串，包含要搜尋的 class 名稱，可以是單個或多個，用空白分隔。\n  classNames: string,\n): Array<Element> {\n  const elements: Array<Element> = [];\n  //首先將輸入的 classNames 字串轉換為一個 Set，便於進行比對。\n  //使用 trim() 移除多餘的空白，並用正規表達式 /\\s+/ 拆分字串為多個 class 名稱。\n  const classNamesSet = new Set(classNames.trim().split(/\\s+/));\n\n  function traverse(el: Element) {\n    if (el == null) {\n      return;\n    }\n    //此函式檢查 classNamesSet 是否為目標節點 classList 的子集合。\n    if (isSubset(classNamesSet, el.classList)) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n```\n","createdAt":"2025-08-16T08:43:45.830Z","updatedAt":"2025-08-16T09:05:28.197Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":30,"data":{"documentId":"cxps4ltexz9fwom3nucu9tm5","slug":"getelementsbytagname","title":"getElementsByTagName() 手寫實作","date":"2025-08-16T08:43:54.191Z","description":"","content":"\n# getElementsByTagName() 手寫實作\n\n`getElementsByTagName()` 是一個 DOM API，可以用來取得指定標籤名稱的 DOM 元素，並且會回傳一個 HTMLCollection 物件。\n\n這裡會在不使用 `document.querySelectorAll()`的情況下 手寫 `Element.getElementsByTagName()` 方法\n\n## 輸入參數\n\n- 一個 element 作為起始搜尋的根節點。\n- 一個 tag 字串。\n\n## 功能需求\n\n- 搜尋 element 的所有後代（不包含自身）是否包含指定的 tag 名稱。\n- 如果節點的 tag 包含了所有指定的 tag 名稱，就將其加入結果陣列中。\n- 最終返回一個陣列（`Array<Element>`），而非類陣列（`HTMLCollection`）。\n\n## 範例\n\n```js\nconst doc = new DOMParser().parseFromString(\n  `<div id=\"foo\">\n    <span>Span</span>\n    <p>Paragraph</p>\n    <div id=\"bar\">Div</div>\n  </div>`,\n  \"text/html\",\n);\n\ngetElementsByTagName(doc.body, \"div\");\n// [div#foo, div#bar]\n```\n\n## 實作思路：\n\n由於 DOM 是樹狀結構，透過 **遞迴** 進行可以方便地遍歷所有的子節點及其後代，並將符合條件的節點加入陣列中。\n\n```ts\nexport default function getElementsByTagName(\n  element: Element,\n  tagNameParam: string,\n): Array<Element> {\n  //用於存放符合條件的後代元素\n  const elements: Array<Element> = [];\n\n  //將輸入的 tagNameParam 轉為大寫，因為 Element.tagName 返回的值是大寫（如 DIV）。\n  const tagName = tagNameParam.toUpperCase();\n\n  //使用遞迴的方式，逐一檢查 element 的所有後代節點。\n  function traverse(el: Element) {\n    if (el == null) {\n      return;\n    }\n    //如果目前的節點標籤名稱符合目標，加入陣列\n    if (el.tagName === tagName) {\n      elements.push(el);\n    }\n\n    // 遍歷目前節點的所有子節點\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  //搜尋後代節點（不包括起始節點），必須從 element.children 開始遍歷。\n  //Element.children 會回傳即時子元素的 HTMLCollection\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n```\n\n## HTMLCollection\n\n`HTMLCollection` 是一種 **動態更新** 的類陣列，當 DOM 結構發生變化時，`HTMLCollection` 的內容會即時反映這些變化。\n\n為什麼不能用`.forEach()`遍歷? 因為 `HTMLCollection` 是一個類陣列，不是真正的陣列，因此不繼承 `Array.prototype` 上的方法（例如 `.forEach`, .`map`, .`filter` 等）。\n","createdAt":"2025-08-16T08:43:45.920Z","updatedAt":"2025-08-16T08:43:54.212Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":32,"data":{"documentId":"cpukq887lkekoejmqopmat4u","slug":"hosting","title":"Hosting 提升","date":"2025-08-16T08:43:54.231Z","description":"Hosting 提升 Hosting 提升指的是在執行 JavaScript 程式碼之前， JavaScript 引擎會將變數和函式的宣告提升到作用域的頂端。 當瀏覽器運行 Javascript 引擎的時候也就是 runtime 時，會進入創造階段： 創造階段 首先進入創造階段，JavaScript 引擎會會將幫所有的變數和函式準備記憶體的空間，此時的變數與函式會提升。 var 變數的提升 var 變數的宣告會被提升到作用域的的頂端，但賦值（值的初始化）不會被提升。因此，在提升後變數會被初始化為 undefined。","content":"\n# Hosting 提升\n\nHosting 提升指的是在執行 JavaScript 程式碼之前， JavaScript 引擎會將變數和函式的宣告提升到作用域的頂端。\n\n當瀏覽器運行 Javascript 引擎的時候也就是 runtime 時，會進入創造階段：\n\n## 創造階段\n\n首先進入創造階段，JavaScript 引擎會會將幫所有的變數和函式準備記憶體的空間，此時的變數與函式會提升。\n\n### var 變數的提升\n\nvar 變數的宣告會被提升到作用域的的頂端，但賦值（值的初始化）不會被提升。因此，在提升後變數會被初始化為 undefined。\n\n```js\nvar counts = 2;\n```\n\n當提升時可以理解成以下：\n\n```js\nvar counts; //提升到函式作用域的的頂端，這時候的 counts 值是 undefined\ncounts = 2; //此時賦值 2\n```\n\n### const 變數和 let 變數的提升\n\nlet 和 const 宣告也會被提升，但與 var 不同的是，它們不會被初始化為 undefined，而是會進入「暫時死區」（TDZ, Temporal Dead Zone），直到程式執行到宣告它們的那一行為止。如果在此之前訪問它們，會拋出 ReferenceError。\n\n```js\nlet counts = 3;\nconst times = 5;\n```\n\n當提升時可以理解成以下：\n\n```js\ncounts; // ReferenceError 因為尚未被宣告\ntimes; // ReferenceError 因為尚未被宣告\nlet counts = 3; //宣告並且賦值\nconst times = 5; //宣告並且賦值\n```\n\n### 函式陳述式提升\n\n函式陳述式會包完整的函式被提升到作用域頂部，此時的函式是可以在宣告前被呼叫的。\n\n```js\nsayHi();\n\nfunction sayHi() {\n  console.log(\"Hi!\");\n}\n```\n\n當提升時可以理解成以下：\n\n```js\nfunction sayHi() {\n  console.log(\"Hi!\");\n}\n\nsayHi(); //此時呼叫會印出 \"Hi!\"\n```\n\n### 函式表達式提升\n\n視同變數的提升，一樣會被提升到函式作用域的頂部。\n函式表達式的變數宣告部分會被提升，但賦值為函式的部分不會。因此，提升後變數是 undefined，試圖呼叫它會導致錯誤。\n\n```js\nsayHi();\n\nvar sayHi = function () {\n  console.log(\"Hi!\");\n};\n```\n\n當提升時可以理解成以下：\n\n```js\nvar sayHi; //此時的值會是 undefined\nsayHi(); //Uncaught TypeError: sayHi is not a function\nsayHi = function () {\n  console.log(\"Hi!\");\n};\n```\n\n## 執行階段\n\n這時候會實際執行程式碼，並且將值賦予給變數。\n\n---\n\n## 實例練習\n\n[45. Hoisting VI](https://bigfrontend.dev/quiz/Hoisting-VI)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nvar foo = 1;\n(function () {\n  console.log(foo);\n  foo = 2;\n  console.log(window.foo);\n  console.log(foo);\n  var foo = 3;\n  console.log(foo);\n  console.log(window.foo);\n})();\n```\n\n## 解題\n\n```js\n// 創造階段： var foo 會被提升到作用域頂部，但尚未賦值\nvar foo;\nfoo = 1;\n//\n(function () {\n  var foo; // 創造階段：在 IIFE（立即執行函數）內的 var foo 被提升到最頂端，但尚未賦值\n  console.log(foo); //undefined\n  foo = 2;\n  console.log(window.foo); // window.foo 指的是全局變數 foo，它的值在最開始被賦值為 1，所以這裡會輸出 1\n  console.log(foo); // 這裡的 foo 指的是函式內的變數，已經被賦值為 2，所以輸出 2\n  foo = 3;\n  console.log(foo); //3 // 這裡的 foo 指的是函式內的變數，已經被賦值為 3，所以輸出 3\n  console.log(window.foo); //1 // window.foo 指的是全局變數 foo，它的值在最開始被賦值為 1，所以這裡會輸出 1\n})();\n```\n","createdAt":"2025-08-16T08:43:45.971Z","updatedAt":"2025-08-16T10:25:14.826Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":34,"data":{"documentId":"ti8gt789nbnwnp903s2b9ts1","slug":"variables","title":"let, var ,const 的差異","date":"2025-08-16T08:43:54.276Z","description":"JavaScript 中 let, var , const 的差異 使用 let、var 和 const 宣告變數時分別在：作用域、初始化、重複宣告、重新賦值、提升時有不同的行為。 作用域 scope var 的作用域是全域或是在 function 中，var 宣告的變數會被提升到整個函式的頂端; let 跟 const 則是區塊(block)作用域，這裡的 block 指的是 function 中或 if-else block 或 for-loop block，let 跟 const 只在它們所在的區塊內有效，使它們更具預測性，減少變數意外被覆蓋的可能性。","content":"\n# JavaScript 中 `let`, `var` , `const` 的差異\n\n使用 `let`、`var` 和 `const` 宣告變數時分別在：作用域、初始化、重複宣告、重新賦值、提升時有不同的行為。\n\n## 作用域 scope\n\n`var` 的作用域是全域或是在 function 中，`var` 宣告的變數會被提升到整個函式的頂端;\n\n`let` 跟 `const` 則是區塊(block)作用域，這裡的 block 指的是 function 中或 if-else block 或 for-loop block，`let` 跟 `const` 只在它們所在的區塊內有效，使它們更具預測性，減少變數意外被覆蓋的可能性。\n\n## 初始化 Initialization\n\n初始化就是指變數第一次的賦值。使用 `var` 跟 `let` 宣告的變數初始化可以不需要賦值;\n\n使用 `const` 初始化則需要必須賦值，否則會拋出: SyntaxError: Missing initializer in const declaration 的錯誤。\n\n```js\nvar a;\nlet b;\nconst c; // SyntaxError: Missing initializer in const declaration\n```\n\n## 重複宣告\n\n`var` 可以重複宣告，`var` 重複宣告時會覆蓋前面的變數; `let` 跟 `const` 則不可以。\n\n## 重新賦值\n\n`var` 跟 `let` 可以重新賦值; `const` 則不行，`const` 代表的是參考 (reference) 的不可變性 (immutable)，當物件和陣列被指派給 `const` 時，參考的是其記憶體的位置，物件和陣列的內容屬性是可以修改的，但不能重新指派為新的物件或陣列。\n\n```js\nvar a = 1;\na = 2;\n\nlet b = 3;\nb = 4;\n\nconst c = 5;\nc = 6; //error 因為 'c' 為常數，所以無法指派至 'c'。\n\nconst person = {\n    id:1 ;\n    name:'Ashley';\n}\nperson.id = 2; //可以修改 person 的 id ，因為仍是參考同一個記憶體位置。\nconsole.log(person.id); // 2\n\nperson  = {\n    id:5 ;\n    name:'Andy';\n}; // TypeError: Assignment to constant variable. 這時試圖指派一個全新的物件給 person（也就代表參考的記憶位置改變了），因參考不可變性所以報錯。\n```\n\n## 提升\n\n`var` 宣告的變數會自動初始化，初始值為 `undefined`;\n`let` 跟 `const` 宣告的變數會進到暫時死區 （TDZ, Temporal Dead Zone），直到執行到宣告的那一行。\n\n---\n\n## 實例練習\n\n[100. `var` vs `let`](https://bigfrontend.dev/quiz/var-vs-let)\n\n```js\nvar a = \"BFE\";\nlet b = \"bigfrontend\";\nconsole.log(this.a);\nconsole.log(this.b);\n```\n\n## 解題\n\n```js\nvar a = \"BFE\";\nlet b = \"bigfrontend\";\nconsole.log(this.a); //\"BFE\"\nconsole.log(this.b); //undefined\n```\n\n因為 `var` 的作用域是全域，`var` 的變數會被加到全域物件，在瀏覽器中是 `window` 物件，`this` 通常指向全域物件，因此 `this.a` 等同於 `window.a` 也就是\"BFE\"。\n\n`let` 則是區塊的作用域，`let` 的變數無法被加到全域物件，因此 `this.b` 是 `undefined`。\n","createdAt":"2025-08-16T08:43:46.081Z","updatedAt":"2025-08-16T10:25:15.190Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":36,"data":{"documentId":"n68qoyu17sint8l6xv6j3caa","slug":"equality-operator","title":"== 和 === 的差異","date":"2025-08-16T08:43:54.324Z","description":"JavaScript 中 == 和 === 的差異 == 是鬆散比較運算子、===是嚴格比較運算子，兩者最大的不同：==是當等號兩邊 values 的型別不同時，會強制轉換資料型別與值，而 === 不會。 === 嚴格比較 必須等號雙邊的值與型別一致，才會回傳 true，如果型別不同，即使值相同，也會回傳 false。 == 鬆散比較 == 會當等號運算子兩邊值的型別不同時，會在將兩邊的值進行比較之前，強制轉換型別和值，再進行比較。 常見的強制轉換規則 - Boolean,String,Number型別比較時會轉換為數字。 - true 會轉換為 1 ， false 會轉換為 0。","content":"\n# JavaScript 中 == 和 === 的差異\n\n`==` 是鬆散比較運算子、`===`是嚴格比較運算子，兩者最大的不同：`==`是當等號兩邊 values 的型別不同時，會強制轉換資料型別與值，而 `===` 不會。\n\n## `===` 嚴格比較\n\n必須等號雙邊的值與型別一致，才會回傳 `true`，如果型別不同，即使值相同，也會回傳 `false`。\n\n## `==` 鬆散比較\n\n`==` 會當等號運算子兩邊值的型別不同時，會在將兩邊的值進行比較之前，強制轉換型別和值，再進行比較。\n\n### 常見的強制轉換規則\n\n- `Boolean`,`String`,`Number`型別比較時會轉換為數字。\n- `true` 會轉換為 `1` ， `false` 會轉換為 `0`。\n- `null == undefined` 回傳 `true`，因為它們被認為是\"相等的\"，即使型別不同。\n- `null` 和 `undefined` 與其他任何值比較（如數字、布林值、字串等）時，會回傳 `false`。\n- 當一個物件與一個原始值進行比較時，會嘗試使用 `valueOf` 方法將物件轉換為一個原始值。\n- 當一個陣列與一個非陣列值進行比較時，會使用陣列的 `toString` 方法轉換成字串。\n\n## Object.is()\n\n比 `===` 更嚴格的比較，會檢查傳入兩個的值是否為相同值，然後會回傳 Boolean 。\n與 `===` 不同的是：\n\n- `===`會將`-0` 和 `+0` 視為相等，但`Object.is()`視為不同值。\n- `===`會將`NaN`和`NaN`視為不同相等，但`Object.is()`視為相等。\n\n---\n\n## 實例練習1\n\n[10. Equal](https://bigfrontend.dev/quiz/Equal-1)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(0 == false);\nconsole.log(\"\" == false);\nconsole.log([] == false);\nconsole.log(undefined == false);\nconsole.log(null == false);\nconsole.log(\"1\" == true);\nconsole.log(1n == true);\nconsole.log(\" 1     \" == true);\n```\n\n## 解題1\n\n```js\nconsole.log(0 == false);\n```\n\n`true`，因為 `false` 會被強制型別轉換成 `0`，`0 == 0` 值相等。\n\n```js\nconsole.log(\"\" == false);\n```\n\n`true`，因為空字串跟 `false` 會被強制型別轉換成 `0`。\n\n```js\nconsole.log([] == false);\n```\n\n`true`，因為空陣列會先被轉成空字串，空字串會再轉成 `0`，`false` 會被轉成 `0`，`0 == 0` 值相等。\n\n```js\nconsole.log(undefined == false);\n```\n\n`false`，因為 `undefined` 只會與 `null` 寬鬆相等。\n\n```js\nconsole.log(null == false);\n```\n\n`false`，因為 `null` 只會與 `undefined` 寬鬆相等。\n\n```js\nconsole.log(\"1\" == true);\n```\n\n`true`，因為 `\"1\"` 會被轉成 `1` ，`true` 會被轉成 `1` ，`1 == 1` 值相等。\n\n```js\nconsole.log(1n == true);\n```\n\n`true`，因為 `1n` 會從 BigInt 轉成 `1`，`true` 會被轉成 `1` ，`1 == 1` 值相等。\n\n```js\nconsole.log(\" 1     \" == true);\n```\n\n`true`，因為 `\" 1 \"` 會轉成 `1`，true 會被轉成 `1` ，`1 == 1` 值相等。\n\n## 實例練習2\n\n[24. Equality & Sameness](https://bigfrontend.dev/quiz/Equality-Sameness)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(0 == \"0\");\nconsole.log(0 === \"0\");\nconsole.log(Object.is(0, \"0\"));\n\nconsole.log(0 == 0);\nconsole.log(0 === 0);\nconsole.log(Object.is(0, 0));\n\nconsole.log(0 == -0);\nconsole.log(0 === -0);\nconsole.log(Object.is(0, -0));\n\nconsole.log(NaN == NaN);\nconsole.log(NaN === NaN);\nconsole.log(Object.is(NaN, NaN));\n\nconsole.log(0 == false);\nconsole.log(0 === false);\nconsole.log(Object.is(0, false));\n```\n\n## 解題2\n\n```js\nconsole.log(0 == \"0\");\n```\n\n`true`，鬆散比較會強制轉換 `\"0\"` 的型別為 `0` ， `0 == 0` 值相等。\n\n```js\nconsole.log(0 === \"0\");\n```\n\n`false`，因嚴格比較兩邊的型別需相同。\n\n```js\nconsole.log(Object.is(0, \"0\"));\n```\n\n`false`，因 `Object.is` 進行同值嚴格比較，兩個型別不同。\n\n```js\nconsole.log(0 == 0);\n```\n\n`true`，兩邊值相同。\n\n```js\nconsole.log(0 === 0);\n```\n\n`true`，兩邊值相同。\n\n```js\nconsole.log(Object.is(0, 0));\n```\n\n`true`，兩邊值相同。\n\n```js\nconsole.log(0 == -0);\n```\n\n`true`，`0`跟 `-0`在 JavaScript 中鬆散比較被認為是相等的。\n\n```js\nconsole.log(0 === -0);\n```\n\n`true`，`0`跟 `-0`在 JavaScript 中嚴格比較被認為是相等的。\n\n```js\nconsole.log(Object.is(0, -0));\n```\n\n`false`，因 `Object.is` 進行同值嚴格比較認為 `0` 和 `-0` 是不相等的。\n\n```js\nconsole.log(NaN == NaN);\n```\n\n`false`，在 JavaScript 中，`NaN（Not-a-Number)` 與任何值都不相等，包括它自己。\n\n```js\nconsole.log(NaN === NaN);\n```\n\n`false`，在 JavaScript 中，`NaN（Not-a-Number)` 與任何值都不相等，包括它自己。\n\n```js\nconsole.log(Object.is(NaN, NaN));\n```\n\n`true`，因 `Object.is`認為 `NaN` 與 `NaN` 是相等的。\n\n```js\nconsole.log(0 == false);\n```\n\n`true`，因為鬆散比較 `false` 會轉型為 `0` ， `0 == 0` 值相等。\n\n```js\nconsole.log(0 === false);\n```\n\n`false`，因嚴格比較兩邊的型別需相同。\n\n```js\nconsole.log(Object.is(0, false));\n```\n\n`false`，因兩個值的類型不同。\n\n## 實例練習3\n\n[30. Equal II](https://bigfrontend.dev/quiz/Equal-II)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log([1] == 1);\nconsole.log([1] == \"1\");\nconsole.log([\"1\"] == \"1\");\nconsole.log([\"1\"] == 1);\nconsole.log([1] == [\"1\"]);\nconsole.log(new Boolean(true) == 1);\nconsole.log(new Boolean(true) == new Boolean(true));\nconsole.log(Boolean(true) == \"1\");\nconsole.log(Boolean(false) == [0]);\nconsole.log(new Boolean(true) == \"1\");\nconsole.log(new Boolean(false) == [0]);\nconsole.log(null == undefined);\n```\n\n## 解題3\n\n```js\nconsole.log([1] == 1);\n```\n\n`true`，在鬆散比較下，當一個陣列與一個非陣列值進行比較時，會使用陣列的 `toString` 方法轉換成字串，`[1]` 會被轉換為 `\"1\"`，`\"1\"`再轉成 `1`，`1 == 1` 值相等。\n\n```js\nconsole.log([1] == \"1\");\n```\n\n`true`，在鬆散比較下 `[1]` 會轉成`\"1\"`，`\"1\"== \"1\"`值相等。\n\n```js\nconsole.log([\"1\"] == \"1\");\n```\n\n`true`，在鬆散比較下 `[\"1\"]` 會轉成`\"1\"`，`\"1\"== \"1\"`值相等。\n\n```js\nconsole.log([\"1\"] == 1);\n```\n\n`true`，在鬆散比較下 `[\"1\"]` 會轉成`\"1\"`，，`\"1\"`再轉成 `1`，`1 == 1` 值相等。\n\n```js\nconsole.log([1] == [\"1\"]);\n```\n\n`false`，因為 `[\"1\"]`、`[1]` 都是陣列，兩個物件的參考的記憶體位置不相同。\n\n```js\nconsole.log(new Boolean(true) == 1);\n```\n\n`true`，在鬆散比較下，當一個物件與一個原始值進行比較時，JavaScript 會嘗試使用 `valueOf` 方法將物件轉換為一個原始值，`new Boolean(true)`轉成`true`，`true`再轉換成`1`，`1 == 1` 值相等。\n\n```js\nconsole.log(new Boolean(true) == new Boolean(true));\n```\n\n`false`，因為兩個物件相比較時，會檢查兩個物件的參考的記憶體位置是否相同。\n\n```js\nconsole.log(Boolean(true) == \"1\");\n```\n\n`true`，`Boolean(true)` 會返回 `true` ，`true` 轉為 `1` ，\"1\" 轉為 1，`1 == 1` 值相等。\n\n```js\nconsole.log(Boolean(false) == [0]);\n```\n\n`true`，`Boolean(false)` 會返回 `false`，`[0]` 會轉成 `\"0\"`， `false`再轉成 `0`， `\"0\"`再轉成 `0`，`0 == 0`值相等。\n\n```js\nconsole.log(new Boolean(true) == \"1\");\n```\n\n`true`，`new Boolean(true)` 轉成 `true` ， `\"1\"` 轉成 `1`， `true` 再轉成 `1`， `1 == 1`值相等。\n\n```js\nconsole.log(new Boolean(false) == [0]);\n```\n\n`false`，因為 `new Boolean(false)`、`[0]` 分別是陣列跟物件，兩個參考的記憶體位置不相同。\n\n```js\nconsole.log(null == undefined);\n```\n\n`true`，在鬆散比較中 `null` 跟 `undefined` 是相等的。\n","createdAt":"2025-08-16T08:43:46.184Z","updatedAt":"2025-08-16T10:25:14.838Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":38,"data":{"documentId":"s5a29ap1ucg4uque9k1o3pmw","slug":"event-loop","title":"Event loop 事件循環","date":"2025-08-16T08:43:54.366Z","description":"JavaScript 中的事件循環 event loop 是什麼? JavaScript 是單執行緒的語言，所以一次只能執行一件事。事件循環 Event loop 是可以確保作為單行緒語言的 Javascript 可以在執行環境(瀏覽器或Node.js)中執行非同步 (asynchronous)程式碼而不會阻塞主執行緒的機制。 事件循環 event loop 進行的流程 1. Javascript 的主執行緒開始執行 scripts，並且將同步任務放入執行棧 （call stack），直到該任務完成後才會被移除。","content":"\n# JavaScript 中的事件循環 event loop 是什麼?\n\nJavaScript 是單執行緒的語言，所以一次只能執行一件事。事件循環 Event loop 是可以確保作為單行緒語言的 Javascript 可以在執行環境(瀏覽器或Node.js)中執行非同步 (asynchronous)程式碼而不會阻塞主執行緒的機制。\n\n## 事件循環 event loop 進行的流程\n\n1. Javascript 的主執行緒開始執行 scripts，並且將同步任務放入執行棧 （call stack），直到該任務完成後才會被移除。\n\n   - 棧 stack : 是一種資料結構，特色是先進後出，當程式碼執行時函式會先被放入執行棧的最上方，當函式執行完成就會從最上方移除，接著執行執行棧最上方的函式，直到整個執行棧被清空。\n\n2. 當執行時遇到非同步的任務時，例如：呼叫 api 或 `setTimeout()`，執行環境就會呼叫 Web API or Node.js API 讓其在背景運作。\n\n3. 等待非同步的任務獲得結果後，將其 callback 放到任務隊列(task queues)中。\n\n   - 隊列 queue: 是一種資料結構，特色是先進先出，可以想像是排隊的概念。\n\n   - 任務隊列(task queues)又可以分成微任務和宏任務：\n\n   - 微任務 Micro task queue：\n\n     - Promise.then\n     - Promise.catch\n     - Promise.finally\n     - process.nextTick（Node.js 環境）\n     - MutationObserver（瀏覽器環境）\n     - queueMicrotask()\n\n   - 宏任務 Macro task queue\n\n     - setTimeout()\n     - HTTP 請求\n     - UI handler:clicks, scrolls\n     - setInterval()\n     - script(整體程式碼)\n     - UI 渲染\n     - postMessage\n     - MessageChannel\n\n4. 當執行棧 （call stack）裡面所有的同步任務被執行完，就會去讀取任務隊列(task queues)，然後把任務隊列的第一個任務加到執行棧 （call stack）執行。\n\n   **微任務優先於宏任務**\n\n   - 會優先執行所有的微任務，當所有微任務執行完畢後，如果有新的微任務被添加到隊列中，則繼續依序執行新的微任務，直到微任務隊列清空。\n   - 從宏任務隊列中取出一個任務執行，執行完，事件循環會去檢查微任務的隊列，如果有未執行的微任務就會先把微任務執行完畢。\n\n這個過程會一直無限循環下去，Javascript 有效地去處理非同步與同步的運行，並且可以避免主執行緒阻塞。\n\n＊ 文字較為抽象，這個影片的說明更有助於理解整個觀念：\n[JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue](https://www.youtube.com/watch?v=eiC58R16hb8)\n\n---\n\n## 實例練習1\n\n[1. Promise order](https://bigfrontend.dev/quiz/1-promise-order)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(1);\nconst promise = new Promise((resolve) => {\n  console.log(2);\n  resolve();\n  console.log(3);\n});\n\nconsole.log(4);\n\npromise\n  .then(() => {\n    console.log(5);\n  })\n  .then(() => {\n    console.log(6);\n  });\n\nconsole.log(7);\n\nsetTimeout(() => {\n  console.log(8);\n}, 10);\n\nsetTimeout(() => {\n  console.log(9);\n}, 0);\n```\n\n---\n\n## 解題1\n\n1. 執行 `console.log(1)`，印出 `1`\n2. 執行 `const promise = new Promise((resolve) => {...}`中的 `console.log(2)`，印出`2`，`console.log(3)`，印出`3`\n3. `console.log(4)`，印出`4`\n4. 將 `promise.then(() => {console.log(5)}).then(() => {console.log(6)})`的 callback 放到微任務隊列，\n5. 執行 `console.log(7)`，印出`7`\n6. 將 `setTimeout(() => {console.log(8)}, 10)`放到宏任務隊列，等待 10ms 後執行。\n7. 將 `setTimeout(() => {console.log(9)}, 0)`放到宏任務隊列，但因為延遲是 0ms，所以這個宏任務會在所有同步代碼執行完後的下一次事件循環中優先執行。\n8. 同步代碼全部執行完畢，檢查微任務隊列，發現有微任務\n   - 將微任務隊列的`promise.then(() => {console.log(5)}).then(() => {console.log(6)})`放到 call stack 執行\n   - 執行`console.log(5)`，印出`5`\n   - 執行`console.log(6)`印出`6`\n9. 檢查微任務隊列，發現沒有微任務，檢查宏任務隊列，發現有宏任務\n   - 執行`setTimeout(() => {console.log(9)}, 0)`，印出`9`\n   - 執行`setTimeout(() => {console.log(8)}, 10)`，印出`8`\n\n## 實例練習2\n\n[47. Promise Order II](https://bigfrontend.dev/quiz/promise-order-II)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n}, 10);\n\nsetTimeout(() => {\n  console.log(3);\n}, 0);\n\nnew Promise((_, reject) => {\n  console.log(4);\n  reject(5);\n  console.log(6);\n})\n  .then(() => console.log(7))\n  .catch(() => console.log(8))\n  .then(() => console.log(9))\n  .catch(() => console.log(10))\n  .then(() => console.log(11))\n  .then(console.log)\n  .finally(() => console.log(12));\n\nconsole.log(13);\n```\n\n## 解題2\n\n1. 執行`console.log(1)`，印出`1`\n2. 把 `setTimeout(() => { console.log(2); }, 10)`放到宏任務隊列，延遲 10ms 後執行。\n3. 把 `setTimeout(() => { console.log(3); }, 0)`放到宏任務隊列中，延遲 0ms，會在事件循環的下一輪執行。\n4. 執行`new Promise((_, reject) => {...})`\n\n   - 執行`console.log(4)`，印出`4`\n   - 執行 `reject(5)`，將 `.catch()` 的回調放入微任務隊列，但不會立即執行\n   - 執行`console.log(6)`，印出`6`\n\n5. 執行`console.log(13)`，印出`13`\n6. 所有同步的程式碼都執行完了，檢查微任務隊列\n   - `reject(5)`觸發`.catch(() => console.log(8))`，印出`8`，\n   - 接著執行 `.then(() => console.log(9))`，印出`9`\n   - 接著執行 `.then(() => console.log(11))`印出`11`\n   - 接著執行 `.then(console.log)`，印出`undefined`\n   - 接著執行 `.finally(() => console.log(12))`，印出`12`\n7. 檢查微任務隊列，發現已清空，執行宏任務隊列\n   - 執行 `setTimeout(() => {console.log(3);}, 0);`印出`3`\n   - 執行 `setTimeout(() => {console.log(2);}, 10);`印出`2`\n\n## 實例練習3\n\n[103. Promise Order III](https://bigfrontend.dev/quiz/Promise-Order-III)\n\n```js\nconst createPromise = () => Promise.resolve(1);\n\nfunction func1() {\n  createPromise().then(console.log);\n  console.log(2);\n}\n\nasync function func2() {\n  await createPromise();\n  console.log(3);\n}\n\nconsole.log(4);\nfunc1();\nfunc2();\n```\n\n## 解題3\n\n1. 執行 `console.log(4)`，印出`4`\n2. 執行 `func1()`\n\n   - 執行`createPromise().then(console.log)`，這裡 `Promise.resolve(1)` 會立即 resolve，將 `console.log` 放到微任務列隊\n   - 執行 `console.log(2)`，印出`2`\n\n3. 執行 `async function func2()`\n\n   - 執行`await createPromise()`，此時`createPromise()`會立即 resolve，並暫停 `func2` 的執行，await 將控制權交還給主執行緒，並將剩下的部分`console.log(3)`放入微任務隊列\n\n4. 所有同步程式碼執行完畢，檢查微任務列隊\n   - 執行`console.log`，又`console.log`為`Promise.resolve(1)`的callback，故會印出`1`\n   - 執行`async function func2()`，執行`console.log(3)`，印出`3`\n","createdAt":"2025-08-16T08:43:46.238Z","updatedAt":"2025-08-16T10:25:14.851Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":40,"data":{"documentId":"cqvzd675llqokcvfi7l9ac1j","slug":"event-delegation","title":"Event delegation 事件委派","date":"2025-08-16T08:43:54.399Z","description":"JavaScript 中的事件委派 event delegation 事件委派 event delegation 事件委派 event delegation 是一種 JavaScript Pattern，在父層 DOM 元素上只要綁定一個監聽器，底下的子元素就看透過事件冒泡（Event Bubbling）機制觸發父層的監聽器，如此一來就不需要在每一個子元素上綁定個監聽器，只要在其共同的父元素上綁定一個即可。 優點: - 節省記憶體：監聽器數量變少，也就可以提升效能。 - 提高程式碼維護性：處理事件的邏輯只需要在父元素的監聽器寫一次。","content":"\n# JavaScript 中的事件委派 event delegation\n\n## 事件委派 event delegation\n\n事件委派 event delegation 是一種 JavaScript Pattern，在父層 DOM 元素上只要綁定一個監聽器，底下的子元素就看透過**事件冒泡（Event Bubbling）**機制觸發父層的監聽器，如此一來就不需要在每一個子元素上綁定個監聽器，只要在其共同的父元素上綁定一個即可。\n\n優點:\n\n- 節省記憶體：監聽器數量變少，也就可以提升效能。\n- 提高程式碼維護性：處理事件的邏輯只需要在父元素的監聽器寫一次。\n- 可以支援動態元素：可以動態的調整增加子元素，不需要額外的力氣處理綁定或移除子元素上的監聽器。\n\n```html\n<ul id=\"devices\">\n  <li>iPhone 16</li>\n  <li>S24 Ultra</li>\n  <li>Pixel 9 Pro XL</li>\n</ul>\n\n<script>\n  const devices = document.getElementById(\"devices\");\n\n  devices.addEventListener(\"click\", function (event) {\n    if (event.target.tagName === \"LI\") {\n      console.log(event.target.innerText);\n    }\n  });\n</script>\n```\n\n在這個例子中，`devices`作為父元素被綁定監聽器，將當點擊`<li>`，`<li>`就透過事件冒泡向上傳遞到`devices`，接著就可以透過`event.target`來檢查實際觸發事件的子元素是否符合條件，進而執行處理事件的邏輯\n\n## 實例練習\n\n[117. event delegation](https://bigfrontend.dev/problem/event-delegation)\n\nCan you create a function which works like jQuery.on(), that attaches event listeners to selected elements.\n\nIn jQuery, selector is used to target the elements, in this problem, it is changed to a predicate function.\n\n```js\nonClick(\n  // root element\n  document.body,\n  // predicate\n  (el) => el.tagName.toLowerCase() === \"div\",\n  function (e) {\n    console.log(this);\n    // this logs all the `div` element\n  },\n);\n```\n\nevent.stopPropagation() and event.stopImmediatePropagation() should also be supported.\n\nyou should only attach one real event listener to the root element.\n\n## 解題\n\n這題太難了，所以我看了別人的解答試圖去理解。\n\n參考解答：[BFE.dev 117. event delegation | JSer - Front-End Interview questions](https://www.youtube.com/watch?v=TkBQYTi1jJU>)\n\n```js\n// Map<node, Array<[predicate, handler]>>\nconst allHandlers = new Map(); //用來儲存每個 root 元素及其對應的事件處理器。每個 root 都會對應一個 Array，其中存放了多組 [predicate, handler]\n/**\n * @param {HTMLElement} root 根元素，事件監聽器將綁定在這個元素上\n * @param {(el: HTMLElement) => boolean} predicate 判斷函數，用於檢查事件目標是否符合條件\n * @param {(e: Event) => void} handler 事件處理函數，當事件目標符合條件時呼叫\n */\nfunction onClick(root, predicate, handler) {\n  if (allHandlers.has(root)) {\n    //檢查 allHandlers 是否已經儲存了對應的 root 元素。如果已經有，則直接將新的 [predicate, handler] 對添加到該 root 元素的處理器列表中\n    allHandlers.get(root).push([predicate, handler]);\n    //將新的 [predicate, handler] 對添加到該 root 元素的處理器列表中\n    return;\n  }\n  //如果沒有對應的 root 元素，則創建一個新的數組\n  allHandlers.set(root, [[predicate, handler]]);\n  // 然後在 root 上綁定一個 click 事件監聽器\n  root.addEventListener(\n    \"click\",\n    function (e) {\n      // 從事件目標元素 e.target 開始，一層層向上遍歷 DOM 結構，直到到達 root 元素或事件冒泡被停止\n      let el = e.target;\n      const handlers = allHandlers.get(root);\n      let isPropagationStopped = false;\n      e.stopPropagation = () => {\n        //用來手動控制事件傳播，避免事件繼續冒泡到父元素\n        isPropagationStopped = true;\n      };\n      //使用 while (el) 檢查事件目標及其父元素是否符合判斷函數的條件\n      while (el) {\n        let isImmediatePropagationStopped = false;\n        e.stopImmediatePropagation = () => {\n          //isImmediatePropagationStopped 停止傳播事件的同時也停止同一元素上後續的處理器執行\n          isImmediatePropagationStopped = true;\n          isPropagationStopped = true;\n        };\n        for (const [predicate, handler] of handlers) {\n          //predicate(el)：用來判斷當前元素是否符合條件\n          if (predicate(el)) {\n            //執行對應的 handler 處理函式\n            handler.call(el, e);\n            // 檢查是否需要停止事件傳播\n            if (isImmediatePropagationStopped) {\n              break;\n            }\n          }\n        }\n        //如果 isPropagationStopped 設為 true，或者已經遍歷到 root 元素，則停止事件的繼續傳播\n        if (el === root || isPropagationStopped) break;\n        el = el.parentElement;\n      }\n    },\n    false,\n  );\n}\n```\n","createdAt":"2025-08-16T08:43:46.286Z","updatedAt":"2025-08-16T10:25:14.862Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":42,"data":{"documentId":"ealem383tko6x7u45yzl1l7s","slug":"this","title":"this 如何在 JavaScript 中運作？","date":"2025-08-16T08:43:54.430Z","description":"this 如何在 JavaScript 中運作？ 在 JavaScript 中this的指向會根據不同呼叫的方式而有不同的結果，以下分別列出幾種this的運作方式： 全域環境 在全域的環境下： - 瀏覽器中：this指向的是window物件 - Node.js: this指向一個空的模組作用域內的物件 直接呼叫函式 當直接呼叫函式，在函式中的this均指向的是window物件。 new 運算子 使用new運算子會建立一個新的物件實例，此時的this的指向為該物件。 物件的方法 當呼叫物件中的方法時，此時的this指向的是呼叫該方法的物件。","content":"\n# this 如何在 JavaScript 中運作？\n\n在 JavaScript 中`this`的指向會根據不同呼叫的方式而有不同的結果，以下分別列出幾種`this`的運作方式：\n\n## 全域環境\n\n在全域的環境下：\n\n- 瀏覽器中：`this`指向的是`window`物件\n- Node.js: `this`指向一個空的模組作用域內的物件\n\n```js\nconsole.log(this === window); //true\n```\n\n## 直接呼叫函式\n\n當直接呼叫函式，在函式中的`this`均指向的是`window`物件。\n\n```js\nfunction hiThis() {\n  console.log(this === window); // true (在瀏覽器中，非嚴格模式)\n}\n\nhiThis();\n\n(\"use strict\");\nfunction hiStrict() {\n  console.log(this === undefined); // true (嚴格模式)\n}\n\nhiStrict();\n```\n\n## new 運算子\n\n使用`new`運算子會建立一個新的物件實例，此時的`this`的指向為該物件。\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nconst person = new Person(\"Ashley\");\nconsole.log(person.name); // \"Ashley\"\n```\n\n## 物件的方法\n\n當呼叫物件中的方法時，此時的`this`指向的是呼叫該方法的物件。\n\n```js\nconst person = {\n  name: \"Ashley\",\n  sayHi: function () {\n    console.log(`Hi!${this.name}.`); //Hi!Ashley.\n  },\n};\n\nperson.sayHi();\n```\n\n在這個例子中，`this`指向的是 person\n\n## class constructor\n\n在 class 中 `this` 是自動綁定到 `class` 的實例，在 class 函式建構子中使用`this`呼叫函式，這裡的`this`指向的是 class 的實例。\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getPersonName() {\n    console.log(this);\n  }\n}\n\nconst person = new Person(\"Ashley\");\nconsole.log(person.getPersonName()); //Person{name:'Ashley'}\n```\n\n`this` 指向 class 的物件實例，也就是 Person 的實例。\n\n## 箭頭函式\n\n箭頭函式沒有自己的`this`，是繼承外層作用域的 `this`，因此即使在物件內使用箭頭函式，`this` 也不會指向該物件，而是指向箭頭函式定義時的外層環境。\n\n```js\nconst person = {\n  name: \"Ashley\",\n  sayHi: () => {\n    console.log(`Hi!${this.name}`); //Hi!undefined\n  },\n};\n\nperson.sayHi();\n```\n\n因為箭頭函式中的 `this` 是從外層作用域繼承，而不是指向 `person`，因為箭頭函式中的 this 指向外層的`window`，所以此例中 `this.name` 是 `undefined`。\n\n```js\nconst person = {\n  name: \"Ashley\",\n  sayHi: function () {\n    const arrowFn = () => {\n      console.log(`Hi!${this.name}`); //Hi!Ashley\n    };\n    arrowFn();\n  },\n};\n\nperson.sayHi();\n```\n\n在這個例子中，`arrowFn` 繼承了 `sayHi` 函式中的 `this`，因此指向 `person`。\n\n## 使用 `.call()`、.`apply()`、`.bind()`\n\n使用`.call`、`.apply`、`.bind.`可以傳入物件改變`this`的指向。\n\n```js\nfunction greet() {\n  console.log(this.name);\n}\n\nconst person = { name: \"Ashley\" };\n\ngreet.call(person); // Ashley\ngreet.apply(person); // Ashley\n\nconst boundGreet = greet.bind(person);\nboundGreet(); // Ashley\n```\n\n`call()` 和 `apply()` 會立即執行函式，並將 `this` 設定為傳入的物件。\n`bind()` 則會返回一個新的函式，並永久綁定 `this` 到傳入的物件。\n\n---\n\n## 實例練習 1\n\n[41. `this` III](https://bigfrontend.dev/quiz/this-III)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: this.a + 1,\n  c: () => this.a + 1,\n  d() {\n    return this.a + 1;\n  },\n  e() {\n    return (() => this.a + 1)();\n  },\n};\nconsole.log(obj.b);\nconsole.log(obj.c());\nconsole.log(obj.d());\nconsole.log(obj.e());\n```\n\n## 解題 1\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: this.a + 1,\n  c: () => this.a + 1,\n  d() {\n    return this.a + 1;\n  },\n  e() {\n    return (() => this.a + 1)();\n  },\n};\nconsole.log(obj.b); //NaN; 因為這裡this指的是window物件，undefined + 1\nconsole.log(obj.c()); //NaN; 因為這裡this指的是window物件，undefined + 1\nconsole.log(obj.d()); //2;因為這裡this指的是obj,1+1\nconsole.log(obj.e()); //2;因為匿名函式的this指向是上一層的作用域，上一層的指向是obj,1+1\n```\n\n## 實例練習 2\n\n[19. `this`](https://bigfrontend.dev/quiz/this)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: function () {\n    console.log(this.a);\n  },\n  c() {\n    console.log(this.a);\n  },\n  d: () => {\n    console.log(this.a);\n  },\n  e: (function () {\n    return () => {\n      console.log(this.a);\n    };\n  })(),\n  f: function () {\n    return () => {\n      console.log(this.a);\n    };\n  },\n};\n\nconsole.log(obj.a);\nobj.b();\nobj.b();\nconst b = obj.b;\nb();\nobj.b.apply({ a: 2 });\nobj.c();\nobj.d();\nobj.d();\nobj.d.apply({ a: 2 });\nobj.e();\nobj.e();\nobj.e.call({ a: 2 });\nobj.f()();\nobj.f()();\nobj.f().call({ a: 2 });\n```\n\n## 解題 2\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: function () {\n    console.log(this.a);\n  },\n  c() {\n    console.log(this.a);\n  },\n  d: () => {\n    console.log(this.a);\n  },\n  e: (function () {\n    return () => {\n      console.log(this.a);\n    };\n  })(),\n  f: function () {\n    return () => {\n      console.log(this.a);\n    };\n  },\n};\n\nconsole.log(obj.a); //1\nobj.b(); //1，this指向為obj\nobj.b(); //1，this指向為obj\nconst b = obj.b;\nb(); //undefined，b 被賦值給變數 b，這時 this 是 undefined\nobj.b.apply({ a: 2 }); //2，因為使用apply指定this為{ a: 2 }\nobj.c(); //1，this指向為obj\nobj.d(); //undefined，因為是箭頭函式，綁到上一層的作用域也就是全域\nobj.d(); //undefined\nobj.d.apply({ a: 2 }); //undefined，因為是箭頭函式，參考上一層\nobj.e(); //undefined，因為是箭頭函式，參考上一層\nobj.e(); //undefined，因為是箭頭函式，參考上一層\nobj.e.call({ a: 2 }); //undefined，箭頭函數的 this 不會被 call 改變\nobj.f()(); //1，f 返回一個箭頭函數，this 綁定到 f 的 this，即 obj\nobj.f()(); //1\nobj.f().call({ a: 2 }); //1，箭頭函數的 this 不會被 call 改變\n```\n","createdAt":"2025-08-16T08:43:46.340Z","updatedAt":"2025-08-16T10:25:15.165Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":44,"data":{"documentId":"vasdn9zuwi0xojqila7spk2q","slug":"cookie-sessionstorage-localstorage","title":"cookie, sessionStorage 和 localStorage 在瀏覽器中的差異","date":"2025-08-16T08:43:54.464Z","description":"","content":"\n# cookie, sessionStorage 和 localStorage 在瀏覽器中的差異\n\n以下幾點為 cookie, sessionStorage 和 localStorage 主要的差異：\n\n## 生命週期長短\n\n- cookie：cookie 的預設行為是在瀏覽器關閉後會消失，但是可以自行透過 Expires 標明失效時間、 Max-Age 標明有效時間長度，讓 cookie 在瀏覽器關閉後能依然存在。\n- sessionStorage：瀏覽器關閉後自動清除，甚至在相同網域的不同標籤頁之間也無法共享。\n- localStorage：如果沒有手動去清除的話，會永久保存在瀏覽器。\n\n## 資料儲存的大小\n\n- cookie：4KB 左右。\n- sessionStorage：依據不同瀏覽器 5MB~10MB。\n- localStorage：依據不同瀏覽器 5MB~10MB。\n\n## 使用的方式\n\n- cookie：cookie 會隨著 http 請求打到伺服器，會在第一次 client 發送請求後，sever 會在 response 的 header 加入`Set-Cookie` 還有 response 加入 cookie，當 client 收到後會存在瀏覽器本地。\n\n- sessionStorage：使用 key-value 的形式儲存在瀏覽器本地。\n- localStorage：使用 key-value 的形式儲存在瀏覽器本地。\n\n## 應用場景\n\n- cookie： 適合用來用戶驗證、追蹤會話。\n- sessionStorage： 因為生命週期較短，適合短期且臨時的資料儲存，例如：表單的資料、購物車。\n- localStorage： 生命週期很長，適合存需要長期保存的資料例如：主題選擇、語系設定。\n\n---\n\n## 實例練習\n\n[135. localStorage with expiration](https://bigfrontend.dev/problem/localStorage-with-expiration)\nlocalStorage is a simple and handy client-side storage, but you should avoid using it because it is synchronous.\n\nAlso Safari's ITP actually deletes client-side script-writable storage after 7 days of Safari use without interacting on your website, and localStorage is included.\n\nUnlike Cookie, localStorage doesn't expire.\n\nIn this problem, please create a localStorage wrapper with expiration support\n\n```js\nmyLocalStorage.setItem(\"bfe\", \"dev\", 1000);\nmyLocalStorage.getItem(\"bfe\");\n// 'dev'\n```\n\nafter 1 second:\n\n```js\nmyLocalStorage.getItem(\"bfe\");\n// null\n```\n\n## 解題\n\n參考 [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)\n\n```js\nwindow.myLocalStorage = {\n  getItem(key) {\n    const data = window.localStorage.getItem(key);\n    if (!data) return null; // key 不存在\n    const parsedData = JSON.parse(data);\n    // 檢查 expiry ，沒有設置 expiry 或尚未過期，則返回 value\n    if (!parsedData.expiry || parsedData.expiry > Date.now()) {\n      return parsedData.value;\n    } else {\n      // 如果過期了，移除該項目並返回 null\n      window.localStorage.removeItem(key);\n      return null;\n    }\n  },\n\n  setItem(key, value, maxAge) {\n    window.localStorage.setItem(key, value);\n\n    if (maxAge === 0) {\n      //因為這題必須要在 LocalStorage 實現失效時間的功能，因此如果 maxAge 失效時間是0的話就代表就是失效了，直接移除該項目\n      window.localStorage.removeItem(key);\n    }\n    //計算出過期的時間\n    const expiry = maxAge > 0 ? Date.now() + maxAge : null;\n    //將過期的時間跟資料儲存\n    const data = {\n      value: value,\n      expiry: expiry,\n    };\n    // 儲存 JSON 字串到 localStorage\n    window.localStorage.setItem(key, JSON.stringify(data));\n  },\n\n  removeItem(key) {\n    window.localStorage.removeItem(key);\n  },\n\n  clear() {\n    window.localStorage.clear();\n  },\n};\n```\n","createdAt":"2025-08-16T08:43:46.426Z","updatedAt":"2025-08-16T08:43:54.493Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":46,"data":{"documentId":"q4jmgx1hru1t9rdmeoaaqnbh","slug":"script","title":"<script>, <script async> 和 <script defer> 的差異","date":"2025-08-16T08:43:54.514Z","description":", 和 的差異 透過我們可以適當的控制腳本在瀏覽器載入的時機。 這是預設的腳本加載方式，在網頁渲染的過程中，會使用 在 HTML 中載入 Javascript，當執行到時，瀏覽器會暫停解析 HTML，開始下載 腳本並且立即執行，直到 執行完畢才會繼續解析 HTML 建立 DOM。但是當需要載入的腳本很多的時候，會阻塞頁面渲染，會導致使用者體驗不佳。 - 適用於： 需要立即執行的腳本，特別是那些會影響到 HTML 結構的腳本（例如，使用 document.write() 的腳本）。","content":"\n# `<script>`, `<script async>` 和 `<script defer>` 的差異\n\n透過`<script>`我們可以適當的控制腳本在瀏覽器載入的時機。\n\n## `<script>`\n\n這是預設的腳本加載方式，在網頁渲染的過程中，會使用 `<script>` 在 HTML 中載入 Javascript，當執行到`<script>`時，瀏覽器會暫停解析 HTML，開始下載 `<script>`腳本並且立即執行，直到`<script>` 執行完畢才會繼續解析 HTML 建立 DOM。但是當需要載入的`<script>`腳本很多的時候，會阻塞頁面渲染，會導致使用者體驗不佳。\n\n```html\n<script src=\"index.js\"></script>\n```\n\n- 適用於：\n  需要立即執行的腳本，特別是那些會影響到 HTML 結構的腳本（例如，使用 document.write() 的腳本）。\n\n## Non-Blocking:`<script async>` 和 `<script defer>`\n\n使用 `async` 屬性和 `defer` 屬性可以讓 `<script>` 檔案在一開始就在背景先下載，可以避免腳本阻塞 HTML 解析。\n\n### `<script async>`\n\n`async` 屬性會非同步下載 `<script>`腳本，一旦下載好就立刻執行，開始時執行會停止解析 HTML，但下載本身不會阻塞 HTML 的解析。如果有多個 `<script>` 並不能保證 `<script>` 間執行的順序，也不確定腳本執行的時候 HTML 是否完全解析完成。\n\n- 適用於：\n  不需要依賴 DOM 或者不需要嚴格執行順序的獨立腳本的第三方函式庫，例如：GA。\n\n### `<script defer>`\n\n`defer`屬性會非同步下載 `<script>` 腳本，但是與 `async` 屬性不同的是，`defer` 屬性不會打斷 DOM 建立的過程，而是等到 HTML 解析完成，並且在 `DOMContentLoad` 執行之前執行下載好的腳本，另外，`defer` 會保證 script 是依照 `<script>` 的順序去執行。\n\n- 適用於：\n  依賴 DOM 或是跟其他模組有相互依賴的模組。\n","createdAt":"2025-08-16T08:43:46.502Z","updatedAt":"2025-08-16T10:25:14.876Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":48,"data":{"documentId":"ckytvb2llrbgd5xlg0d8iwak","slug":"null-undefined-undeclared","title":"null, undefined 和 undeclared 的差異","date":"2025-08-16T08:43:54.557Z","description":"null, undefined 和 undeclared 的差異 null - 變數被宣告並且被指定爲有意義的空值 null，通常用來明確地表示「沒有值」或「空物件」的狀態。null 的型別是物件。 - 型別: null 的型別是物件。 - 使用場景：當你明確地想表示某個變數不應該有任何值時，可以將其設為 null。 undefined - 變數被宣告已經被宣告但是並沒有指派一個值，當 JavaScript 初始化變數或找不到某個物件的屬性時，會自動給它賦值為 undefined。 - 型別: undefined。","content":"\n# null, undefined 和 undeclared 的差異\n\n## `null`\n\n- 變數被宣告並且被指定爲有意義的空值 `null`，通常用來明確地表示「沒有值」或「空物件」的狀態。`null` 的型別是物件。\n- 型別: `null` 的型別是物件。\n- 使用場景：當你明確地想表示某個變數不應該有任何值時，可以將其設為 `null`。\n\n```js\nlet obj = null;\nconsole.log(typeof obj); // \"object\"\n```\n\n## `undefined`\n\n- 變數被宣告已經被宣告但是並沒有指派一個值，當 JavaScript 初始化變數或找不到某個物件的屬性時，會自動給它賦值為 `undefined`。\n- 型別: `undefined`。\n- 使用場景：當沒有給變數賦值，或者函數沒有返回值時，JavaScript 會自動給它 `undefined`。\n\n在鬆散的比較中， `null` == `undefined`，但在嚴格比較中 === 它們是不相等的。\n\n```js\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\n```\n\n```js\nlet x;\nconsole.log(x); // undefined\nconsole.log(typeof x); // \"undefined\"\n```\n\n## undeclared\n\n- undeclared 就是從未被宣告過的變數。如果在嚴格模式下嘗試使用未宣告的變數，會拋出 ReferenceError 錯誤。\n- 使用場景：undeclared 通常是由於變數使用前未宣告造成的錯誤，這在嚴格模式下尤其會被檢測出來。\n\n```js\n\"use strict\";\n\nx = 1; //會在嚴格模式下拋出 ReferenceError 錯誤，因為變數沒有被宣告\nconsole.log(x);\n```\n\n在非嚴格模式下，這種行為會自動在全域範圍創建變數，這可能導致意想不到的副作用。\n\n```\nx = 1; // 非嚴格模式下會隱式創建全域變數 x\nconsole.log(x); // 1\n\n```\n\n---\n\n## 實例練習 1\n\n[Type Utilities](https://www.greatfrontend.com/questions/javascript/type-utilities)\nIn this question, we will implement the following utility functions to determine the types of primitive values.\n\n- isBoolean(value): Return true if value is a boolean, false otherwise.\n- isNumber(value): Return true if value is a number, false otherwise. Note that NaN is considered a number.\n- isNull(value): Return true if value is null, false otherwise.\n- isString(value): Return true if value is a String, else false.\n- isSymbol(value): Return true if value is a Symbol primitive, else false.\n- isUndefined(value): Return true if value is undefined, else false.\n\n## 解題 1\n\n```js\nexport function isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n\nexport function isNumber(value) {\n  return typeof value === \"number\";\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isString(value) {\n  return typeof value === \"string\";\n}\n\nexport function isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\nexport function isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n```\n\n## 實例練習 2\n\n[9. null and undefined](https://bigfrontend.dev/quiz/null-and-undefined)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(JSON.stringify([1, 2, null, 3]));\nconsole.log(JSON.stringify([1, 2, undefined, 3]));\nconsole.log(null === undefined);\nconsole.log(null == undefined);\nconsole.log(null == 0);\nconsole.log(null < 0);\nconsole.log(null > 0);\nconsole.log(null <= 0);\nconsole.log(null >= 0);\nconsole.log(undefined == 0);\nconsole.log(undefined < 0);\nconsole.log(undefined > 0);\nconsole.log(undefined <= 0);\nconsole.log(undefined >= 0);\n```\n\n## 解題 2\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(JSON.stringify([1, 2, null, 3])); //\"[1,2,null,3]\"\nconsole.log(JSON.stringify([1, 2, undefined, 3])); //\"[1,2,null,3]\"，undefined 被轉換為 null，因為 JSON 不支持 undefined 作為有效值\nconsole.log(null === undefined); //false\nconsole.log(null == undefined); //true\nconsole.log(null == 0); //false\nconsole.log(null < 0); //false\nconsole.log(null > 0); //false\nconsole.log(null <= 0); //true，null 會被轉換為 0\nconsole.log(null >= 0); //true，null 會被轉換為 0\nconsole.log(undefined == 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined < 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined > 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined <= 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined >= 0); //false，undefined 會被轉換為 NaN\n```\n","createdAt":"2025-08-16T08:43:46.605Z","updatedAt":"2025-08-16T10:25:15.201Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":50,"data":{"documentId":"zys0aaevc7h803fdwqlioxyv","slug":"call-apply","title":".call 和 .apply 的差異","date":"2025-08-16T08:43:54.617Z","description":".call 和 .apply 的差異 .call跟.apply 都可以直接呼叫函式並且改變函式內 this 的指向，兩者最主要的差異是傳入的參數形式不同。 .call - 定義：.call 方法會立即執行函式，並將 this 指向傳入的第一個參數，接下來的參數是要傳給函式的具體值，一個一個地傳入。 - 參數形式：.call是 逐個傳入參數的。 - fn.call(thisArg, arg1, arg2, ...) - 使用時機：所有參數的數量，並且想逐個傳遞。 在這個例子中，this 被設定為 person，並且 food 和 count 是逐個傳入的。","content":"\n# .call 和 .apply 的差異\n\n`.call`跟`.apply` 都可以直接呼叫函式並且改變函式內 this 的指向，兩者最主要的差異是傳入的參數形式不同。\n\n## `.call`\n\n- 定義：`.call` 方法會立即執行函式，並將 this 指向傳入的第一個參數，接下來的參數是要傳給函式的具體值，一個一個地傳入。\n- 參數形式：`.call`是 逐個傳入參數的。\n- `fn.call(thisArg, arg1, arg2, ...)`\n- 使用時機：所有參數的數量，並且想逐個傳遞。\n\n```js\nfunction order(food, count) {\n  console.log(this.name, \"點了\", food, count);\n  //Ashley 點了 豚骨拉麵 一份\n}\nconst person = {\n  name: \"Ashley\",\n};\norder.call(person, \"豚骨拉麵\", \"一份\");\n```\n\n在這個例子中，this 被設定為 person，並且 food 和 count 是逐個傳入的。\n\n## `.apply`\n\n- 定義：`.apply` 與 `.call` 類似，也會立即執行函式，並將 this 指向傳入的第一個參數。但是，接下來的參數必須以陣列的形式傳遞。\n- 參數形式：`.apply` 是用 **陣列** 傳遞參數的。\n- `fn.apply(thisArg, [arg1, arg2, ...])`\n- 使用時機：參數是以陣列的形式存在，或者數量不確定時。\n\n```js\nfunction order(food, count) {\n  console.log(this.name, \"點了\", food, count);\n  //Andy 點了 沾麵 兩份\n}\nconst person = {\n  name: \"Andy\",\n};\norder.apply(person, [\"沾麵\", \"兩份\"]);\n```\n\n在這個例子中，this 被設定為 person，而參數 food 和 count 是以陣列的形式傳遞。\n","createdAt":"2025-08-16T08:43:46.661Z","updatedAt":"2025-08-16T10:25:15.121Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":52,"data":{"documentId":"n2cksk0fuqh49dfbws2q766b","slug":"closure","title":"closure 閉包是什麼？如何應用？","date":"2025-08-16T08:43:54.667Z","description":"closure 閉包是什麼？如何應用？ 閉包是什麼？ closure 函式可以存取其外部函式的變數，即使外部函式已經執行完畢並離開其作用域。可以存取到外部變數的原因在於: JavaScript 使用了語法作用域（lexical scope），在函式定義時會記住函式被定義時的變數環境，並且這些變數會一直存在於記憶體中，只要閉包中的內部函式仍然在使用它們。 當外部函式執行完畢後，通常會釋放其作用域中的變數以節省記憶體。但如果某個內部函式（閉包）仍然引用這些變數，那麼這些變數將不會被釋放，而是持續存在於內部函式的作用域鏈中。","content":"\n# closure 閉包是什麼？如何應用？\n\n## 閉包是什麼？\n\nclosure 函式可以存取其外部函式的變數，即使外部函式已經執行完畢並離開其作用域。可以存取到外部變數的原因在於: JavaScript 使用了語法作用域（lexical scope），在函式定義時會記住函式被定義時的變數環境，並且這些變數會一直存在於記憶體中，只要閉包中的內部函式仍然在使用它們。\n\n當外部函式執行完畢後，通常會釋放其作用域中的變數以節省記憶體。但如果某個內部函式（閉包）仍然引用這些變數，那麼這些變數將不會被釋放，而是持續存在於內部函式的作用域鏈中。\n\n```js\nfunction outerFunction() {\n  let outerVariable = \"I am outside!\";\n\n  function innerFunction() {\n    console.log(outerVariable);\n  }\n\n  return innerFunction;\n}\n\nconst closureFunction = outerFunction();\nclosureFunction(); // I am outside!\n```\n\n- 內部函式 `innerFunction` 是閉包，它記住了 `outerFunction` 的語法作用域，它可以存取到外部變數 `outerVariable`，即使 `outerFunction` 已經執行完畢。\n\n## 閉包的應用\n\n### 資料封裝\n\n閉包可以用來模擬私有變數，使得外部無法直接存取某些變數，只能透過內部函式進行操作。\n\n```js\nfunction createCounter() {\n  let count = 0;\n\n  return function () {\n    count++;\n    console.log(count);\n  };\n}\n\nconst counter = createCounter();\ncounter(); // 1\ncounter(); // 2\n```\n\ncount 只能透過 `counter` 函式來來增加或減少值，外部無法直接存取。\n\n### 模擬私有方法和變數\n\n閉包可以用來模擬類似於物件中的私有變數和方法。\n\n```js\nfunction counter() {\n  let count = 0;\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  return {\n    increment,\n    decrement,\n    getCount,\n  };\n}\nconst teamACounter = counter();\nteamACounter.increment();\nteamACounter.increment();\nteamACounter.decrement();\nconsole.log(teamACounter.getCount()); // 1\nconst teamBCounter = counter();\nteamBCounter.increment();\nteamBCounter.increment();\nconsole.log(teamBCounter.getCount()); // 2\n```\n\n在這個例子中，`count` 變數是私有的，外部無法直接存取，只能透過 `increment`、`decrement` 和 `getCount` 這三個方法來操作。\n同時可以透過閉包的特性，創建多個獨立的 Counter，互不影響。\n\n### 事件處理（Event handlers）和回呼函式（Callbacks）\n\n閉包經常應用於事件處理或回呼函式中，特別是當需要保持一些狀態或變數時。\nReact 中的 `useState` 就是應用了閉包的特性。\n\n```js\nimport React, { useState } from \"react\";\n\nconst Button = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount((prevCount) => prevCount + 1);\n    console.log(`Button clicked ${count} times`);\n  };\n\n  return <button onClick={handleClick}>Click me</button>;\n};\n```\n\n在這個例子中，`handleClick` 函式是閉包，每次點擊按鈕都會增加 `count` 變數的值。\n\n---\n\n## 實例練習\n\n[99. closure](https://bigfrontend.dev/quiz/closure-1)\n\n```js\nlet dev = \"bfe\";\n\nfunction a() {\n  let dev = \"BFE\";\n  return function () {\n    console.log(dev);\n  };\n}\n\ndev = \"bigfrontend\";\n\na()();\n```\n\n## 解題\n\n答案是`\"BFE\"`，因為 `a()` 函式是閉包，它記住了 `a` 函式被定義時的變數環境，即 `dev` 為 \"BFE\"。\n","createdAt":"2025-08-16T08:43:46.710Z","updatedAt":"2025-08-16T10:25:14.887Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":54,"data":{"documentId":"dalvzazm4whlh6di7x8a2i5g","slug":"prototype","title":"Prototype 原型繼承如何在 JavaScript 運作中？","date":"2025-08-16T08:43:54.744Z","description":"原型繼承如何在 JavaScript 運作中？ 原型 (Prototype) 在 JavaScript 中，每個物件都有一個內部屬性稱為 [[Prototype]]，它指向該物件的原型。原型是一個物件，包含了可以被其他物件共享的屬性和方法。 proto和[[Prototype]] - proto:是大多數現代瀏覽器中暴露出的屬性，允許開發者存取和設置物件的原型（不建議直接使用），proto目前已經棄用了。 - [[Prototype]]：描述了物件與其原型之間的隱藏式連結。","content":"\n# 原型繼承如何在 JavaScript 運作中？\n\n## 原型 (Prototype)\n\n在 JavaScript 中，每個物件都有一個內部屬性稱為 [[Prototype]]，它指向該物件的原型。原型是一個物件，包含了可以被其他物件共享的屬性和方法。\n\n## `__proto__`和`[[Prototype]]`\n\n- `__proto__`:是大多數現代瀏覽器中暴露出的屬性，允許開發者存取和設置物件的原型（不建議直接使用），`__proto__`目前[已經棄用](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)了。\n- `[[Prototype]]`：描述了物件與其原型之間的隱藏式連結。\n\n## 原型鏈(Prototype Chain)\n\n原型鏈有往上查找的特性，當存取一個物件的屬性或方法時，Javascript 會先在物件本身尋找，如果找不到就會沿著原型鏈往上尋找，直到找到為止。原型鏈是由一系列物件組成的，它們通過 **proto** 屬性彼此相連，最終指向 `Object.prototype`，原型鏈的末端。\n\n```js\n//定義一個建構子\nfunction Phone(brand, model) {\n  this.brand = brand;\n  this.model = model;\n}\n//在 Phone.prototype 上定義一個方法，所有 Phone 的實例都能訪問\nphone.prototype.ring = function () {\n  console.log(\"Ring ring!\");\n};\n//使用建構子建立一個物件\nconst myPhone = new Phone(\"Apple\", \"iPhone 16\");\n\n//存取物件的屬性\nconsole.log(myPhone.brand); // Apple\n\n//存取從原型繼承的方法\nmyPhone.ring(); // Ring ring!\n\n//原型鏈\n// myPhone.__proto__ 的原型是 Phone.prototype\nconsole.log(myPhone.__proto__ === Phone.prototype); // true\n\n// Phone.prototype 的原型是 Object.prototype\nconsole.log(Phone.prototype.__proto__ === Object.prototype); // true\n\n// Object.prototype 是原型鏈的終點，其原型為 null\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n在這個範例中，myPhone 是 Phone 建構函數的實例，它的 **proto** 屬性指向 `Phone.prototype`，這樣它可以存取 `Phone.prototype` 上的 `ring` 方法。如果 `Phone.prototype` 上也找不到某個屬性或方法，JavaScript 會繼續沿著原型鏈向上查找，直到達到 `Object.prototype`。\n\nJavaScript 中的原型繼承是基於物件之間的關聯，每個物件都有一個原型物件，通過原型鏈的機制可以實現屬性和方法的繼承，可以實現一個物件從另一個物件繼承屬性和方法，實現程式碼的重用和擴展。\n\n---\n\n## 實例練習 1\n\n[48. Prototype](https://bigfrontend.dev/quiz/prototype)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nfunction Foo() {}\nFoo.prototype.bar = 1;\nconst a = new Foo();\nconsole.log(a.bar);\n\nFoo.prototype.bar = 2;\nconst b = new Foo();\nconsole.log(a.bar);\nconsole.log(b.bar);\n\nFoo.prototype = { bar: 3 };\nconst c = new Foo();\nconsole.log(a.bar);\nconsole.log(b.bar);\nconsole.log(c.bar);\n```\n\n## 解題1\n\n```js\nfunction Foo() {}\nFoo.prototype.bar = 1;\nconst a = new Foo();\nconsole.log(a.bar); //1，Foo.prototype.bar 定義了一個屬性 bar，a 繼承了這個屬性。\n\nFoo.prototype.bar = 2;\nconst b = new Foo();\nconsole.log(a.bar); //2，Foo.prototype.bar 被重新賦值為 2，a 和 b 都繼承了這個屬性。\nconsole.log(b.bar); //2，由於 a 的原型鏈指向 Foo.prototype，所以 a.bar 也變成了 2。\n\nFoo.prototype = { bar: 3 };\nconst c = new Foo();\nconsole.log(a.bar); //2，a 的原型鏈仍然指向舊的 Foo.prototype，所以 a.bar 仍然是 2。\nconsole.log(b.bar); //2，b 的原型鏈仍然指向舊的 Foo.prototype，所以 b.bar 仍然是 2。\nconsole.log(c.bar); //3，Foo.prototype 被重新賦值為一個新物件，c 繼承了這個新物件。\n```\n\n## 實例練習 2\n\n[53. Prototype 2](https://bigfrontend.dev/quiz/prototype2)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nfunction F() {\n  this.foo = \"bar\";\n}\n\nconst f = new F();\nconsole.log(f.prototype);\n```\n\n## 解題2\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nfunction F() {\n  this.foo = \"bar\";\n}\n\nconst f = new F();\nconsole.log(f.prototype); //undefined，f 是 F 的實例，而不是 F 的原型\n```\n","createdAt":"2025-08-16T08:43:46.770Z","updatedAt":"2025-08-16T10:25:14.897Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":56,"data":{"documentId":"oo4w02kxmsk2xpyrwcd6wgy6","slug":"map-set-weakmap-weakset","title":"Map/Set 和 WeakMap/WeakSet 之間的差別是什麼？","date":"2025-08-16T08:43:54.794Z","description":"","content":"\n# Map/Set 和 WeakMap/WeakSet 之間的差別是什麼？\n\n## `Map`和`WeakMap`\n\n### `Map`\n\n- 結構：`Map` 是一個以 key-value 的形式儲存資料，類似物件的資料結構，key 可以是任何型別，而 value 也可以是任何型別。\n- 使用`new Map()` 來生成實例。\n- 記憶體管理： keys values 不會受到 Javascript 垃圾回收機制的影響。\n- 使用場景: 當需要儲存 key-value 的資料時，並且希望 key 保留在記憶體中直到手動刪除時。\n\n```js\nconst map = new Map();\nmap.set(\"name\", \"Ashley\");\nconsole.log(map.get(\"name\")); // 'Ashley'\nmap.delete(\"name\");\nconsole.log(map.size); // 0\n```\n\n### `WeakMap`\n\n- 結構：`WeakMap` 的 key 只能是物件和 Symbol，value 可以是任何型別。\n- 記憶體管理：`WeakMap` 的 key 是弱引用(weak reference)，當 key 不再被引用時，`WeakMap` 會被垃圾回收機制自動回收這個 key-value 對象。\n- 使用`new WeakMap()` 來生成實例。\n- 使用場景: caching data，適合用於需要暫存物件，當 key 不再被引用時，自動回收資料。\n\n```js\nconst weakMap = new WeakMap();\nlet obj = {};\nweakMap.set(obj, \"value\");\nconsole.log(weakMap.get(obj)); // 'value'\nobj = null; // 解除對 obj 的引用，該 key-value 對象會被自動回收\n```\n\n## `Set`和`WeakSet`\n\n### `Set`\n\n- 結構：`Set` 是一個儲存唯一值的集合，類似陣列，但是不允許重複的值。\n- 記憶體管理：值不會受到 Javascript 垃圾回收機制的影響。\n- 使用場景: 當需要管理唯一值的集合，特別是需要剔除重複值時。\n\n```js\nconst set = new Set([1, 1, 1, 2, 2, 3, 4, 5]);\nconsole.log(set); // Set { 1, 2, 3, 4, 5 }\nset.add(6);\nconsole.log(set.has(6)); // true\nset.delete(6);\nconsole.log(set.has(6)); // false\nconsole.log(set.size); // 5\n```\n\n#### `WeakSet`\n\n- 結構：`WeakSet` 的元素只能是物件，並且是弱引用(weak reference)。\n- 記憶體管理：當存入的物件不再被引用時，會被垃圾回收機制自動清理。\n- 使用`new WeakSet()` 來生成實例。\n\n```js\nconst weakSet = new WeakSet();\nlet obj = { key: \"value\" };\nweakSet.add(obj);\nconsole.log(weakSet.has(obj)); // true\nobj = null; // 解除對 obj 的引用，該物件會被垃圾回收\n```\n\n### 總結\n\n| 差異           | `Map`/`Set`                       | `WeakMap`/`WeakSet`                                       |\n| -------------- | --------------------------------- | --------------------------------------------------------- |\n| key 的型別     | `Map`: 任意型別 `Set`: 任意型別   | `WeakMap`: 物件或 Symbol 作為 key `WeakSet`: 物件作為元素 |\n| 記憶體管理機制 | 強引用，手動管理記憶體            | 弱引用，不再被引用時自動回收                              |\n| 是否可列舉     | 可以列舉，keys(), values() 等方法 | 不可以列舉，無法迭代或獲取所有鍵或值                      |\n| `size` 屬性    | 有                                | 沒有，因為會受到垃圾回收機制影響                          |\n\n### 參考資料\n\n[Map](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Map)\n[WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\n[Set](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Set)\n[WeakSet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)\n","createdAt":"2025-08-16T08:43:46.855Z","updatedAt":"2025-08-16T08:43:54.829Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":65,"data":{"documentId":"cxps4ltexz9fwom3nucu9tm5","slug":"getelementsbytagname","title":"getElementsByTagName() 手寫實作","date":"2025-08-16T08:43:54.191Z","description":"","content":"\n# getElementsByTagName() 手寫實作\n\n`getElementsByTagName()` 是一個 DOM API，可以用來取得指定標籤名稱的 DOM 元素，並且會回傳一個 HTMLCollection 物件。\n\n這裡會在不使用 `document.querySelectorAll()`的情況下 手寫 `Element.getElementsByTagName()` 方法\n\n## 輸入參數\n\n- 一個 element 作為起始搜尋的根節點。\n- 一個 tag 字串。\n\n## 功能需求\n\n- 搜尋 element 的所有後代（不包含自身）是否包含指定的 tag 名稱。\n- 如果節點的 tag 包含了所有指定的 tag 名稱，就將其加入結果陣列中。\n- 最終返回一個陣列（`Array<Element>`），而非類陣列（`HTMLCollection`）。\n\n## 範例\n\n```js\nconst doc = new DOMParser().parseFromString(\n  `<div id=\"foo\">\n    <span>Span</span>\n    <p>Paragraph</p>\n    <div id=\"bar\">Div</div>\n  </div>`,\n  \"text/html\",\n);\n\ngetElementsByTagName(doc.body, \"div\");\n// [div#foo, div#bar]\n```\n\n## 實作思路：\n\n由於 DOM 是樹狀結構，透過 **遞迴** 進行可以方便地遍歷所有的子節點及其後代，並將符合條件的節點加入陣列中。\n\n```ts\nexport default function getElementsByTagName(\n  element: Element,\n  tagNameParam: string,\n): Array<Element> {\n  //用於存放符合條件的後代元素\n  const elements: Array<Element> = [];\n\n  //將輸入的 tagNameParam 轉為大寫，因為 Element.tagName 返回的值是大寫（如 DIV）。\n  const tagName = tagNameParam.toUpperCase();\n\n  //使用遞迴的方式，逐一檢查 element 的所有後代節點。\n  function traverse(el: Element) {\n    if (el == null) {\n      return;\n    }\n    //如果目前的節點標籤名稱符合目標，加入陣列\n    if (el.tagName === tagName) {\n      elements.push(el);\n    }\n\n    // 遍歷目前節點的所有子節點\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  //搜尋後代節點（不包括起始節點），必須從 element.children 開始遍歷。\n  //Element.children 會回傳即時子元素的 HTMLCollection\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n```\n\n## HTMLCollection\n\n`HTMLCollection` 是一種 **動態更新** 的類陣列，當 DOM 結構發生變化時，`HTMLCollection` 的內容會即時反映這些變化。\n\n為什麼不能用`.forEach()`遍歷? 因為 `HTMLCollection` 是一個類陣列，不是真正的陣列，因此不繼承 `Array.prototype` 上的方法（例如 `.forEach`, .`map`, .`filter` 等）。\n","createdAt":"2025-08-16T08:43:45.920Z","updatedAt":"2025-08-16T08:43:54.212Z","publishedAt":"2025-08-16T08:43:54.216Z","locale":null,"author":null}}
{"type":"api::post.post","id":72,"data":{"documentId":"vasdn9zuwi0xojqila7spk2q","slug":"cookie-sessionstorage-localstorage","title":"cookie, sessionStorage 和 localStorage 在瀏覽器中的差異","date":"2025-08-16T08:43:54.464Z","description":"","content":"\n# cookie, sessionStorage 和 localStorage 在瀏覽器中的差異\n\n以下幾點為 cookie, sessionStorage 和 localStorage 主要的差異：\n\n## 生命週期長短\n\n- cookie：cookie 的預設行為是在瀏覽器關閉後會消失，但是可以自行透過 Expires 標明失效時間、 Max-Age 標明有效時間長度，讓 cookie 在瀏覽器關閉後能依然存在。\n- sessionStorage：瀏覽器關閉後自動清除，甚至在相同網域的不同標籤頁之間也無法共享。\n- localStorage：如果沒有手動去清除的話，會永久保存在瀏覽器。\n\n## 資料儲存的大小\n\n- cookie：4KB 左右。\n- sessionStorage：依據不同瀏覽器 5MB~10MB。\n- localStorage：依據不同瀏覽器 5MB~10MB。\n\n## 使用的方式\n\n- cookie：cookie 會隨著 http 請求打到伺服器，會在第一次 client 發送請求後，sever 會在 response 的 header 加入`Set-Cookie` 還有 response 加入 cookie，當 client 收到後會存在瀏覽器本地。\n\n- sessionStorage：使用 key-value 的形式儲存在瀏覽器本地。\n- localStorage：使用 key-value 的形式儲存在瀏覽器本地。\n\n## 應用場景\n\n- cookie： 適合用來用戶驗證、追蹤會話。\n- sessionStorage： 因為生命週期較短，適合短期且臨時的資料儲存，例如：表單的資料、購物車。\n- localStorage： 生命週期很長，適合存需要長期保存的資料例如：主題選擇、語系設定。\n\n---\n\n## 實例練習\n\n[135. localStorage with expiration](https://bigfrontend.dev/problem/localStorage-with-expiration)\nlocalStorage is a simple and handy client-side storage, but you should avoid using it because it is synchronous.\n\nAlso Safari's ITP actually deletes client-side script-writable storage after 7 days of Safari use without interacting on your website, and localStorage is included.\n\nUnlike Cookie, localStorage doesn't expire.\n\nIn this problem, please create a localStorage wrapper with expiration support\n\n```js\nmyLocalStorage.setItem(\"bfe\", \"dev\", 1000);\nmyLocalStorage.getItem(\"bfe\");\n// 'dev'\n```\n\nafter 1 second:\n\n```js\nmyLocalStorage.getItem(\"bfe\");\n// null\n```\n\n## 解題\n\n參考 [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)\n\n```js\nwindow.myLocalStorage = {\n  getItem(key) {\n    const data = window.localStorage.getItem(key);\n    if (!data) return null; // key 不存在\n    const parsedData = JSON.parse(data);\n    // 檢查 expiry ，沒有設置 expiry 或尚未過期，則返回 value\n    if (!parsedData.expiry || parsedData.expiry > Date.now()) {\n      return parsedData.value;\n    } else {\n      // 如果過期了，移除該項目並返回 null\n      window.localStorage.removeItem(key);\n      return null;\n    }\n  },\n\n  setItem(key, value, maxAge) {\n    window.localStorage.setItem(key, value);\n\n    if (maxAge === 0) {\n      //因為這題必須要在 LocalStorage 實現失效時間的功能，因此如果 maxAge 失效時間是0的話就代表就是失效了，直接移除該項目\n      window.localStorage.removeItem(key);\n    }\n    //計算出過期的時間\n    const expiry = maxAge > 0 ? Date.now() + maxAge : null;\n    //將過期的時間跟資料儲存\n    const data = {\n      value: value,\n      expiry: expiry,\n    };\n    // 儲存 JSON 字串到 localStorage\n    window.localStorage.setItem(key, JSON.stringify(data));\n  },\n\n  removeItem(key) {\n    window.localStorage.removeItem(key);\n  },\n\n  clear() {\n    window.localStorage.clear();\n  },\n};\n```\n","createdAt":"2025-08-16T08:43:46.426Z","updatedAt":"2025-08-16T08:43:54.493Z","publishedAt":"2025-08-16T08:43:54.499Z","locale":null,"author":null}}
{"type":"api::post.post","id":78,"data":{"documentId":"oo4w02kxmsk2xpyrwcd6wgy6","slug":"map-set-weakmap-weakset","title":"Map/Set 和 WeakMap/WeakSet 之間的差別是什麼？","date":"2025-08-16T08:43:54.794Z","description":"","content":"\n# Map/Set 和 WeakMap/WeakSet 之間的差別是什麼？\n\n## `Map`和`WeakMap`\n\n### `Map`\n\n- 結構：`Map` 是一個以 key-value 的形式儲存資料，類似物件的資料結構，key 可以是任何型別，而 value 也可以是任何型別。\n- 使用`new Map()` 來生成實例。\n- 記憶體管理： keys values 不會受到 Javascript 垃圾回收機制的影響。\n- 使用場景: 當需要儲存 key-value 的資料時，並且希望 key 保留在記憶體中直到手動刪除時。\n\n```js\nconst map = new Map();\nmap.set(\"name\", \"Ashley\");\nconsole.log(map.get(\"name\")); // 'Ashley'\nmap.delete(\"name\");\nconsole.log(map.size); // 0\n```\n\n### `WeakMap`\n\n- 結構：`WeakMap` 的 key 只能是物件和 Symbol，value 可以是任何型別。\n- 記憶體管理：`WeakMap` 的 key 是弱引用(weak reference)，當 key 不再被引用時，`WeakMap` 會被垃圾回收機制自動回收這個 key-value 對象。\n- 使用`new WeakMap()` 來生成實例。\n- 使用場景: caching data，適合用於需要暫存物件，當 key 不再被引用時，自動回收資料。\n\n```js\nconst weakMap = new WeakMap();\nlet obj = {};\nweakMap.set(obj, \"value\");\nconsole.log(weakMap.get(obj)); // 'value'\nobj = null; // 解除對 obj 的引用，該 key-value 對象會被自動回收\n```\n\n## `Set`和`WeakSet`\n\n### `Set`\n\n- 結構：`Set` 是一個儲存唯一值的集合，類似陣列，但是不允許重複的值。\n- 記憶體管理：值不會受到 Javascript 垃圾回收機制的影響。\n- 使用場景: 當需要管理唯一值的集合，特別是需要剔除重複值時。\n\n```js\nconst set = new Set([1, 1, 1, 2, 2, 3, 4, 5]);\nconsole.log(set); // Set { 1, 2, 3, 4, 5 }\nset.add(6);\nconsole.log(set.has(6)); // true\nset.delete(6);\nconsole.log(set.has(6)); // false\nconsole.log(set.size); // 5\n```\n\n#### `WeakSet`\n\n- 結構：`WeakSet` 的元素只能是物件，並且是弱引用(weak reference)。\n- 記憶體管理：當存入的物件不再被引用時，會被垃圾回收機制自動清理。\n- 使用`new WeakSet()` 來生成實例。\n\n```js\nconst weakSet = new WeakSet();\nlet obj = { key: \"value\" };\nweakSet.add(obj);\nconsole.log(weakSet.has(obj)); // true\nobj = null; // 解除對 obj 的引用，該物件會被垃圾回收\n```\n\n### 總結\n\n| 差異           | `Map`/`Set`                       | `WeakMap`/`WeakSet`                                       |\n| -------------- | --------------------------------- | --------------------------------------------------------- |\n| key 的型別     | `Map`: 任意型別 `Set`: 任意型別   | `WeakMap`: 物件或 Symbol 作為 key `WeakSet`: 物件作為元素 |\n| 記憶體管理機制 | 強引用，手動管理記憶體            | 弱引用，不再被引用時自動回收                              |\n| 是否可列舉     | 可以列舉，keys(), values() 等方法 | 不可以列舉，無法迭代或獲取所有鍵或值                      |\n| `size` 屬性    | 有                                | 沒有，因為會受到垃圾回收機制影響                          |\n\n### 參考資料\n\n[Map](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Map)\n[WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\n[Set](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Set)\n[WeakSet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)\n","createdAt":"2025-08-16T08:43:46.855Z","updatedAt":"2025-08-16T08:43:54.829Z","publishedAt":"2025-08-16T08:43:54.833Z","locale":null,"author":null}}
{"type":"api::post.post","id":79,"data":{"documentId":"a006suoz4u7nfud7zg1taf5m","slug":"synchronous-asynchronous","title":"synchronous 同步與 asynchronous 非同步","date":"2025-08-16T08:43:54.848Z","description":"同步 synchronous 與非同步 asynchronous 同步 synchronous JavaScript 中同步的概念是指程式碼的執行會依照順序進行，必須等到前一個任務完成後才能執行下一個任務。但是由於 JavaScript 是單一執行緒的程式語言，運行同步程如果其任務執行時間過久很可能會阻塞，在瀏覽器中會出現空白或凍結的情況，這會導致使用者體驗不佳。 這個例子說明了 for 迴圈是一個耗時的同步任務。在執行該迴圈時，瀏覽器將被阻塞，直到任務完成後才會執行 console.log('End')。","content":"\n# 同步 synchronous 與非同步 asynchronous\n\n## 同步 synchronous\n\nJavaScript 中同步的概念是指程式碼的執行會依照順序進行，必須等到前一個任務完成後才能執行下一個任務。但是由於 JavaScript 是單一執行緒的程式語言，運行同步程如果其任務執行時間過久很可能會阻塞，在瀏覽器中會出現空白或凍結的情況，這會導致使用者體驗不佳。\n\n```js\nconsole.log(\"Start\");\nfor (let i = 0; i < 1000000000; i++) {} // 模擬一個耗時的同步任務\nconsole.log(\"End\");\n```\n\n這個例子說明了 `for` 迴圈是一個耗時的同步任務。在執行該迴圈時，瀏覽器將被阻塞，直到任務完成後才會執行 `console.log('End')`。\n\n## 非同步 asynchronous\n\n非同步的程式碼不會阻塞主執行緒，當程式碼遇到非同步任務時，會先將任務交到交給瀏覽器或 Node.js 的背景進行處理，並繼續執行後續的程式碼。而不是等待非同步任務完成。當非同步任務完成後，會通過 `callback` 或 `Promise` 或 `async/await` 來通知 JavaScript 主執行緒，然後再執行相應的回應操作。這有助於提高程式碼的效率和效能。\n\n```js\nconsole.log(\"Start\");\nsetTimeout(() => {\n  console.log(\"Async Task Complete\");\n}, 1000); // 模擬一個 1 秒後完成的非同步任務\nconsole.log(\"End\");\n```\n\n這個例子會先印出 `Start`、`End`，然後再印出 `Async Task Complete`。這是因為 `setTimeout` 是一個非同步任務，當遇到 `setTimeout` 時，會將任務交給瀏覽器背景進行處理，並繼續執行後續的程式碼。\n\n## 總結\n\n| 特性差異 | 同步 (Synchronous)         | 非同步 (Asynchronous)                                             |\n| -------- | -------------------------- | ----------------------------------------------------------------- |\n| 執行順序 | 按照程式碼的順序，逐行執行 | 可以在執行其他程式碼的同時處理背景中的非同步任務                  |\n| 阻塞     | 任務執行時會阻塞後續程式碼 | 任務執行時不會阻塞後續程式碼                                      |\n| 應用場景 | 資料處理、簡單邏輯運算     | 呼叫 http request、計時器、事件監聽器、檔案讀取、資料庫查詢等     |\n| 實現方式 | 順序執行                   | 非同步函式、`Promise`、`async/await`、事件監聽器、`setTimeout` 等 |\n","createdAt":"2025-08-16T08:43:54.912Z","updatedAt":"2025-08-16T10:25:14.911Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":81,"data":{"documentId":"lud2kvvo4v4gjtjyyl0r1ac6","slug":"anonymous-function","title":"Anonymous function 匿名函式有哪些應用場景?","date":"2025-08-16T08:43:54.929Z","description":"匿名函式有哪些應用場景？ 匿名函式 anonymous function 是指在 JavaScript 中沒有名稱的函式，通常用於一次性的操作或者作為參數傳遞給其他函式，此外，匿名函式不會在編譯階段被提升到作用域的上方（這是函式表達式的特性），因此它們在程式碼執行時才會被解析。匿名函式有許多應用場景，以下是一些常見的例子： 回調函式 Callback function 匿名函式常用於作為回調函式，當某個操作完成後被執行。 這個例子中，箭頭函式 () => {} 就是一個匿名函式，用作 setTimeout 的回調函式，當計時器 1000 ms 後，會執行這個匿名函式。","content":"\n# 匿名函式有哪些應用場景？\n\n匿名函式 anonymous function 是指在 JavaScript 中沒有名稱的函式，通常用於一次性的操作或者作為參數傳遞給其他函式，此外，匿名函式不會在編譯階段被提升到作用域的上方（這是函式表達式的特性），因此它們在程式碼執行時才會被解析。匿名函式有許多應用場景，以下是一些常見的例子：\n\n## 回調函式 Callback function\n\n匿名函式常用於作為回調函式，當某個操作完成後被執行。\n\n```js\nsetTimeout(() => {\n  console.log(\"Task Complete\");\n}, 1000);\n```\n\n這個例子中，箭頭函式 `() => {}` 就是一個匿名函式，用作 `setTimeout` 的回調函式，當計時器 1000 ms 後，會執行這個匿名函式。\n\n## 立即函式 IIFE\n\n立即函式是在定義後就會立刻執行的函式，通常用於創建一個私有作用域，避免變數污染全局作用域。匿名函式在這裡用於定義立即函式。\n\n```js\n{function(){(\n    var a = 1;\n    console.log(a)//1\n)}\n}();\nconsole.log(a)//a is not defined\n```\n\n## 高階函式 Higher-order function\n\n高階函式是指接受一個或多個函式作為參數，或者返回函式。匿名函式常用於作為這類函式的回調。\n例如：`map`、`filter`、`reduce`、`sort` 等方法都接受函式作為參數：\n\n### map\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst squared = numbers.map((num) => num * num);\nconsole.log(squared); // [1, 4, 9, 16, 25]\n```\n\n### filter\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst even = numbers.filter((num) => num % 2 === 0);\nconsole.log(even); // [2, 4]\n```\n\n### reduce\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\nconsole.log(sum); // 15\n```\n\n### sort\n\n```js\nconst numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nconst sorted = numbers.sort((a, b) => a - b);\nconsole.log(sorted); // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n```\n\n## 事件處理 event handler\n\n匿名函式也常用於事件處理器中，這樣可以保持程式碼簡潔，並避免與其他函式名稱產生衝突。\n\n```js\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function () {\n  console.log(\"Button Clicked\");\n});\n```\n\n匿名函式在這裡用作事件處理函式，當按鈕被點擊時，會執行這個匿名函式。\n","createdAt":"2025-08-16T08:43:54.960Z","updatedAt":"2025-08-16T10:25:14.923Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":83,"data":{"documentId":"mfikce30lwe90em7zfya8avi","slug":"debounce-throttle","title":"手寫 debounce 防抖函式和 throttle 節流函式","date":"2025-08-16T08:43:54.981Z","description":"手寫 debounce 防抖函式和 throttle 節流函式 防抖和節流函式是前端常見的效能優化的技巧，透過這兩個函式可以有效的減少函式被觸發的次數，達到效能優化的目的。 debounce 防抖函式 防抖函式的作用是在一段時間內只執行一次函式。當多次觸發事件時，防抖函式會在最後一次事件觸發後的一段時間內執行一次函式。如果在這段時間內再次觸發事件，計時器會重新計時。 應用場景 - 輸入框搜尋建議：當使用者在搜尋框中輸入時，如果每次按鍵都立即發送請求，這將導致過多的請求。在使用防抖函式後，只有使用者停止輸入一段時間後才會發送搜尋請求。","content":"\n# 手寫 debounce 防抖函式和 throttle 節流函式\n\n防抖和節流函式是前端常見的效能優化的技巧，透過這兩個函式可以有效的減少函式被觸發的次數，達到效能優化的目的。\n\n# debounce 防抖函式\n\n防抖函式的作用是在一段時間內只執行一次函式。當多次觸發事件時，防抖函式會在最後一次事件觸發後的一段時間內執行一次函式。如果在這段時間內再次觸發事件，計時器會重新計時。\n\n## 應用場景\n\n- 輸入框搜尋建議：當使用者在搜尋框中輸入時，如果每次按鍵都立即發送請求，這將導致過多的請求。在使用防抖函式後，只有使用者停止輸入一段時間後才會發送搜尋請求。\n- 按鈕防連點：當使用者連續點擊按鈕時，如果沒有防抖函式，每次點擊都會觸發事件。使用防抖函式後，只有最後一次點擊會觸發事件。\n- 調整瀏覽器大小事件：如果每次窗口大小調整時都進行重新渲染，會造成性能浪費。可以使用防抖讓瀏覽器大小調整完畢後才進行重繪。\n\n## 實例練習\n\n[6. implement basic debounce()](https://bigfrontend.dev/problem/implement-basic-debounce)\n\n```js\n// This is a JavaScript coding problem from BFE.dev\n\n/**\n * @param {(...args: any[]) => any} func\n * @param {number} wait\n * @returns {(...args: any[]) => any}\n */\nfunction debounce(func, wait) {\n  // your code here\n}\n```\n\n## 解題\n\n利用計時器 (setTimeout) 來延遲執行目標函式，當 debounce function 被多次觸發時，會不斷清除舊的 timeoutId 並重新計時，直到停止觸發後才執行 func\n\n```js\n/**\n * @param {(...args: any[]) => any} func 要執行的函式 func\n * @param {number} wait 等待時間 (ms)\n * @returns {(...args: any[]) => any}\n */\n\nfunction debounce(func, wait) {\n  let timeoutId;\n  return function (...args) {\n    // 每一次觸發 debounce function 時會清除之前的 timeoutId\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    // 重新計時，設定新的 timeoutId\n    // 當 wait 時間內沒有再次觸發 debounce function 時，執行 func\n    timeoutId = setTimeout(() => func(...args), wait);\n  };\n}\n```\n\n# throttle 節流函式\n\n節流函式的作用是的作用是在多次觸發事件中，保證函式在固定的時間間隔內只執行一次。當多次觸發事件時，節流函式會在一段時間內執行一次函式 callback。如果在這段時間內再次觸發事件，函式不會被執行，直到這段時間結束。\n\n## 應用場景\n\n- 滾動事件監聽器：當用戶滾動頁面時，可以使用節流控制事件觸發次數，避免高頻率地調用處理函式。\n- 按鈕點擊：限制點擊按鈕的次數，避免用戶短時間內多次點擊造成多次請求或響應。\n\n## 手寫 throttle 節流函式\n\n1. 檢查時間是否到達，如果到達執行函式，否則不執行。\n2. 設定 timer，等待 wait 時間後清除 timer。\n\n```js\n/**\n * @param {(...args:any[]) => any} func 要執行的函式 func\n * @param {number} wait 等待時間 (ms)\n * @returns {(...args:any[]) => any}\n */\nfunction throttle(func, wait) {\n  let timer = null;\n\n  return function (...args) {\n    // 如果 timer 存在，表示還在節流等待期間，不執行函式\n    if (timer) return;\n\n    // 設定 timer，等到 wait 時間結束後執行 callback 並清除 timer\n    timer = setTimeout(() => {\n      timer = null;\n    }, wait);\n\n    // 時間到，執行 callback 函式\n    func.apply(this, args);\n  };\n}\n```\n","createdAt":"2025-08-16T08:43:55.025Z","updatedAt":"2025-08-16T10:25:14.933Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":85,"data":{"documentId":"qdm8hfvgjw7pv43x15ibtboi","slug":"interface-type","title":"Interface 和 Type 的差別","date":"2025-08-16T08:43:55.066Z","description":"Interface 和 Type 的差別 1.TypeScript 編譯器推論結果不同 Type 宣告 Type 時，所使用的名稱代表的是其背後的型別結構 Interface Interface 介面宣告時會使用名稱代表 TypeScript 編譯器推論的結果 2.Type 和 Interface 的擴展性差異 Type Type 較適合靜態、變動性較小的資料結構，並且可以表達任一型別。 雖然 Type 無法擴充，但可以使用交集運算子 & 來合併多個 Type。","content":"\n# Interface 和 Type 的差別\n\n## 1.TypeScript 編譯器推論結果不同\n\n### Type\n\n宣告 `Type` 時，所使用的名稱代表的是其背後的型別結構\n\n```typescript\ntype Person = {\n  name: string;\n  age: number;\n  gender: string;\n};\ntype Employee = Person;\n\n/**\n * TypeScript 編譯器推論結果為：\n * type Employee =\n * {\n *   name: string;\n *   age: number;\n *   gender: string;\n * }\n **/\n```\n\n### Interface\n\nInterface 介面宣告時會使用名稱代表 TypeScript 編譯器推論的結果\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n  gender: string;\n}\ntype Employee = Person; // TypeScript 編譯器推論結果為： type Employee = Person\n```\n\n## 2.Type 和 Interface 的擴展性差異\n\n### Type\n\nType 較適合靜態、變動性較小的資料結構，並且可以表達任一型別。\n\n```typescript\ntype Phone = {\n  brand: string;\n  model: string;\n  price: number;\n};\n```\n\n雖然 Type 無法擴充，但可以使用交集運算子 `&` 來合併多個 Type。\n然而，與 Interface 不同的是，Type 不能進行重新開放（declaration merging），這意味著無法多次聲明一個 Type 來合併屬性。\n\n```typescript\ntype Person = {\n  name: string;\n};\n\ntype Employee = Person & {\n  salary: number;\n};\n```\n\n另外，Type 不僅限於物件也可以用於其他型別的別名，像是聯合型別、函數型別、原始型別等。\n\n```typescript\n// 原始型別別名\n\ntype StringAlias = string;\n\n// 聯合型別\ntype UnionType = string | number;\n\n// 函數型別\ntype FunctionType = (a: number, b: number) => number;\n```\n\n### Interface\n\nInterface 的宣告較為靈活，可以用來描述物件、函式、類別、JSON物件等...，並且可以自由的進行擴充。\n\n```typescript\ninterface Person {\n  name: string;\n}\n\ninterface Person {\n  age: number;\n}\n\n// 合併後的 Person 會包含 name 和 age 屬性\nconst person: Person = {\n  name: \"John\",\n  age: 30,\n};\n```\n\nInterface 支持宣告合併（declaration merging），這表示可以多次宣告同一個 Interface，並且 TypeScript 會將它們合併。\n\n```typescript\ninterface Phone {\n  brand: string;\n  model: string;\n  price: number;\n}\n\ninterface SmartPhone extends Phone {\n  os: string;\n}\n```\n","createdAt":"2025-08-16T08:43:55.129Z","updatedAt":"2025-08-16T10:25:14.944Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":87,"data":{"documentId":"wdqs25ol6zhum5kd88yw6l3d","slug":"01-clamp","title":"01-clamp","date":"2025-08-16T08:43:55.152Z","description":"🔸 題目描述 你正在開發一個處理數值資料的系統。請寫一個名為 clamp 的函式，它需要三個參數： - 一個數值 number - 一個最小值 lower - 一個最大值 upper 此函式應確保輸出的 number 始終落在指定的範圍内，包括最小值和最大值本身。你會如何實作這個 clamp 呢? Tests Solutions","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n你正在開發一個處理數值資料的系統。請寫一個名為 `clamp` 的函式，它需要三個參數：\n\n- 一個數值 `number`\n- 一個最小值 `lower`\n- 一個最大值 `upper`\n\n此函式應確保輸出的 `number` 始終落在指定的範圍内，包括最小值和最大值本身。你會如何實作這個 `clamp` 呢?\n\n```js\n// 在範圍中，返回原值\nclamp(7, 0, 9); // => 7\n\n// 小於 lower，返回 lower\nclamp(-12, -4, 5); // => -4\n\n// 大於 upper，返回 upper\nclamp(18, 3, 9); // => 9\n```\n\n## Tests\n\n```js title=\"test.ts\"\nimport { describe, expect, test } from \"@jest/globals\";\nimport clamp from \"./clamp\";\ndescribe(\"clamp\", () => {\n  test(\"should return the input number when it is within the specified range\", () => {\n    expect(clamp(7, 0, 9)).toBe(7);\n    expect(clamp(3, -5, 5)).toBe(3);\n    expect(clamp(-2, -10, 10)).toBe(-2);\n  });\n\n  test(\"should return the lower bound when the input number is less than the lower bound\", () => {\n    expect(clamp(-5, 0, 9)).toBe(0);\n    expect(clamp(-10, -5, 5)).toBe(-5);\n    expect(clamp(-15, -10, 10)).toBe(-10);\n  });\n\n  test(\"should return the upper bound when the input number is greater than the upper bound\", () => {\n    expect(clamp(10, 0, 9)).toBe(9);\n    expect(clamp(6, -5, 5)).toBe(5);\n    expect(clamp(15, -10, 10)).toBe(10);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```ts title=\"solution1.js\"\n    function clamp(number: number, lower: number, upper: number) {\n    if (number < lower) {\n        return lower;\n    } else if (number > upper) {\n        return upper;\n    } else {\n        return number;\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```ts title=\"solution2.js\"\n    function clamp(number: number, lower: number, upper: number) {\n      return Math.min(upper, Math.max(lower, number));\n    }\n    //使用 Math.max 函數來確保數值不會低於下限，然後使用 Math.min 函數來確保數值不會超過上限\n    ```\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.161Z","updatedAt":"2025-08-16T10:25:14.955Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":89,"data":{"documentId":"sqqyc87jht9z9dux9awal0fs","slug":"02-inrange","title":"02-inRange","date":"2025-08-16T08:43:55.178Z","description":"","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個函式 `inRange` 。此函式接受三個參數：\n\n- `value`：要檢查的數值\n- `start`：範圍的下限 (範圍包含 `start`)，預設為 0\n- `end`：範圍的上限 (範圍不包含 `end`)\n\n在實作時，要同時考量以下條件：\n\n- 預設行為：如果僅提供兩個參數，則第二個參數被視為 `end`，而 `start` 此時預設為 0，這樣會讓使用該函式的人，在正數範圍內能更簡易地使用\n- 負數範圍：如果 `start` 大於 `end`，`inRange` 會交換參數以正確處理負數範圍，確保在正負數都能被處理\n- 輸出：`inRange` 函式輸出會是一個 `Boolean`\n\n```js\ninRange(3, 2, 4); // => true\ninRange(4, 8); // => true\ninRange(4, 2); // => false\ninRange(2, 2); // => false\ninRange(1.2, 2); // => true\n```\n\n## Tests\n\n```js title=\"test.ts\"\nimport { describe, expect, test } from \"@jest/globals\";\nimport inRange from \"./inRange\";\n\ndescribe(\"inRange\", () => {\n  test(\"returns true when value is within the range\", () => {\n    expect(inRange(3, 2, 4)).toBe(true);\n    expect(inRange(4, 8)).toBe(true);\n  });\n\n  test(\"returns false when value is outside the range\", () => {\n    expect(inRange(4, 2)).toBe(false);\n    expect(inRange(2, 2)).toBe(false);\n  });\n\n  test(\"handles negative ranges correctly\", () => {\n    expect(inRange(-3, -2, -4)).toBe(true);\n    expect(inRange(-4, -2)).toBe(false);\n    expect(inRange(-2, -2)).toBe(true);\n    expect(inRange(-1, -2)).toBe(true);\n  });\n\n  test(\"handles decimal values correctly\", () => {\n    expect(inRange(1.2, 2)).toBe(true);\n    expect(inRange(1.2, 0.5, 1)).toBe(false);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```ts title=\"solution1.js\"\n    function inRange(value, start, end = 0) {\n        return value >= Math.min(start, end) && value < Math.max(start, end)\n    }\n    //Math.min(start, end) 會返回 start 和 end 中的最小值。如果 value 大於或等於這個最小值，那麼 value 就不會低於範圍的下限。\n//Math.max(start, end) 會返回 start 和 end 中的最大值。如果 value 小於這個最大值，那麼 value 就不會超過範圍的上限。\nexport default inRange;\n```\n\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```ts title=\"solution2.js\"\n    function inRange(value: number, start: number = 0, end?: number): boolean {\n    // 如果只提供了兩個參數，則將第二個參數視為 `end`，並將 `start` 設為 0\n    if (end === undefined) {\n        end = start;\n        start = 0;\n    }\n\n    // 如果 `start` 大於 `end`，則交換 `start` 和 `end`\n    if (start > end) {\n    [start, end] = [end, start];\n    }\n\n    // 檢查 `value` 是否在範圍內\n    return value >= start && value < end;\n    }\n    export default inRange;\n    ```\n\n</TabItem>\n<TabItem value=\"solution3\" label=\"解法三\">\n  ```ts title=\"solution3.js\"\n    function inRange(value: number, start: number, end = 0): boolean {\n    if (start > end) {\n        if (value >= end && value < start) {\n        return true;\n        }\n    } else if (value >= start && value < end) {\n        return true;\n    }\n    return false;\n    }\n    export default inRange;\n    ```\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.183Z","updatedAt":"2025-08-16T08:43:55.183Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":90,"data":{"documentId":"sqqyc87jht9z9dux9awal0fs","slug":"02-inrange","title":"02-inRange","date":"2025-08-16T08:43:55.178Z","description":"","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個函式 `inRange` 。此函式接受三個參數：\n\n- `value`：要檢查的數值\n- `start`：範圍的下限 (範圍包含 `start`)，預設為 0\n- `end`：範圍的上限 (範圍不包含 `end`)\n\n在實作時，要同時考量以下條件：\n\n- 預設行為：如果僅提供兩個參數，則第二個參數被視為 `end`，而 `start` 此時預設為 0，這樣會讓使用該函式的人，在正數範圍內能更簡易地使用\n- 負數範圍：如果 `start` 大於 `end`，`inRange` 會交換參數以正確處理負數範圍，確保在正負數都能被處理\n- 輸出：`inRange` 函式輸出會是一個 `Boolean`\n\n```js\ninRange(3, 2, 4); // => true\ninRange(4, 8); // => true\ninRange(4, 2); // => false\ninRange(2, 2); // => false\ninRange(1.2, 2); // => true\n```\n\n## Tests\n\n```js title=\"test.ts\"\nimport { describe, expect, test } from \"@jest/globals\";\nimport inRange from \"./inRange\";\n\ndescribe(\"inRange\", () => {\n  test(\"returns true when value is within the range\", () => {\n    expect(inRange(3, 2, 4)).toBe(true);\n    expect(inRange(4, 8)).toBe(true);\n  });\n\n  test(\"returns false when value is outside the range\", () => {\n    expect(inRange(4, 2)).toBe(false);\n    expect(inRange(2, 2)).toBe(false);\n  });\n\n  test(\"handles negative ranges correctly\", () => {\n    expect(inRange(-3, -2, -4)).toBe(true);\n    expect(inRange(-4, -2)).toBe(false);\n    expect(inRange(-2, -2)).toBe(true);\n    expect(inRange(-1, -2)).toBe(true);\n  });\n\n  test(\"handles decimal values correctly\", () => {\n    expect(inRange(1.2, 2)).toBe(true);\n    expect(inRange(1.2, 0.5, 1)).toBe(false);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```ts title=\"solution1.js\"\n    function inRange(value, start, end = 0) {\n        return value >= Math.min(start, end) && value < Math.max(start, end)\n    }\n    //Math.min(start, end) 會返回 start 和 end 中的最小值。如果 value 大於或等於這個最小值，那麼 value 就不會低於範圍的下限。\n//Math.max(start, end) 會返回 start 和 end 中的最大值。如果 value 小於這個最大值，那麼 value 就不會超過範圍的上限。\nexport default inRange;\n```\n\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```ts title=\"solution2.js\"\n    function inRange(value: number, start: number = 0, end?: number): boolean {\n    // 如果只提供了兩個參數，則將第二個參數視為 `end`，並將 `start` 設為 0\n    if (end === undefined) {\n        end = start;\n        start = 0;\n    }\n\n    // 如果 `start` 大於 `end`，則交換 `start` 和 `end`\n    if (start > end) {\n    [start, end] = [end, start];\n    }\n\n    // 檢查 `value` 是否在範圍內\n    return value >= start && value < end;\n    }\n    export default inRange;\n    ```\n\n</TabItem>\n<TabItem value=\"solution3\" label=\"解法三\">\n  ```ts title=\"solution3.js\"\n    function inRange(value: number, start: number, end = 0): boolean {\n    if (start > end) {\n        if (value >= end && value < start) {\n        return true;\n        }\n    } else if (value >= start && value < end) {\n        return true;\n    }\n    return false;\n    }\n    export default inRange;\n    ```\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.183Z","updatedAt":"2025-08-16T08:43:55.183Z","publishedAt":"2025-08-16T08:43:55.184Z","locale":null,"author":null}}
{"type":"api::post.post","id":91,"data":{"documentId":"pp1b6qsz8rdm68hbg3sj46wx","slug":"03-compact","title":"03-compact","date":"2025-08-16T08:43:55.196Z","description":"🔸 題目描述 請實作一個 compact 效用函式。 compact 能將輸入的陣列中的 false、null、0、空字串、undefined 和 NaN 都去除，並輸出一個新的陣列。請實作此 compact 函式。 Tests Solutions `","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個 `compact` 效用函式。 `compact` 能將輸入的陣列中的 `false`、`null`、0、空字串、`undefined` 和 NaN 都去除，並輸出一個新的陣列。請實作此 `compact` 函式。\n\n```js\n// 範例一\ncompact([0, 1, false, 2, \"\", 3, \"hello\"]);\n// => [1, 2, 3, 'hello']\n\n// 範例二\ncompact([null, undefined, NaN, \" \"]);\n// =>[' ']\n\n// 範例三\ncompact([{ name: \"Alice\" }, null, { age: 30 }, undefined]);\n// =>[{ name: 'Alice' }, { age: 30 }]\n```\n\n## Tests\n\n```js title=\"test.ts\"\nimport { describe, expect, test } from \"@jest/globals\";\nimport compact from \"./compact\";\n\ndescribe(\"compact\", () => {\n  test(\"removes all falsy values from the array\", () => {\n    expect(compact([0, 1, false, 2, \"\", 3, \"hello\"])).toEqual([\n      1,\n      2,\n      3,\n      \"hello\",\n    ]);\n    expect(compact([null, undefined, NaN, \" \"])).toEqual([\" \"]);\n    expect(compact([{ name: \"Alice\" }, null, { age: 30 }, undefined])).toEqual([\n      { name: \"Alice\" },\n      { age: 30 },\n    ]);\n  });\n\n  test(\"does not remove non-falsy values\", () => {\n    expect(compact([1, 2, 3])).toEqual([1, 2, 3]);\n    expect(compact([\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n    expect(compact([{ name: \"Alice\" }, { age: 30 }])).toEqual([\n      { name: \"Alice\" },\n      { age: 30 },\n    ]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```ts title=\"solution1.ts\"\n    const compact = <T>(arr: T[]): T[] => {\n        return arr.filter(Boolean);\n        //false、null、0、空字串、undefined 和 NaN 都是 falsy value\n    };\n    export default compact;\n    ````\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```ts title=\"solution2.ts\"\n    function compact(array: T[]) : T[] {\n    const result = []\n    for (const value of array) {\n        if (value) {\n        result.push(value)\n        }\n    }\n    return result\n    }\n    export default compact;\n    ```\n    </TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.201Z","updatedAt":"2025-08-16T10:25:14.967Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":93,"data":{"documentId":"axz5mzycre96dx8vatmgjx3h","slug":"04-difference","title":"04-difference","date":"2025-08-16T08:43:55.215Z","description":"🔸 題目描述 請實作一個名為 difference 的函式，該函式接收兩個陣列作為參數。函式的功能是回傳只在第一個陣列中存在、在第二個陣列中不存在的元素，並且避免對重複值進行多餘的操作。 Tests Solutions `","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個名為 `difference` 的函式，該函式接收兩個陣列作為參數。函式的功能是回傳只在第一個陣列中存在、在第二個陣列中不存在的元素，並且避免對重複值進行多餘的操作。\n\n```js\ndifference([], []); // []\ndifference([1, 1, 2, 3], [2, 3]); // [1, 1]\ndifference([1, 2, 3], [1, 2, 3, 4]); // []\ndifference([4, 3, 2, 1], [1, 2, 3]); // [4]\n```\n\n## Tests\n\n```js\nimport { describe, expect, test } from \"@jest/globals\";\nimport difference from \"./difference\";\n\ndescribe(\"difference\", () => {\n  test(\"returns elements only present in the first array\", () => {\n    expect(difference([], [])).toEqual([]);\n    expect(difference([1, 1, 2, 3], [2, 3])).toEqual([1, 1]);\n    expect(difference([1, 2, 3], [1, 2, 3, 4])).toEqual([]);\n    expect(difference([4, 3, 2, 1], [1, 2, 3])).toEqual([4]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js\n    function difference(array: any[], values: any[]): any[] {\n        const result = [];\n        for (const element of array) {\n            if (!values.includes(element)) {\n                result.push(element);\n            }\n        }\n        return result;\n    }\n    ````\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js\n      function difference(array: any[], values: any[]) {\n        return array.filter((item: any) => !values.includes(item));\n      }\n    ```\n    </TabItem>\n\n  <TabItem value=\"solution3\" label=\"解法三\">\n    ```js\n      function difference(array: any[], values: any[]): any[] {\n        const valuesSet = new Set(values);\n        //將 values 轉換為一個 Set。Set 是一種數據結構，它存儲的元素都是唯一的，並且 Set 提供了一個 has 方法，可以用來快速檢查一個元素是否存在於 Set 中。\n        return array.filter((value) => !valuesSet.has(value));\n        //由於 Set.has 方法的時間複雜度是 O(1)，適合處理非常大的 values 陣列\n        }\n    ```\n    </TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.219Z","updatedAt":"2025-08-16T10:25:14.978Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":95,"data":{"documentId":"k3ud7x8jpz1ue26uz9zg33sb","slug":"05-dropwhile","title":"05-dropWhile","date":"2025-08-16T08:43:55.229Z","description":"","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個 `dropWhile` 函式。此函式接受兩個參數，第一個是參數是一個陣列，它可以是任何類型的陣列；第二個是一個 predicate 函式，會接受陣列中的元素，如果返回為真，則表示該元素應該被丟棄，直到返回的不為真則停止。\n\n`dropWhile` 會回傳一個新的陣列，且不應改動到原始陣列。回傳的陣列從原始陣列的第一個不滿足 predicate 條件的元素開始，直到陣列中的最後一個元素，若每個元素皆滿足 predicate 函式，則回傳空陣列。\n\n```js\n// 範例一\ndropWhile([1, 2, 3, 4, 5, 6], (value) => value < 4);\n// => [4, 5, 6]\n\n// 範例二\ndropWhile([0, 1, 2], (value) => value < 5);\n// => []\n\n// 範例三\ndropWhile([0, 6, 1, 2], (value) => value < 5);\n// => [6, 1, 2]\n```\n\n## Tests\n\n```js\nimport { describe, expect, test } from \"@jest/globals\";\nimport dropWhile from \"./dropWhile\";\n\ndescribe(\"dropWhile\", () => {\n  test(\"drops elements while predicate is true\", () => {\n    const result = dropWhile([1, 2, 3, 4, 5, 6], (value) => value < 4);\n    expect(result).toEqual([4, 5, 6]);\n  });\n\n  test(\"returns empty array if all elements satisfy the predicate\", () => {\n    const result = dropWhile([0, 1, 2], (value) => value < 5);\n    expect(result).toEqual([]);\n  });\n\n  test(\"stops dropping when predicate is false\", () => {\n    const result = dropWhile([0, 6, 1, 2], (value) => value < 5);\n    expect(result).toEqual([6, 1, 2]);\n  });\n\n  test(\"does not mutate the original array\", () => {\n    const original = [1, 2, 3, 4, 5, 6];\n    const copy = [...original];\n    dropWhile(original, (value) => value < 4);\n    expect(original).toEqual(copy);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js\n    function dropWhile(array: any[], predicate: (value: any) => boolean): any[] {   \n        //findIndex() 方法返回符合條件的第一個元素的索引，如果沒有找到符合條件的元素，則返回 -1\n        const dropIndex = array.findIndex((value) => !predicate(value));\n        \n        //slice 方法從該索引開始創建一個新的陣列\n        return dropIndex === -1 ? [] : array.slice(dropIndex);\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js\n      function dropWhile(array, predicate) {\n         //追蹤當前正在檢查的元素的索引\n        let index = 0;\n\n        //這個 while 迴圈會持續執行，直到已經檢查了所有的元素或者找到了第一個不滿足條件的元素）\n        while (index < array.length && predicate(array[index], index, array)) {\n            index++;\n        }\n\n        return array.slice(index);\n    }\n    ```\n\n</TabItem>\n\n  <TabItem value=\"solution3\" label=\"解法三\">\n    ```js\n      function dropWhile(array, predicate) {\n        //追蹤已經丟棄的元素的數量\n        let droppedCount = 0;\n\n        for (let i = 0; i < array.length; i++) {\n            if (!predicate(array[i], i, array)) {\n            //一旦找到了第一個不滿足 predicate 函數的元素，迴圈就會停止，不會再檢查後面的元素\n            break;\n            }\n            droppedCount++;\n        }\n\n        return array.slice(droppedCount);\n    }\n    ```\n    </TabItem>\n\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.235Z","updatedAt":"2025-08-16T08:43:55.235Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":96,"data":{"documentId":"k3ud7x8jpz1ue26uz9zg33sb","slug":"05-dropwhile","title":"05-dropWhile","date":"2025-08-16T08:43:55.229Z","description":"","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個 `dropWhile` 函式。此函式接受兩個參數，第一個是參數是一個陣列，它可以是任何類型的陣列；第二個是一個 predicate 函式，會接受陣列中的元素，如果返回為真，則表示該元素應該被丟棄，直到返回的不為真則停止。\n\n`dropWhile` 會回傳一個新的陣列，且不應改動到原始陣列。回傳的陣列從原始陣列的第一個不滿足 predicate 條件的元素開始，直到陣列中的最後一個元素，若每個元素皆滿足 predicate 函式，則回傳空陣列。\n\n```js\n// 範例一\ndropWhile([1, 2, 3, 4, 5, 6], (value) => value < 4);\n// => [4, 5, 6]\n\n// 範例二\ndropWhile([0, 1, 2], (value) => value < 5);\n// => []\n\n// 範例三\ndropWhile([0, 6, 1, 2], (value) => value < 5);\n// => [6, 1, 2]\n```\n\n## Tests\n\n```js\nimport { describe, expect, test } from \"@jest/globals\";\nimport dropWhile from \"./dropWhile\";\n\ndescribe(\"dropWhile\", () => {\n  test(\"drops elements while predicate is true\", () => {\n    const result = dropWhile([1, 2, 3, 4, 5, 6], (value) => value < 4);\n    expect(result).toEqual([4, 5, 6]);\n  });\n\n  test(\"returns empty array if all elements satisfy the predicate\", () => {\n    const result = dropWhile([0, 1, 2], (value) => value < 5);\n    expect(result).toEqual([]);\n  });\n\n  test(\"stops dropping when predicate is false\", () => {\n    const result = dropWhile([0, 6, 1, 2], (value) => value < 5);\n    expect(result).toEqual([6, 1, 2]);\n  });\n\n  test(\"does not mutate the original array\", () => {\n    const original = [1, 2, 3, 4, 5, 6];\n    const copy = [...original];\n    dropWhile(original, (value) => value < 4);\n    expect(original).toEqual(copy);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js\n    function dropWhile(array: any[], predicate: (value: any) => boolean): any[] {   \n        //findIndex() 方法返回符合條件的第一個元素的索引，如果沒有找到符合條件的元素，則返回 -1\n        const dropIndex = array.findIndex((value) => !predicate(value));\n        \n        //slice 方法從該索引開始創建一個新的陣列\n        return dropIndex === -1 ? [] : array.slice(dropIndex);\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js\n      function dropWhile(array, predicate) {\n         //追蹤當前正在檢查的元素的索引\n        let index = 0;\n\n        //這個 while 迴圈會持續執行，直到已經檢查了所有的元素或者找到了第一個不滿足條件的元素）\n        while (index < array.length && predicate(array[index], index, array)) {\n            index++;\n        }\n\n        return array.slice(index);\n    }\n    ```\n\n</TabItem>\n\n  <TabItem value=\"solution3\" label=\"解法三\">\n    ```js\n      function dropWhile(array, predicate) {\n        //追蹤已經丟棄的元素的數量\n        let droppedCount = 0;\n\n        for (let i = 0; i < array.length; i++) {\n            if (!predicate(array[i], i, array)) {\n            //一旦找到了第一個不滿足 predicate 函數的元素，迴圈就會停止，不會再檢查後面的元素\n            break;\n            }\n            droppedCount++;\n        }\n\n        return array.slice(droppedCount);\n    }\n    ```\n    </TabItem>\n\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.235Z","updatedAt":"2025-08-16T08:43:55.235Z","publishedAt":"2025-08-16T08:43:55.237Z","locale":null,"author":null}}
{"type":"api::post.post","id":97,"data":{"documentId":"chef3j5sqlii2y631bxrf2bi","slug":"06-droprightwhile","title":"06-dropRightWhile","date":"2025-08-16T08:43:55.245Z","description":"","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個名為 `dropRightWhile` 的函式，該函式接收兩個參數。第一個參數是一個陣列；第二個參數是一個 predicate 函式，用於指定條件。\n\n`dropRightWhile` 函式會從陣列的末端開始遍歷，移除符合指定條件的元素，直到遇到不符合條件的元素為止。然後，它會回傳剩餘的元素所組成的新陣列，同時確保原始陣列保持不變。\n\n```js\n// 範例一\ndropRightWhile(\n  [\"hello\", \"world\", \"today\", \"isGood\"],\n  (value) => value.length > 5,\n);\n// => ['hello', 'world', 'today']\n// 範例二\ndropRightWhile(\n  [\n    { name: \"Alice\", age: 25 },\n    { name: \"Charlie\", age: 20 },\n    { name: \"Bob\", age: 30 },\n  ],\n  (obj) => obj.age > 25,\n);\n// => [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 20 }]\n\n// 範例三\ndropRightWhile([10, 20, 30, 40, 50, 10], (value) => value !== 10);\n// => [10, 20, 30, 40, 50, 10]\n\n// 範例四\ndropRightWhile([1], (value) => value > 0);\n// => []\n```\n\n## Tests\n\n```js\nimport { describe, expect, it } from \"@jest/globals\";\nimport dropRightWhile from \"./dropRightWhile\";\n\ndescribe(\"dropRightWhile\", () => {\n  it(\"should drop elements from the end of the array until the predicate returns false\", () => {\n    const result = dropRightWhile(\n      [\"hello\", \"world\", \"today\", \"isGood\"],\n      (value) => value.length > 5,\n    );\n    expect(result).toEqual([\"hello\", \"world\", \"today\"]);\n  });\n\n  it(\"should drop objects from the end of the array until the predicate returns false\", () => {\n    const result = dropRightWhile(\n      [\n        { name: \"Alice\", age: 25 },\n        { name: \"Charlie\", age: 20 },\n        { name: \"Bob\", age: 30 },\n      ],\n      (obj) => obj.age > 25,\n    );\n    expect(result).toEqual([\n      { name: \"Alice\", age: 25 },\n      { name: \"Charlie\", age: 20 },\n    ]);\n  });\n\n  it(\"should return the original array if no elements need to be dropped\", () => {\n    const result = dropRightWhile(\n      [10, 20, 30, 40, 50, 10],\n      (value) => value !== 10,\n    );\n    expect(result).toEqual([10, 20, 30, 40, 50, 10]);\n  });\n\n  it(\"should return an empty array if all elements need to be dropped\", () => {\n    const result = dropRightWhile([1], (value) => value > 0);\n    expect(result).toEqual([]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js\n    function dropRightWhile(array, predicate) {\n      let index = array.length - 1;\n      while (index >= 0 && predicate(array[index])) {\n        index--;\n      }\n      return array.slice(0, index + 1);\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js\n    function dropRightWhile(array, predicate) {\n      for (let i = array.length - 1; i >= 0; i--) {\n        if (!predicate(array[i], i, array)) {\n          return array.slice(0, i + 1);\n        }\n      }\n      return [];\n    }\n    ```\n\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.253Z","updatedAt":"2025-08-16T08:43:55.253Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":98,"data":{"documentId":"chef3j5sqlii2y631bxrf2bi","slug":"06-droprightwhile","title":"06-dropRightWhile","date":"2025-08-16T08:43:55.245Z","description":"","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個名為 `dropRightWhile` 的函式，該函式接收兩個參數。第一個參數是一個陣列；第二個參數是一個 predicate 函式，用於指定條件。\n\n`dropRightWhile` 函式會從陣列的末端開始遍歷，移除符合指定條件的元素，直到遇到不符合條件的元素為止。然後，它會回傳剩餘的元素所組成的新陣列，同時確保原始陣列保持不變。\n\n```js\n// 範例一\ndropRightWhile(\n  [\"hello\", \"world\", \"today\", \"isGood\"],\n  (value) => value.length > 5,\n);\n// => ['hello', 'world', 'today']\n// 範例二\ndropRightWhile(\n  [\n    { name: \"Alice\", age: 25 },\n    { name: \"Charlie\", age: 20 },\n    { name: \"Bob\", age: 30 },\n  ],\n  (obj) => obj.age > 25,\n);\n// => [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 20 }]\n\n// 範例三\ndropRightWhile([10, 20, 30, 40, 50, 10], (value) => value !== 10);\n// => [10, 20, 30, 40, 50, 10]\n\n// 範例四\ndropRightWhile([1], (value) => value > 0);\n// => []\n```\n\n## Tests\n\n```js\nimport { describe, expect, it } from \"@jest/globals\";\nimport dropRightWhile from \"./dropRightWhile\";\n\ndescribe(\"dropRightWhile\", () => {\n  it(\"should drop elements from the end of the array until the predicate returns false\", () => {\n    const result = dropRightWhile(\n      [\"hello\", \"world\", \"today\", \"isGood\"],\n      (value) => value.length > 5,\n    );\n    expect(result).toEqual([\"hello\", \"world\", \"today\"]);\n  });\n\n  it(\"should drop objects from the end of the array until the predicate returns false\", () => {\n    const result = dropRightWhile(\n      [\n        { name: \"Alice\", age: 25 },\n        { name: \"Charlie\", age: 20 },\n        { name: \"Bob\", age: 30 },\n      ],\n      (obj) => obj.age > 25,\n    );\n    expect(result).toEqual([\n      { name: \"Alice\", age: 25 },\n      { name: \"Charlie\", age: 20 },\n    ]);\n  });\n\n  it(\"should return the original array if no elements need to be dropped\", () => {\n    const result = dropRightWhile(\n      [10, 20, 30, 40, 50, 10],\n      (value) => value !== 10,\n    );\n    expect(result).toEqual([10, 20, 30, 40, 50, 10]);\n  });\n\n  it(\"should return an empty array if all elements need to be dropped\", () => {\n    const result = dropRightWhile([1], (value) => value > 0);\n    expect(result).toEqual([]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js\n    function dropRightWhile(array, predicate) {\n      let index = array.length - 1;\n      while (index >= 0 && predicate(array[index])) {\n        index--;\n      }\n      return array.slice(0, index + 1);\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js\n    function dropRightWhile(array, predicate) {\n      for (let i = array.length - 1; i >= 0; i--) {\n        if (!predicate(array[i], i, array)) {\n          return array.slice(0, i + 1);\n        }\n      }\n      return [];\n    }\n    ```\n\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.253Z","updatedAt":"2025-08-16T08:43:55.253Z","publishedAt":"2025-08-16T08:43:55.255Z","locale":null,"author":null}}
{"type":"api::post.post","id":99,"data":{"documentId":"crmn8r61n2vukk6thtg2er9m","slug":"07-fill","title":"07-fill","date":"2025-08-16T08:43:55.265Z","description":"🔸 題目描述 實作 fill 函式，此函式接收四個參數： - 一個陣列 - 要替換的 value - start 索引 - end 索引 該函式會從 start 到 end 索引 (包含 start 但不包含 end) 來把陣列的元素換成 value 。如果未提供 start 索引，則應預設為 0。如果未提供 end 索引，則剩餘元素會被替換為 value。 Tests Solutions","content":"import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n實作 `fill` 函式，此函式接收四個參數：\n\n- 一個陣列\n- 要替換的 `value`\n- `start` 索引\n- `end` 索引\n\n該函式會從 `start` 到 `end` 索引 (包含 `start` 但不包含 `end`) 來把陣列的元素換成 `value` 。如果未提供 `start` 索引，則應預設為 0。如果未提供 `end` 索引，則剩餘元素會被替換為 `value`。\n\n```js\nfill([1, 2, 3], \"_\");\n// => ['_', '_', '_']\n\nfill([1, 2], \"*\", 2, 3);\n// => [1, 2]\n\nfill([1, 2, 3, 4, 5], \"_\", 1, -1);\n// => [1, '_', '_', '_', 5]\n```\n\n## Tests\n\n```js\nimport { describe, expect, test } from \"@jest/globals\";\nimport fill from \"./fill\"; // adjust this to your actual file path\n\ndescribe(\"fill\", () => {\n  test(\"fills all elements with the provided value when start and end are not provided\", () => {\n    expect(fill([1, 2, 3], \"_\")).toEqual([\"_\", \"_\", \"_\"]);\n  });\n\n  test(\"does not fill any elements when start is equal to or greater than the array length\", () => {\n    expect(fill([1, 2], \"*\", 2, 3)).toEqual([1, 2]);\n  });\n\n  test(\"fills elements from start to end with the provided value\", () => {\n    expect(fill([1, 2, 3, 4, 5], \"_\", 1, -1)).toEqual([1, \"_\", \"_\", \"_\", 5]);\n  });\n\n  test(\"fills remaining elements with the provided value when end is not provided\", () => {\n    expect(fill([1, 2, 3], \"_\", 1)).toEqual([1, \"_\", \"_\"]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js title=\"solution1.js\"\n    function fill(array, value, start = 0, end = array.length) {\n        if (start < 0) {\n            start = array.length + start;\n        }\n\n        if (end < 0) {\n            end = array.length + end;\n        }\n\n        if (end > array.length) {\n            end = array.length;\n        }\n\n        for (let i = start; i < end; i++) {\n            array[i] = value;\n        }\n\n        return array;\n    }\n\nexport default inRange;\n```\n\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js title=\"solution2.js\"\n    function fill(array, value, start = 0, end = array.length) {\n        return array.fill(value, start, end);\n    }\n    ```\n\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.269Z","updatedAt":"2025-08-16T10:25:14.992Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":101,"data":{"documentId":"kt55i6e9be9d53a2zxd3b7xi","slug":"usecontext-mobx","title":"React 中 useContext 跟 React-MobX 的差異","date":"2025-08-16T08:43:55.284Z","description":"","content":"\nimport CodeSandbox from \"../../src/components/mdx/CodeSandbox.jsx\";\n\n# React 中 `useContext` 跟 React-MobX 的差異\n\n## `useContext`\n\n`useContext` 是 react 提供的一個 hook，可以讓我們透過讀取和訂閱元件中 `context` 共享元件之間的資料，主要是用來解決狀態提升和 prop drilling 的問題（即層層傳遞 props）。\n\n```jsx title=\"App.jsx\"\nimport { createContext, useContext, useRef, useState } from \"react\";\n\nconst AuthContext = createContext(null);\n\nexport default function App() {\n  const [currentUser, setCurrentUser] = useState(\"\");\n  console.log(\"App rendered\");\n  return (\n    <AuthContext.Provider value={{ currentUser, setCurrentUser }}>\n      <Form />\n    </AuthContext.Provider>\n  );\n}\n\nfunction WelcomeCard() {\n  const { currentUser, setCurrentUser } = useContext(AuthContext);\n  console.log(\"WelcomeCard rendered\");\n  return (\n    <div>\n      <h1>Welcome, {currentUser}!</h1>\n      <button onClick={() => setCurrentUser(\"\")}>Log out</button>\n    </div>\n  );\n}\n\nfunction News() {\n  console.log(\"News rendered\");\n  return (\n    <div>\n      <h1>Latest News</h1>\n      <ul>\n        <li>ewrweorjewoirj</li>\n        <li>ewwwwwrj</li>\n        <li>wjwirjwi</li>\n      </ul>\n    </div>\n  );\n}\n\nfunction Form() {\n  const { currentUser, setCurrentUser } = useContext(AuthContext);\n  const [name, setName] = useState(\"\");\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    setCurrentUser(name);\n  }\n  console.log(\"Form rendered\");\n  return (\n    <section>\n      {currentUser && <WelcomeCard />}\n      {!currentUser && (\n        <form onSubmit={handleSubmit}>\n          <div>\n            <label name=\"username\">\n              username\n              <input\n                type={\"text\"}\n                id=\"username\"\n                onChange={(event) => setName(event.target.value)}\n              />\n            </label>\n          </div>\n          <button type=\"submit\">Log in</button>\n        </form>\n      )}\n      <News />\n    </section>\n  );\n}\n```\n\n<CodeSandbox codeSandboxId=\"5lfkj4\" />\n\n在這例子中，使用 useContext 實作了一個簡單的登入表單，當使用者輸入名稱後，點擊登入按鈕，就會顯示歡迎卡片，並且可以登出。\n\n在 App 元件中，使用 `AuthContext.Provider` 提供了 `currentUser` 和 `setCurrentUser` 兩個方法，透過 `useContext` 可以在子元件中取得這兩個方法。\n\n子元件透過 `setCurrentUser` 方法，可以改變 `AuthContext` 的 `currentUser` 的值，並且重新 render 子元件。\n\n### 透過 Context 傳遞資料\n\n在 `WelcomeCard` 中，我們透過 `useContext` 取得 `currentUser` 和 `setCurrentUser`，不需要透過 props 傳遞資料，就可以取得 `currentUser` 的值。\n\n### 更新 `Context` 的值\n\n在 App 元件中，`<AuthContext.Provider value={{ currentUser, setCurrentUser }}></<AuthContext.Provider>`向下子元件提供 `AuthContext` 的初始值 `currentUser` 與更新方法 setCurrentUser 。\n\n在 `Form` 元件中，我們透過`const { currentUser, setCurrentUser } = useContext(AuthContext);` 去取得 `currentUser` 和 `setCurrentUser`，並且在 `handleSubmit` 方法中，透過 `setCurrentUser(name)` 去更新 `AuthContext`的`currentUser` 的值。\n\n### 當 `Context` 的值改變時，會 re-render 子元件\n\n接續上方，當提交表單後，`currentUser` 的值改變，`AuthContext` 的 `currentUser` 的值也會改變，這時候從 `AuthContext` 所在的元件 `App` 向下開始 re-render，並且接續 re-render 子元件 `Form`、 `WelcomeCard`、`News`。\n\n## React-MobX\n\nReact-MobX 是一個 React 應用程式狀態管理的工具，透過觀察者模式，當 MobX 狀態變更時元件可以自動更新 UI，不需要手動去更新元件。\n\n```jsx title=\"App.jsx\"\nimport Counter from \"./Counter\";\nimport counterStore from \"./counterStore\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Board = observer(() => {\n  console.log(\"Board rendered\");\n  return <h1>Count: {counterStore.count}</h1>;\n});\n\nexport default function App() {\n  console.log(\"App rendered\");\n  return (\n    <div>\n      <h1>MobX-State-Tree 計數器範例</h1>\n      <Board />\n      <Counter />\n    </div>\n  );\n}\n```\n\n```jsx title=\"counterStore.js\"\nimport { types } from \"mobx-state-tree\";\n\n// 定義一個 Counter 模型\nconst CounterModel = types\n  .model({\n    count: types.number, // 可觀察的狀態\n  })\n  .actions((self) => ({\n    // 定義 action 來修改狀態\n    increment() {\n      self.count += 1;\n    },\n    decrement() {\n      self.count -= 1;\n    },\n  }));\n\n// 創建模型實例\nconst counterStore = CounterModel.create({\n  count: 0,\n});\n\nexport default counterStore;\n```\n\n- 使用了 mobx-state-tree 來定義一個結構化的狀態樹 `CounterModel`，其中有一個 `count` 狀態和兩個修改該狀態的 action (`increment` 和 `decrement`)。\n\n- 使用 `types.model` 定義 MobX-State-Tree 模型，然後通過 actions 來定義修改狀態的方法。\n\n```jsx title=\"Counter.jsx\"\nimport React from \"react\";\nimport { observer } from \"mobx-react-lite\"; // observer 使 React 元件能觀察 MobX 的狀態變更\nimport counterStore from \"./counterStore\"; // 引入剛才定義的 store\n\nconst Counter = observer(() => {\n  console.log(\"Counter rendered\");\n  return (\n    <div>\n      <button onClick={() => counterStore.increment()}>Increment</button>\n      <button onClick={() => counterStore.decrement()}>Decrement</button>\n    </div>\n  );\n});\n\nexport default Counter;\n```\n\n- 使用 observer 讓 React 元件能夠觀察並反應 MobX-State-Tree 狀態的變化。當 `counterStore.count` 改變時，React 元件會自動重新渲染。\n- 透過按鈕點擊來觸發 `increment` 和 `decrement` action，這些方法會自動更新狀態。\n- 在這個例子中，只會重新渲染 `Board` 元件，不會像使用 `useContext` 一樣向下更新使用該 `context`的子元件。\n\n  https://codesandbox.io/p/sandbox/5lkzr4\n\n<CodeSandbox codeSandboxId=\"5lkzr4\" />\n\n## `useContext` 和 React-MobX 的差異\n\n| 特性               | `useContext `                                                                                          | React-MobX                                       |\n| ------------------ | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------ |\n| 狀態管理範圍       | 可以包裹在特定 component tree ，範圍靈活                                                               | 只能在全域最上層                                 |\n| 狀態變更與更新機制 | 當 `context` 的值更新時，所有使用該 `context` 的元件都會重新渲染，無論這些組件是否實際依賴被更新的值。 | 僅重新渲染觀察到狀態變更的元件，精細控制渲染粒度 |\n| 應用場景           | 適合多語系、主題等較簡單的全域性的狀態管理                                                             | 適合較大型的應用程式，需要更細粒度的狀態管理     |\n","createdAt":"2025-08-16T08:43:55.385Z","updatedAt":"2025-08-16T08:43:55.385Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":102,"data":{"documentId":"kt55i6e9be9d53a2zxd3b7xi","slug":"usecontext-mobx","title":"React 中 useContext 跟 React-MobX 的差異","date":"2025-08-16T08:43:55.284Z","description":"","content":"\nimport CodeSandbox from \"../../src/components/mdx/CodeSandbox.jsx\";\n\n# React 中 `useContext` 跟 React-MobX 的差異\n\n## `useContext`\n\n`useContext` 是 react 提供的一個 hook，可以讓我們透過讀取和訂閱元件中 `context` 共享元件之間的資料，主要是用來解決狀態提升和 prop drilling 的問題（即層層傳遞 props）。\n\n```jsx title=\"App.jsx\"\nimport { createContext, useContext, useRef, useState } from \"react\";\n\nconst AuthContext = createContext(null);\n\nexport default function App() {\n  const [currentUser, setCurrentUser] = useState(\"\");\n  console.log(\"App rendered\");\n  return (\n    <AuthContext.Provider value={{ currentUser, setCurrentUser }}>\n      <Form />\n    </AuthContext.Provider>\n  );\n}\n\nfunction WelcomeCard() {\n  const { currentUser, setCurrentUser } = useContext(AuthContext);\n  console.log(\"WelcomeCard rendered\");\n  return (\n    <div>\n      <h1>Welcome, {currentUser}!</h1>\n      <button onClick={() => setCurrentUser(\"\")}>Log out</button>\n    </div>\n  );\n}\n\nfunction News() {\n  console.log(\"News rendered\");\n  return (\n    <div>\n      <h1>Latest News</h1>\n      <ul>\n        <li>ewrweorjewoirj</li>\n        <li>ewwwwwrj</li>\n        <li>wjwirjwi</li>\n      </ul>\n    </div>\n  );\n}\n\nfunction Form() {\n  const { currentUser, setCurrentUser } = useContext(AuthContext);\n  const [name, setName] = useState(\"\");\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    setCurrentUser(name);\n  }\n  console.log(\"Form rendered\");\n  return (\n    <section>\n      {currentUser && <WelcomeCard />}\n      {!currentUser && (\n        <form onSubmit={handleSubmit}>\n          <div>\n            <label name=\"username\">\n              username\n              <input\n                type={\"text\"}\n                id=\"username\"\n                onChange={(event) => setName(event.target.value)}\n              />\n            </label>\n          </div>\n          <button type=\"submit\">Log in</button>\n        </form>\n      )}\n      <News />\n    </section>\n  );\n}\n```\n\n<CodeSandbox codeSandboxId=\"5lfkj4\" />\n\n在這例子中，使用 useContext 實作了一個簡單的登入表單，當使用者輸入名稱後，點擊登入按鈕，就會顯示歡迎卡片，並且可以登出。\n\n在 App 元件中，使用 `AuthContext.Provider` 提供了 `currentUser` 和 `setCurrentUser` 兩個方法，透過 `useContext` 可以在子元件中取得這兩個方法。\n\n子元件透過 `setCurrentUser` 方法，可以改變 `AuthContext` 的 `currentUser` 的值，並且重新 render 子元件。\n\n### 透過 Context 傳遞資料\n\n在 `WelcomeCard` 中，我們透過 `useContext` 取得 `currentUser` 和 `setCurrentUser`，不需要透過 props 傳遞資料，就可以取得 `currentUser` 的值。\n\n### 更新 `Context` 的值\n\n在 App 元件中，`<AuthContext.Provider value={{ currentUser, setCurrentUser }}></<AuthContext.Provider>`向下子元件提供 `AuthContext` 的初始值 `currentUser` 與更新方法 setCurrentUser 。\n\n在 `Form` 元件中，我們透過`const { currentUser, setCurrentUser } = useContext(AuthContext);` 去取得 `currentUser` 和 `setCurrentUser`，並且在 `handleSubmit` 方法中，透過 `setCurrentUser(name)` 去更新 `AuthContext`的`currentUser` 的值。\n\n### 當 `Context` 的值改變時，會 re-render 子元件\n\n接續上方，當提交表單後，`currentUser` 的值改變，`AuthContext` 的 `currentUser` 的值也會改變，這時候從 `AuthContext` 所在的元件 `App` 向下開始 re-render，並且接續 re-render 子元件 `Form`、 `WelcomeCard`、`News`。\n\n## React-MobX\n\nReact-MobX 是一個 React 應用程式狀態管理的工具，透過觀察者模式，當 MobX 狀態變更時元件可以自動更新 UI，不需要手動去更新元件。\n\n```jsx title=\"App.jsx\"\nimport Counter from \"./Counter\";\nimport counterStore from \"./counterStore\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Board = observer(() => {\n  console.log(\"Board rendered\");\n  return <h1>Count: {counterStore.count}</h1>;\n});\n\nexport default function App() {\n  console.log(\"App rendered\");\n  return (\n    <div>\n      <h1>MobX-State-Tree 計數器範例</h1>\n      <Board />\n      <Counter />\n    </div>\n  );\n}\n```\n\n```jsx title=\"counterStore.js\"\nimport { types } from \"mobx-state-tree\";\n\n// 定義一個 Counter 模型\nconst CounterModel = types\n  .model({\n    count: types.number, // 可觀察的狀態\n  })\n  .actions((self) => ({\n    // 定義 action 來修改狀態\n    increment() {\n      self.count += 1;\n    },\n    decrement() {\n      self.count -= 1;\n    },\n  }));\n\n// 創建模型實例\nconst counterStore = CounterModel.create({\n  count: 0,\n});\n\nexport default counterStore;\n```\n\n- 使用了 mobx-state-tree 來定義一個結構化的狀態樹 `CounterModel`，其中有一個 `count` 狀態和兩個修改該狀態的 action (`increment` 和 `decrement`)。\n\n- 使用 `types.model` 定義 MobX-State-Tree 模型，然後通過 actions 來定義修改狀態的方法。\n\n```jsx title=\"Counter.jsx\"\nimport React from \"react\";\nimport { observer } from \"mobx-react-lite\"; // observer 使 React 元件能觀察 MobX 的狀態變更\nimport counterStore from \"./counterStore\"; // 引入剛才定義的 store\n\nconst Counter = observer(() => {\n  console.log(\"Counter rendered\");\n  return (\n    <div>\n      <button onClick={() => counterStore.increment()}>Increment</button>\n      <button onClick={() => counterStore.decrement()}>Decrement</button>\n    </div>\n  );\n});\n\nexport default Counter;\n```\n\n- 使用 observer 讓 React 元件能夠觀察並反應 MobX-State-Tree 狀態的變化。當 `counterStore.count` 改變時，React 元件會自動重新渲染。\n- 透過按鈕點擊來觸發 `increment` 和 `decrement` action，這些方法會自動更新狀態。\n- 在這個例子中，只會重新渲染 `Board` 元件，不會像使用 `useContext` 一樣向下更新使用該 `context`的子元件。\n\n  https://codesandbox.io/p/sandbox/5lkzr4\n\n<CodeSandbox codeSandboxId=\"5lkzr4\" />\n\n## `useContext` 和 React-MobX 的差異\n\n| 特性               | `useContext `                                                                                          | React-MobX                                       |\n| ------------------ | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------ |\n| 狀態管理範圍       | 可以包裹在特定 component tree ，範圍靈活                                                               | 只能在全域最上層                                 |\n| 狀態變更與更新機制 | 當 `context` 的值更新時，所有使用該 `context` 的元件都會重新渲染，無論這些組件是否實際依賴被更新的值。 | 僅重新渲染觀察到狀態變更的元件，精細控制渲染粒度 |\n| 應用場景           | 適合多語系、主題等較簡單的全域性的狀態管理                                                             | 適合較大型的應用程式，需要更細粒度的狀態管理     |\n","createdAt":"2025-08-16T08:43:55.385Z","updatedAt":"2025-08-16T08:43:55.385Z","publishedAt":"2025-08-16T08:43:55.388Z","locale":null,"author":null}}
{"type":"api::post.post","id":103,"data":{"documentId":"m59cl6ubrnh43b98tf83xj17","slug":"dom-vdom","title":"DOM 與 Virtual DOM","date":"2025-08-16T08:43:55.420Z","description":"DOM DOM (Document Object Model) 是一個網頁樹狀資料結構的物件，用來呈現瀏覽器中的畫面結構。當頁面產生變化時，便是透過操作 DOM 後藉由瀏覽器的渲染引擎重繪來呈現畫面，一旦對 DOM 進行操作，渲染引擎就會自動地將整個畫面重繪。 操作 DOM 對效能的影響 操作 DOM 本身是一個昂貴的效能負擔，如果在短時間內頻繁或大量的更新 DOM 元素，可能會造成畫面卡頓，因為瀏覽器的渲染引擎也會跟著不斷重繪畫面。因此，在前端的針對 DOM 的效能優化就是盡量縮小操作 DOM 的範圍。","content":"\n## DOM\n\nDOM (Document Object Model) 是一個網頁樹狀資料結構的物件，用來呈現瀏覽器中的畫面結構。當頁面產生變化時，便是透過操作 DOM 後藉由瀏覽器的渲染引擎重繪來呈現畫面，一旦對 DOM 進行操作，渲染引擎就會自動地將整個畫面重繪。\n\n## 操作 DOM 對效能的影響\n\n操作 DOM 本身是一個昂貴的效能負擔，如果在短時間內頻繁或大量的更新 DOM 元素，可能會造成畫面卡頓，因為瀏覽器的渲染引擎也會跟著不斷重繪畫面。因此，在前端的針對 DOM 的效能優化就是盡量縮小操作 DOM 的範圍。\n\n## Virtual DOM\n\n為了縮小操作 DOM 的範圍 Virtual DOM 的概念就產生了，簡單來說，Virtual DOM 就是一個虛擬的畫面結構，同時也是描述真實的 DOM 結構。它本身就是由一個個的 DOM 元素組成的樹狀結構，而 DOM 元素的本身就是 Javascript 物件。\n\n與 DOM 的關係，可以比喻成 Virtual DOM 是 DOM 的試做品，在更新 DOM 之前，先產生開發者期望中虛擬的畫面結構，然後再用這個虛擬的畫面結構去實際操作 DOM 。\n\n## Virtual DOM 對於效能的優化\n\n當瀏覽器第一次繪製畫面時會產生實際的 DOM 結構，同時也會產生一個 Virtual DOM 的結構，因此當我們要再更新畫面會是這樣的：\n\n1. 根據資料產生一組新的 Virtual DOM 結構\n2. 將新的 Virtual DOM 結構與舊的 Virtual DOM 結構做比較\n3. 比較新舊之間差異的部分\n4. 將差異的部分更新在真實的 DOM 上\n5. 瀏覽器的渲染引擎會自動重繪畫面\n6. 若新舊的 Virtual DOM 結構一樣，則不會更新 DOM 結構，因此也不會重繪畫面\n\n這樣的做的好處可以，縮小操作 DOM 的範圍，只需要操作真正需要更新的 DOM 元素，可以大大的降低效能的負擔，另外，使用 Virtual DOM 的好處是：Virtual DOM 並不會向真實的 DOM 與瀏覽器的渲染引擎做綁定，因此產生的 JavaScript 物件較為單純，也因此節省了效能。\n","createdAt":"2025-08-16T08:43:55.458Z","updatedAt":"2025-08-16T10:25:15.004Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":105,"data":{"documentId":"yc2bneuiqp4t646zgzi9tijs","slug":"02-react-element","title":"02-建構畫面的最小單位：React Element","date":"2025-08-16T08:43:55.470Z","description":"","content":"\n## React Element\n\nReact Element 就是組成 React Virtual DOM 畫面結構的元素，它是基於 Virtual DOM 的概念描述並且組成畫面的最小單位，其本質是 JavaScript 物件資料型態，用來描述預期中真實的 DOM 元素。\n\n## 建立 React Element 的方法\n\n使用 React 的 createElement 方法來建立 React Element 並且傳入以下參數：\n\n1. type:元素的類型，標籤名稱的字串，例如:`h1`、`div`、`p`、`span`等，也可以傳入 React Element，例如 `Fragment`\n2. props:元素的屬性，必須是物件或`null`\n3. optional:子元素，可以傳入 `React Element`作為子節點 或 `null`、`string`、`number`...等。\n\n```jsx live\nfunction App() {\n  const h1Element = React.createElement(\n    \"h1\",\n    { className: \"title\" },\n    \"Hello World\",\n  );\n  return <div>{h1Element}</div>;\n}\n```\n\n根據上方例子可以理解為使用 createElement 方法來建立一個元素類型為 `h1` 的元素，並且將 `h1` 元素的屬性傳入className `title`，並且將 `h1` 元素的內容設定為 `Hello World`。這個 React Element 將轉換成相對應的 DOM 元素。\n\n將 h1Element 印出來可以發現，React element 本身為 Javascript 物件。\n\n```js\nconsole.log(h1Element)\n\n{\n    $$typeof: Symbol(react.element),\n    type: 'h1',\n    key: null,\n    ref: null,\n    props: {\n        className: 'title',\n        children: 'Hello World'\n        },\n     …\n}\n```\n\n接著透過 React 轉換 DOM 元素來呈現在瀏覽器畫面：\n![](./截圖%202024-04-07%20下午4.24.08.png)\n\n## React Element 與實際 DOM 的關係\n\n可以透過定義 React Element 後，透過 React 轉換成相對應的 DOM 元素來呈現在瀏覽器畫面。雖然 React Element 與 DOM 元素是相對應的關係，但是在某些屬性上還是略有不同的，例如：`class` 屬性在 React Element 中是使用 `className`。\n\n## React Element 一旦被建立後不可以被修改的特性\n\n為什麼 React Element 一旦被建立後不可以被修改? 源於 Virtual DOM 的概念，Virtual DOM 是透過比對新的 Virtual DOM 與舊 Virtual DOM 的差異來去更新真實的 DOM 元素的結構，以縮小操作 DOM 的範圍。\n\n而 React Element 是基於 React 中 Virtual DOM 組成虛擬畫面的最小單位，同時也是描述這個時間點歷史畫面紀錄。\n所以當資料更新時，會建立起新的 Virtual DOM 也就是新的 React Element，再透過與前一份 Virtual DOM 的 React Element 去做對比，最後再將差異更新到真實的 DOM 元素上，這是 React 核心的更新機制。\n\nReact 為了保持這個機制的運作，所以讓 React Element 被建立後就是不能被修改，因為一旦可以修改 React 就無法去比較新舊的差異，因此在 React 中你也無法手動去修改 React Element。\n","createdAt":"2025-08-16T08:43:55.475Z","updatedAt":"2025-08-16T08:43:55.475Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":106,"data":{"documentId":"yc2bneuiqp4t646zgzi9tijs","slug":"02-react-element","title":"02-建構畫面的最小單位：React Element","date":"2025-08-16T08:43:55.470Z","description":"","content":"\n## React Element\n\nReact Element 就是組成 React Virtual DOM 畫面結構的元素，它是基於 Virtual DOM 的概念描述並且組成畫面的最小單位，其本質是 JavaScript 物件資料型態，用來描述預期中真實的 DOM 元素。\n\n## 建立 React Element 的方法\n\n使用 React 的 createElement 方法來建立 React Element 並且傳入以下參數：\n\n1. type:元素的類型，標籤名稱的字串，例如:`h1`、`div`、`p`、`span`等，也可以傳入 React Element，例如 `Fragment`\n2. props:元素的屬性，必須是物件或`null`\n3. optional:子元素，可以傳入 `React Element`作為子節點 或 `null`、`string`、`number`...等。\n\n```jsx live\nfunction App() {\n  const h1Element = React.createElement(\n    \"h1\",\n    { className: \"title\" },\n    \"Hello World\",\n  );\n  return <div>{h1Element}</div>;\n}\n```\n\n根據上方例子可以理解為使用 createElement 方法來建立一個元素類型為 `h1` 的元素，並且將 `h1` 元素的屬性傳入className `title`，並且將 `h1` 元素的內容設定為 `Hello World`。這個 React Element 將轉換成相對應的 DOM 元素。\n\n將 h1Element 印出來可以發現，React element 本身為 Javascript 物件。\n\n```js\nconsole.log(h1Element)\n\n{\n    $$typeof: Symbol(react.element),\n    type: 'h1',\n    key: null,\n    ref: null,\n    props: {\n        className: 'title',\n        children: 'Hello World'\n        },\n     …\n}\n```\n\n接著透過 React 轉換 DOM 元素來呈現在瀏覽器畫面：\n![](./截圖%202024-04-07%20下午4.24.08.png)\n\n## React Element 與實際 DOM 的關係\n\n可以透過定義 React Element 後，透過 React 轉換成相對應的 DOM 元素來呈現在瀏覽器畫面。雖然 React Element 與 DOM 元素是相對應的關係，但是在某些屬性上還是略有不同的，例如：`class` 屬性在 React Element 中是使用 `className`。\n\n## React Element 一旦被建立後不可以被修改的特性\n\n為什麼 React Element 一旦被建立後不可以被修改? 源於 Virtual DOM 的概念，Virtual DOM 是透過比對新的 Virtual DOM 與舊 Virtual DOM 的差異來去更新真實的 DOM 元素的結構，以縮小操作 DOM 的範圍。\n\n而 React Element 是基於 React 中 Virtual DOM 組成虛擬畫面的最小單位，同時也是描述這個時間點歷史畫面紀錄。\n所以當資料更新時，會建立起新的 Virtual DOM 也就是新的 React Element，再透過與前一份 Virtual DOM 的 React Element 去做對比，最後再將差異更新到真實的 DOM 元素上，這是 React 核心的更新機制。\n\nReact 為了保持這個機制的運作，所以讓 React Element 被建立後就是不能被修改，因為一旦可以修改 React 就無法去比較新舊的差異，因此在 React 中你也無法手動去修改 React Element。\n","createdAt":"2025-08-16T08:43:55.475Z","updatedAt":"2025-08-16T08:43:55.475Z","publishedAt":"2025-08-16T08:43:55.476Z","locale":null,"author":null}}
{"type":"api::post.post","id":107,"data":{"documentId":"nms4lqmwt33rww824njdh2f1","slug":"03-render-react-element","title":"03-Render React element","date":"2025-08-16T08:43:55.484Z","description":"","content":"\n## `react-dom`\n\n`react-dom` 是 react 用來將 React Element 繪製成實際 DOM 的工具。透過 `react-dom` 可以指定目標容器去產生或操作實際的 DOM 元素，在 React 專案中會使用 `root` 作為目標容器的入口，以此將 React Element 繪製成實際 DOM 輸出至 `root` 的容器中，而在這個容器中所輸出的 DOM 元素將會交由 React 管轄。\n\n## 將 React Element 繪製成實際 DOM 的流程\n\n### 1.準備輸出 DOM 元素的目標容器\n\n這個 `<div id=\"root\"></div>` 就是 React 繪製成實際 DOM 的目標容器。在此容器內的元素將會被 React 管轄。\n\n```html\n<body>\n  <div id=\"root\"></div>\n</body>\n```\n\n### 2.建立 Root 並指定目標容器\n\n```js title=index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n//取得目標容器 DOM 節點\nconst rootContainer = document.getElementById(\"root\");\n\n//建立React app 畫面管轄入口\nconst root = ReactDOM.createRoot(rootContainer);\n```\n\n### 3. 建立 React Element\n\n```js title=index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n//取得目標容器 DOM 節點\nconst rootContainer = document.getElementById(\"root\");\n\n//建立React app 畫面管轄入口\nconst root = ReactDOM.createRoot(rootContainer);\n\n// highlight-start\nconst h1Element = React.createElement(\n  \"h1\",\n  { className: \"title\" },\n  \"Hello World\",\n);\n// highlight-end\n```\n\n### 4.將 React Element 繪製成實際 DOM 元素\n\n```js title=index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n//取得目標容器 DOM 節點\nconst rootContainer = document.getElementById(\"root\");\n\n//建立React app 畫面管轄入口\nconst root = ReactDOM.createRoot(rootContainer);\n\nconst h1Element = React.createElement(\n  \"h1\",\n  { className: \"title\" },\n  \"Hello World\",\n);\n\n// highlight-next-line\nroot.render(h1Element);\n```\n\n`react-dom` 透過 `root.render()` 將 React Element 進行繪製成真實的 DOM 元素並且注入 root 容器中，在使用 root 容器進行畫面渲染。\n\n## Virtual DOM 的畫面管理流程\n\nVirtual DOM 將畫面的管理流程拆分成兩個階段：Reconciler 和 Render。\n\n### Reconciler\n\nReconciler 主要是用來定義與管理畫面的結構。\n\n在瀏覽器的環境，Reconciler 負責建立和定義 React Element，以描述預期的 DOM 結構，另一個重要的功能是當畫面需要更新時，會找出新舊的 React Element 之間的差異，將差異的部分告訴 Render 。\n\n### Render\n\nRender 則是將 Reconciler 所定義好的描述結構轉換成畫面。\n在瀏覽器的環境下的 Render 就是 `react-dom`， React Element 將透過 `react-dom` 所產生的 root 去繪製成實際 DOM 元素，當畫面需要更新時，會將 Reconciler 比對新舊差異的部分同步化到實際的 DOM 更新。\n\n畫面管理拆分成 Reconciler 與 Render 處理的一大好處是，React 可以替換 Render 去產生瀏覽器以外的 UI 換畫面，例如：React Native，就是把 React 透過專用的 Render 來轉換成 Android 或 IOS 的原生的 UI 畫面。\n","createdAt":"2025-08-16T08:43:55.488Z","updatedAt":"2025-08-16T08:43:55.488Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":108,"data":{"documentId":"nms4lqmwt33rww824njdh2f1","slug":"03-render-react-element","title":"03-Render React element","date":"2025-08-16T08:43:55.484Z","description":"","content":"\n## `react-dom`\n\n`react-dom` 是 react 用來將 React Element 繪製成實際 DOM 的工具。透過 `react-dom` 可以指定目標容器去產生或操作實際的 DOM 元素，在 React 專案中會使用 `root` 作為目標容器的入口，以此將 React Element 繪製成實際 DOM 輸出至 `root` 的容器中，而在這個容器中所輸出的 DOM 元素將會交由 React 管轄。\n\n## 將 React Element 繪製成實際 DOM 的流程\n\n### 1.準備輸出 DOM 元素的目標容器\n\n這個 `<div id=\"root\"></div>` 就是 React 繪製成實際 DOM 的目標容器。在此容器內的元素將會被 React 管轄。\n\n```html\n<body>\n  <div id=\"root\"></div>\n</body>\n```\n\n### 2.建立 Root 並指定目標容器\n\n```js title=index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n//取得目標容器 DOM 節點\nconst rootContainer = document.getElementById(\"root\");\n\n//建立React app 畫面管轄入口\nconst root = ReactDOM.createRoot(rootContainer);\n```\n\n### 3. 建立 React Element\n\n```js title=index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n//取得目標容器 DOM 節點\nconst rootContainer = document.getElementById(\"root\");\n\n//建立React app 畫面管轄入口\nconst root = ReactDOM.createRoot(rootContainer);\n\n// highlight-start\nconst h1Element = React.createElement(\n  \"h1\",\n  { className: \"title\" },\n  \"Hello World\",\n);\n// highlight-end\n```\n\n### 4.將 React Element 繪製成實際 DOM 元素\n\n```js title=index.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n//取得目標容器 DOM 節點\nconst rootContainer = document.getElementById(\"root\");\n\n//建立React app 畫面管轄入口\nconst root = ReactDOM.createRoot(rootContainer);\n\nconst h1Element = React.createElement(\n  \"h1\",\n  { className: \"title\" },\n  \"Hello World\",\n);\n\n// highlight-next-line\nroot.render(h1Element);\n```\n\n`react-dom` 透過 `root.render()` 將 React Element 進行繪製成真實的 DOM 元素並且注入 root 容器中，在使用 root 容器進行畫面渲染。\n\n## Virtual DOM 的畫面管理流程\n\nVirtual DOM 將畫面的管理流程拆分成兩個階段：Reconciler 和 Render。\n\n### Reconciler\n\nReconciler 主要是用來定義與管理畫面的結構。\n\n在瀏覽器的環境，Reconciler 負責建立和定義 React Element，以描述預期的 DOM 結構，另一個重要的功能是當畫面需要更新時，會找出新舊的 React Element 之間的差異，將差異的部分告訴 Render 。\n\n### Render\n\nRender 則是將 Reconciler 所定義好的描述結構轉換成畫面。\n在瀏覽器的環境下的 Render 就是 `react-dom`， React Element 將透過 `react-dom` 所產生的 root 去繪製成實際 DOM 元素，當畫面需要更新時，會將 Reconciler 比對新舊差異的部分同步化到實際的 DOM 更新。\n\n畫面管理拆分成 Reconciler 與 Render 處理的一大好處是，React 可以替換 Render 去產生瀏覽器以外的 UI 換畫面，例如：React Native，就是把 React 透過專用的 Render 來轉換成 Android 或 IOS 的原生的 UI 畫面。\n","createdAt":"2025-08-16T08:43:55.488Z","updatedAt":"2025-08-16T08:43:55.488Z","publishedAt":"2025-08-16T08:43:55.490Z","locale":null,"author":null}}
{"type":"api::post.post","id":109,"data":{"documentId":"o05cjwkdgizp7a3oltvf2efq","slug":"jsx","title":"JSX 根本不是在 JavaScript 中寫 HTML","date":"2025-08-16T08:43:55.499Z","description":"JSX 語法 JSX 語法是一種語法糖，提供我們在建立 react element 時，用類似撰寫 HTML 語法的體驗，提高可閱讀性與開發體驗。 1. 使用 React.createElement 建立 React Element ２. 使用 JSX 語法建立 React Element JSX 語法透過開發工具轉譯後以上兩者的 react element 結構是一樣的，但是使用 JSX 語法的方式更為簡潔。 JSX 語法本質就是 去呼叫 React.createElement 來建立 React Element 的替代語法，其所回傳的值便是一個 React Element。","content":"\n## JSX 語法\n\nJSX 語法是一種語法糖，提供我們在建立 react element 時，用類似撰寫 HTML 語法的體驗，提高可閱讀性與開發體驗。\n\n1. 使用 React.createElement 建立 React Element\n\n```jsx live \"\nfunction App() {\n  const h1Element = React.createElement(\n    \"h1\",\n    { className: \"title\" },\n    \"Hello World\",\n  );\n  return <div>{h1Element}</div>;\n}\n```\n\n２. 使用 JSX 語法建立 React Element\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  return (\n    <div>\n      <h1 className=\"title\">Hello World</h1>\n    </div>\n  );\n}\n```\n\nJSX 語法透過開發工具轉譯後以上兩者的 react element 結構是一樣的，但是使用 JSX 語法的方式更為簡潔。\nJSX 語法本質就是 **去呼叫 React.createElement** 來建立 React Element 的替代語法，其所回傳的值便是一個 React Element。\n\n但是 JSX 語法 在瀏覽器中的 JavaScript 引擎是無法直接執行的，所以需要透過 **transpiler** 來將 JSX 語法靜態轉譯成瀏覽器 JavaScript 引擎可以執行的 JavaScript 語法。\n\n## 什麼是 transpiler?\n\ntranspiler (轉譯器)＝ translator (翻譯器) + compiler (編譯器)，也就是將原始的程式碼轉換成另一種程式碼的工具，例如 Babel 就是一個將 JSX 語法轉譯成瀏覽器可以執行的 JavaScript 語法的轉譯器。\n\n## JSX transformer\n\nJSX transformer 負責轉譯 JSX 語法， Babel 就是 react 官方建議的 transpiler\n\n## JSX 語法是經過什麼樣的處理最後才能在瀏覽器中執行並定義畫面？\n\n```js title=\"index.jsx\"\nimport ReactDOM from \"react-dom/client\";\n\nconst rootContainer = document.getElementById(\"root\");\n\nconst root = ReactDOM.createRoot(rootContainer);\n\n// highlight-start\nconst h1Element = React.createElement(\n  \"h1\",\n  { className: \"title\" },\n  \"Hello World\",\n);\n// highlight-end\n\nroot.render(h1Element);\n```\n\nReact 17 後，在開發環境 Build time 、Javascript 還沒有被執行時，經過 Babel JSX transformer 搭配 `jsx-runtime` 轉譯後的程式碼:\n\n```js title=\"output.js\"\nimport ReactDOM from \"react-dom/client\";\n// highlight-next-line\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst rootContainer = document.getElementById(\"root\");\n\nconst root = ReactDOM.createRoot(rootContainer);\n\n// highlight-start\nconst h1Element = _jsx(\"h1\", { className: \"title\" }, \"Hello World\");\n// highlight-end\n\nroot.render(h1Element);\n```\n\n`_jsx` 方法的意思類似呼叫建立 React element 的 `React.createElement` 方法，透過靜態解析JSX 語法的語意來避免一些多餘的資料處理流程，這樣的轉譯過程是在 Build time 時完成的，所以在瀏覽器中 Runtime 執行時，不需要再進行轉譯，直接執行即可。\n","createdAt":"2025-08-16T08:43:55.525Z","updatedAt":"2025-08-16T10:25:15.022Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":111,"data":{"documentId":"bnetg5dcw6nu2nskxxvigeiv","slug":"05-jsx","title":"05-JSX 的語法規則與畫面渲染的實用技巧","date":"2025-08-16T08:43:55.537Z","description":"","content":"## JSX 的標籤需閉合\n\n在 HTML 中，有些標籤是不需要閉合的，例如 `<img>`、`<input>`，但在 JSX 中，所有的標籤都需要閉合。\n\n```HTML\n<input type=\"text\">\n<img src=\"./index.jpg\">\n\n```\n\n在 JSX 中，沒有子元素的標籤也需要閉合，例如：使用自我閉合，如下：\n\n```jsx\n<input type=\"text\"/>\n<img src=\"./index.jpg\"/>\n\n```\n\n這樣 JSX transformer 才能夠正確地轉譯。\n\n## 為什麼 JSX 語法的第一層只能有一個節點？\n\n因為 JSX 語法就是呼叫一次 React.createElement() 方法，而這個方法只會回傳一個 React Element ，又樹狀的資料結構只能有一個根節點，所以 JSX 語法的第一層只能有一個節點，所以如果有多個節點，就必須用共同一個父節點包起來。\n\n```jsx\nconst element = (\n  //highlight-next-line\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n    //highlight-next-line\n  </div>\n);\n```\n\n如果不想因為第一層用 `<div></div>` 包起來而多一個多餘的 DOM 節點，可以使用 React.Fragment 來包裹或是使用`<></>`這樣就不會產生多餘的 DOM 節點。\n\n1. 使用 `React.Fragment`\n\n```jsx\nimport { Fragment } from \"react\";\nconst element = (\n  //highlight-next-line\n  <Fragment>\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n    //highlight-next-line\n  </Fragment>\n);\n```\n\n2. 使用 `<></>`\n\n```jsx\nconst element = (\n  //highlight-next-line\n  <>\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n    //highlight-next-line\n  </>\n);\n```\n\n這兩個方法在瀏覽器轉譯成實際的 DOM 時：\n\n```HTML\n<div id=\"root\">\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n</div>\n```\n","createdAt":"2025-08-16T08:43:55.541Z","updatedAt":"2025-08-16T08:43:55.541Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":112,"data":{"documentId":"bnetg5dcw6nu2nskxxvigeiv","slug":"05-jsx","title":"05-JSX 的語法規則與畫面渲染的實用技巧","date":"2025-08-16T08:43:55.537Z","description":"","content":"## JSX 的標籤需閉合\n\n在 HTML 中，有些標籤是不需要閉合的，例如 `<img>`、`<input>`，但在 JSX 中，所有的標籤都需要閉合。\n\n```HTML\n<input type=\"text\">\n<img src=\"./index.jpg\">\n\n```\n\n在 JSX 中，沒有子元素的標籤也需要閉合，例如：使用自我閉合，如下：\n\n```jsx\n<input type=\"text\"/>\n<img src=\"./index.jpg\"/>\n\n```\n\n這樣 JSX transformer 才能夠正確地轉譯。\n\n## 為什麼 JSX 語法的第一層只能有一個節點？\n\n因為 JSX 語法就是呼叫一次 React.createElement() 方法，而這個方法只會回傳一個 React Element ，又樹狀的資料結構只能有一個根節點，所以 JSX 語法的第一層只能有一個節點，所以如果有多個節點，就必須用共同一個父節點包起來。\n\n```jsx\nconst element = (\n  //highlight-next-line\n  <div>\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n    //highlight-next-line\n  </div>\n);\n```\n\n如果不想因為第一層用 `<div></div>` 包起來而多一個多餘的 DOM 節點，可以使用 React.Fragment 來包裹或是使用`<></>`這樣就不會產生多餘的 DOM 節點。\n\n1. 使用 `React.Fragment`\n\n```jsx\nimport { Fragment } from \"react\";\nconst element = (\n  //highlight-next-line\n  <Fragment>\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n    //highlight-next-line\n  </Fragment>\n);\n```\n\n2. 使用 `<></>`\n\n```jsx\nconst element = (\n  //highlight-next-line\n  <>\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n    //highlight-next-line\n  </>\n);\n```\n\n這兩個方法在瀏覽器轉譯成實際的 DOM 時：\n\n```HTML\n<div id=\"root\">\n    <h1>Hello, world!</h1>\n    <h2>Welcome to React</h2>\n</div>\n```\n","createdAt":"2025-08-16T08:43:55.541Z","updatedAt":"2025-08-16T08:43:55.541Z","publishedAt":"2025-08-16T08:43:55.543Z","locale":null,"author":null}}
{"type":"api::post.post","id":113,"data":{"documentId":"y9uikr4yo018ii37w0afl3n3","slug":"06","title":"06-單向資料流與一律重繪渲染策略","date":"2025-08-16T08:43:55.551Z","description":"","content":"## 單向資料流的概念\n\n![](./單向資料流.png)\n\n單向資料流指的是一種畫面與資料流管理的設計模式，原始資料變動會驅動畫面的更新，透過原始資料與模板綁定後渲染產生畫面，當資料變動時，畫面才會去更新。在資料傳遞的過程中，是單向的而且不可以被修改的，這樣可以確保畫面不會因為資料在更新以外的地方被修改而導致畫面的不一致，畫面也不會去修改原始資料。\n\n透過單一資料來源可以實踐將畫面與資料分離管理，使用原始資料來驅動畫面的更新，這樣可以讓畫面的狀態變得可預測，也可以讓程式碼變得更容易維護，這是因為資料的變動只會是由開發者去控制，而畫面結果也只會是因為資料的變動與渲染邏輯去產生。\n\n## 實現單向資料流常見的渲染策略\n\n### 渲染策略一：根據資料變動的範圍更新 DOM 元素\n\n就是依據原始資料更新的內容，開發者自行判斷有哪些 DOM 元素需要更新，然後透過操作 DOM 元素的方法手動去更新畫面。\n\n#### 優點：\n\n＊ 減少不必要的 DOM 元素操作，同時減少效能的浪費。\n\n#### 缺點：\n\n＊ 依賴開發者人工判斷，當應用程式架構龐大複雜時，不易維護與管理，容易出錯。\n\n#### 使用該策略的前端框架：Vue\n\nVue 透過資料與模板的綁定，當監聽到資料發生改變時，Vue 會自動去更新 DOM 元素，這樣就不用開發者手動去操作 DOM 元素。\n\n### 渲染策略二：一律重繪\n\n當資料更新後，會將原來的 DOM 元素全部清除，然後重新根據新的原始資料去重新繪製畫面。\n\n#### 優點：\n\n＊ 開發者不用在乎資料更新的內容，只要定義好原始資料與模板定義、渲染邏輯就好，不用手動去更新 DOM 元素。\n\n#### 缺點：\n\n＊ 效能不佳，因為先把整個 DOM 全部清空，再操作 DOM 元素，如此一來操作 DOM 元素的次數過多，會導致畫面卡頓，連帶著使用者體驗不佳。\n\n#### 使用該策略的前端框架： React\n\nReact 實現單向資料流的策略就是透過 Virtual DOM 結合一律重繪的策略，由於一律重繪的策略操作真實的 DOM 元素會耗費大量的效能，因此改成一律重繪 Virtual DOM 。當原始資料發生變動時，React 就會去根據新的原始資料產生一份新的 React Element ，這個過程就是 `re-render`，然後再根據舊的 React Element 與新的 React Element 結構做比較，找出差異的部分，最後再將差異的部分更新到真實的 DOM 元素上，如此一來就可以達到單向資料流的效果。\n","createdAt":"2025-08-16T08:43:55.556Z","updatedAt":"2025-08-16T08:43:55.556Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":114,"data":{"documentId":"y9uikr4yo018ii37w0afl3n3","slug":"06","title":"06-單向資料流與一律重繪渲染策略","date":"2025-08-16T08:43:55.551Z","description":"","content":"## 單向資料流的概念\n\n![](./單向資料流.png)\n\n單向資料流指的是一種畫面與資料流管理的設計模式，原始資料變動會驅動畫面的更新，透過原始資料與模板綁定後渲染產生畫面，當資料變動時，畫面才會去更新。在資料傳遞的過程中，是單向的而且不可以被修改的，這樣可以確保畫面不會因為資料在更新以外的地方被修改而導致畫面的不一致，畫面也不會去修改原始資料。\n\n透過單一資料來源可以實踐將畫面與資料分離管理，使用原始資料來驅動畫面的更新，這樣可以讓畫面的狀態變得可預測，也可以讓程式碼變得更容易維護，這是因為資料的變動只會是由開發者去控制，而畫面結果也只會是因為資料的變動與渲染邏輯去產生。\n\n## 實現單向資料流常見的渲染策略\n\n### 渲染策略一：根據資料變動的範圍更新 DOM 元素\n\n就是依據原始資料更新的內容，開發者自行判斷有哪些 DOM 元素需要更新，然後透過操作 DOM 元素的方法手動去更新畫面。\n\n#### 優點：\n\n＊ 減少不必要的 DOM 元素操作，同時減少效能的浪費。\n\n#### 缺點：\n\n＊ 依賴開發者人工判斷，當應用程式架構龐大複雜時，不易維護與管理，容易出錯。\n\n#### 使用該策略的前端框架：Vue\n\nVue 透過資料與模板的綁定，當監聽到資料發生改變時，Vue 會自動去更新 DOM 元素，這樣就不用開發者手動去操作 DOM 元素。\n\n### 渲染策略二：一律重繪\n\n當資料更新後，會將原來的 DOM 元素全部清除，然後重新根據新的原始資料去重新繪製畫面。\n\n#### 優點：\n\n＊ 開發者不用在乎資料更新的內容，只要定義好原始資料與模板定義、渲染邏輯就好，不用手動去更新 DOM 元素。\n\n#### 缺點：\n\n＊ 效能不佳，因為先把整個 DOM 全部清空，再操作 DOM 元素，如此一來操作 DOM 元素的次數過多，會導致畫面卡頓，連帶著使用者體驗不佳。\n\n#### 使用該策略的前端框架： React\n\nReact 實現單向資料流的策略就是透過 Virtual DOM 結合一律重繪的策略，由於一律重繪的策略操作真實的 DOM 元素會耗費大量的效能，因此改成一律重繪 Virtual DOM 。當原始資料發生變動時，React 就會去根據新的原始資料產生一份新的 React Element ，這個過程就是 `re-render`，然後再根據舊的 React Element 與新的 React Element 結構做比較，找出差異的部分，最後再將差異的部分更新到真實的 DOM 元素上，如此一來就可以達到單向資料流的效果。\n","createdAt":"2025-08-16T08:43:55.556Z","updatedAt":"2025-08-16T08:43:55.556Z","publishedAt":"2025-08-16T08:43:55.558Z","locale":null,"author":null}}
{"type":"api::post.post","id":115,"data":{"documentId":"cwkfmwxq00vbpq0pmigbem38","slug":"07-component","title":"07-畫面組裝的藍圖：component 初探","date":"2025-08-16T08:43:55.566Z","description":"","content":"import CodeSandbox from \"../../../src/components/mdx/CodeSandbox.jsx\";\n\n## component\n\n簡單來說就是畫面的藍圖，component 就是由開發者自行定義好的商業邏輯、特定的樣式、React Element 畫面所組成的，就如同蓋房子一樣，如果說應用程式是一棟房子，那麼 component 就是搭建成房子的不同建材：鋼筋、水泥、磚頭...，透過組合這些 component 而逐步組成應用程式的畫面，同時 component 是可以重複使用的，讓程式碼變得更容易維護與管理。\n\n例如：設計一個 TodoList 的應用程式，可以將 TodoList 拆分成由多個 `<TodoItem />` 元件所組成的 `<TodoList/>` 元件，雖然 `<TodoItem />`這個元件是重用的，但每一個 `<TodoItem />` 都有其各自的元件狀態。\n\n```jsx title=\"TodoItem.jsx\"\nconst TodoItem = ({ todo }) => {\n  return <li>{todo}</li>;\n};\n```\n\n```jsx title=\"TodoList.jsx\"\nconst TodoList = () => {\n  const todos = [\"Todo 1\", \"Todo 2\", \"Todo 3\"];\n  return (\n    <div>\n      <h1>Todo List</h1>\n      <ul>\n        {todos.map((todo, index) => (\n          <TodoItem key={`${todo}-${index}`} todo={todo} />\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\n## props？ 為什麼 props 是唯讀的？\n\nprops 指的就是呼叫 component 時會傳入 component 的屬性，而 props 的資料型別在 React 中沒有任何限制。當 component 接收到從外部傳入的 props 後，就可以根據 props 去產生相對應的客製化的畫面或是商業邏輯。\n\n```jsx title=\"TodoItem.jsx\"\n// highlight-next-line\nconst TodoItem = ({ title, isDone }) => {\n  //將接收到的 props 使用解構取出屬性資料，這樣也就可以賦值到區域變數中\n  return(\n    <li>\n      <input type='checkbox' id={title} name={title} checked={isDone} />\n      <label htmlFor={title}>{title}</label>\n    </li>;\n  )\n};\n```\n\n```jsx title=\"TodoList.jsx\"\nconst TodoList = () => {\n  const todos = [\n    {\n      title: \"Todo 1\",\n      isDone: false,\n    },\n    {\n      title: \"Todo 2\",\n      isDone: true,\n    },\n    {\n      title: \"Todo 3\",\n      isDone: false,\n    },\n  ];\n  return (\n    <div>\n      <h1>Todo List</h1>\n      <ul>\n        {todos.map((todo, index) => (\n          <TodoItem\n            key={`${todo}-${index}`}\n            // highlight-start\n            title={todo.title} //將 title 屬性傳入 <TodoItem/>\n            isDone={todo.isDone} //將 isDone 屬性傳入 <TodoItem/>\n            // highlight-end\n          />\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\nprops 的特性是唯讀的，這是因為 React 的核心概念是單向資料流，所以當資料以 props 屬性傳遞到 components 內部時，為了確保資料的源頭與可追蹤性，以維持單向資料流的特性，所以 props 是不可以被修改的，因為當 props 被手動修改時，我們就無法確定資料的來源是從哪裡來的，也可能會出現無法預期的錯誤。\n\n## component 的 render 與 re-render\n\ncomponent 的一次 render 指的是 react 呼叫 component function 後產生描述一段畫面的 React Element 的結果。又 react virtual dom 為樹狀資料結構，當父 component 中包含一個或是多個子 component 時，當父 component render 時，其所包含的子 component 就會跟著進行一次的 render ，將所 render 完成的 react element 裝回上一層的父 component 上，整個過程是由上而下，會一直持續遍歷到最底層的 component，最後會拼裝成一個完整樹狀結構的 react element。\n\nre-render 則指的是當 component 的 props 或 state 資料發生變化時，react 會重新呼叫 component function 並重新 render 一次，會根據新的原始資料重新產生一份新的 react element，並透過 diff 演算法比對新舊的 react element，找出差異的部分，最後再進行 DOM 更新。\n\n### re-render 的時機點：\n\n1. component 本身 `setState` 更新資料\n2. 父層 component 資料更新傳入子 component\n3. Content provider 的 component 更新時\n\n## 為什麼 component 命名中的首字母必須為大寫？\n\n原是負責轉譯 react jsx transpiler 的 babel 會去根據首字母的大小寫去決定要轉譯成哪一種標籤類型。\n\n- 首字母為小寫： transpiler 會將其當作是字串並且傳入 `React.createElement()`方法作為第一個參數，ex: `React.createElement('div')`。最後取得實際相對的 DOM 元素。\n\n- 首字母為大寫： transpiler 會將其當作是變數名稱，會判斷為 component function 並且傳入 `React.createElement()`方法作為第一個參數，ex: `React.createElement(Hello)`。最後取得一段描述畫面的 React Element。\n\n## 正確呼叫 component 的方式\n\n有一個 component function 如下：\n\n```jsx\nfunction MyComponent() {\n  return <h1>Hello!</h1>;\n}\n```\n\n`<MyComponent />` 和 `{ MyComponent() }`有什麼差異？\n\n```jsx\nconst element1 = <MyComponent />;\nconsole.log(element1); //印出來會是 <MyComponent />;\n```\n\n當 `const element1 = <MyComponent />;` 這行被執行完成後，`MyComponent` component function 其實還沒有被呼叫到。\n\n```jsx\nconst element1 = <MyComponent />;\nconst element2 = MyComponent();\nconsole.log(\"element1\", element1);\nconsole.log(\"element2\", element2);\n```\n\n1. `<MyComponent />`\n\n```jsx\nconst element1 = <MyComponent />;\nconsole.log(\"element1\", element1);\n```\n\n![](./element1.png)\n\n2. `{MyComponent()}`\n\n```jsx\nconst element2 = MyComponent();\nconsole.log(\"element2\", element2);\n```\n\n![](./element2.png)\n\n這兩者種呼叫的方式差異在於：\n\n- `<MyComponent />`:\n\n  - Component 類型的 react component 有延遲執行的特性，\n    當程式碼執行到 `<MyComponent />` 會先告訴 react 這個父 component 有什麼結構，在 return 完成後會去 reconciler 觀察是否轉換成 DOM element，之後才會交給 renderer 去處理 DOM element。\n\n  - `<MyComponent />`在這裡的意義就是告訴 react 我想要在這裡產生一個 MyComponent 實例/ Fiber Node，但其實還沒有被呼叫，真正被呼叫是等父 component 建立 React element 後、描述完畫面才會進行呼叫子 component。\n\n- `MyComponent()`:\n\n  - React 會將它視為是一個普通的 function，當程式碼執行到 `MyComponent()` 會立即執行 `MyComponent()`。在 runtime 時 JavaScript engine 分辨不出來要建立一個 component 實例，只是會單純作為描述 React element 的表達式。\n  - React 並不會將 `MyComponent()` 視為 component，而且也不應該將 call `MyComponent()` 去呼叫 component，原因在於 component 能夠帶有 state 是因為 react 對 hook 加料，所以當以不正確的方式去呼叫 component 時，就不是在 React 機制底下運作，進而導致 hook 壞掉，產生難以追蹤的 bug。\n\n```jsx\nconst MyComponent = () => {\n  return (\n    <div>\n      <h1>Hello World</h1>\n    </div>\n  );\n};\n\nfunction App() {\n  return (\n    <main>\n      {MyComponent()}\n      <MyComponent />\n    </main>\n  );\n}\n\nexport default App;\n```\n\n上方的程式碼其實就等同於：\n\n```jsx\nfunction App() {\n  return (\n    <main>\n      {\n        <div>\n          <h1>Hello World</h1>\n        </div>\n      }\n      <MyComponent />\n    </main>\n  );\n}\n\nexport default App;\n```\n\n### React 延遲呼叫特性\n\n一定要使用 `React.createElement()` 產生 component 才能要求 react 去延遲呼叫 component function 和產生 component 實例，延遲呼叫的好處是可以在內容未更動的情況下避免 re-render。\n\n將子 component 定義在 父 component 的外部並且使用 `{}` 的方式呼叫，當父 component 因狀態更新而 re-render 時，子 component 會因被 react 判斷為同一個 component 所以不會重新 render。\n例子：\n\n<CodeSandbox codeSandboxId=\"all-compoent-m36qz8?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clvdx88xq00063b6jopw379v7%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clvdx88xq00023b6jgabzj7lc%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clvdx88xq00033b6j335wgwcz%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clvdx88xq00053b6jnfsof8pq%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clvdx88xq00023b6jgabzj7lc%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvdx88xp00013b6jgryjlq92%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.js%2522%257D%255D%252C%2522id%2522%253A%2522clvdx88xq00023b6jgabzj7lc%2522%252C%2522activeTabId%2522%253A%2522clvdx88xp00013b6jgryjlq92%2522%257D%252C%2522clvdx88xq00053b6jnfsof8pq%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvdx88xq00043b6j6s1i1d8u%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clvdx88xq00053b6jnfsof8pq%2522%252C%2522activeTabId%2522%253A%2522clvdx88xq00043b6j6s1i1d8u%2522%257D%252C%2522clvdx88xq00033b6j335wgwcz%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clvdx88xq00033b6j335wgwcz%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D\" />\n\n從中可以發現 App component 因為點擊的 button 而更新了 count 的 state，資料驅動畫面更新，在執行到 `{Child}` 的時候 ChildComponent 並不會跟著 re-render，接著執行至 `<ChildComponent />` ChildComponent 就會進行 re-render 重新建立一個 React element ，這是因為即使 `<ChildComponent />` 長相一樣，但其時它們的 reference 是不同的，所以 react 會判斷為不同的 component。\n\n### React 如何判斷是不是一個 component 實例\n\n在上方曾提到過負責轉譯 jsx 的 transpiler 是透過首字母的大寫去判斷 component function ，但是對於 React 來說，React 則是透過呼叫方式來判斷，首字母的大小寫定義對 React 來說並沒有意義。\n\n```js\nconst foo = () => {\n  return <div />;\n};\n```\n\n使用 `React.createElement `方法來呼叫 `foo` ，會被 React 視為是一個 component 實例。但是不能被放在 JSX 語法中，因為 transpiler 會將其視為是一個字串，試圖轉換成 DOM element。\n\n所以 React 判斷為一個 component 實例的方式是一定要透過 React element 的方式呼叫 component function。ex: `<Component/>`。使用 React element 呼叫才能讓 react 去 `React.createElement `方法產生 component 實例達成延遲呼叫的特性，可以從 component 實例取出資料並且讓 hook 正常運作，另外也可以藉由 React 內建的優化機制檢查在兩次 render 過程中是否為同一個 component 類型，近而減少避免不必要的 re-render。\n","createdAt":"2025-08-16T08:43:55.571Z","updatedAt":"2025-08-16T08:43:55.571Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":116,"data":{"documentId":"cwkfmwxq00vbpq0pmigbem38","slug":"07-component","title":"07-畫面組裝的藍圖：component 初探","date":"2025-08-16T08:43:55.566Z","description":"","content":"import CodeSandbox from \"../../../src/components/mdx/CodeSandbox.jsx\";\n\n## component\n\n簡單來說就是畫面的藍圖，component 就是由開發者自行定義好的商業邏輯、特定的樣式、React Element 畫面所組成的，就如同蓋房子一樣，如果說應用程式是一棟房子，那麼 component 就是搭建成房子的不同建材：鋼筋、水泥、磚頭...，透過組合這些 component 而逐步組成應用程式的畫面，同時 component 是可以重複使用的，讓程式碼變得更容易維護與管理。\n\n例如：設計一個 TodoList 的應用程式，可以將 TodoList 拆分成由多個 `<TodoItem />` 元件所組成的 `<TodoList/>` 元件，雖然 `<TodoItem />`這個元件是重用的，但每一個 `<TodoItem />` 都有其各自的元件狀態。\n\n```jsx title=\"TodoItem.jsx\"\nconst TodoItem = ({ todo }) => {\n  return <li>{todo}</li>;\n};\n```\n\n```jsx title=\"TodoList.jsx\"\nconst TodoList = () => {\n  const todos = [\"Todo 1\", \"Todo 2\", \"Todo 3\"];\n  return (\n    <div>\n      <h1>Todo List</h1>\n      <ul>\n        {todos.map((todo, index) => (\n          <TodoItem key={`${todo}-${index}`} todo={todo} />\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\n## props？ 為什麼 props 是唯讀的？\n\nprops 指的就是呼叫 component 時會傳入 component 的屬性，而 props 的資料型別在 React 中沒有任何限制。當 component 接收到從外部傳入的 props 後，就可以根據 props 去產生相對應的客製化的畫面或是商業邏輯。\n\n```jsx title=\"TodoItem.jsx\"\n// highlight-next-line\nconst TodoItem = ({ title, isDone }) => {\n  //將接收到的 props 使用解構取出屬性資料，這樣也就可以賦值到區域變數中\n  return(\n    <li>\n      <input type='checkbox' id={title} name={title} checked={isDone} />\n      <label htmlFor={title}>{title}</label>\n    </li>;\n  )\n};\n```\n\n```jsx title=\"TodoList.jsx\"\nconst TodoList = () => {\n  const todos = [\n    {\n      title: \"Todo 1\",\n      isDone: false,\n    },\n    {\n      title: \"Todo 2\",\n      isDone: true,\n    },\n    {\n      title: \"Todo 3\",\n      isDone: false,\n    },\n  ];\n  return (\n    <div>\n      <h1>Todo List</h1>\n      <ul>\n        {todos.map((todo, index) => (\n          <TodoItem\n            key={`${todo}-${index}`}\n            // highlight-start\n            title={todo.title} //將 title 屬性傳入 <TodoItem/>\n            isDone={todo.isDone} //將 isDone 屬性傳入 <TodoItem/>\n            // highlight-end\n          />\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\nprops 的特性是唯讀的，這是因為 React 的核心概念是單向資料流，所以當資料以 props 屬性傳遞到 components 內部時，為了確保資料的源頭與可追蹤性，以維持單向資料流的特性，所以 props 是不可以被修改的，因為當 props 被手動修改時，我們就無法確定資料的來源是從哪裡來的，也可能會出現無法預期的錯誤。\n\n## component 的 render 與 re-render\n\ncomponent 的一次 render 指的是 react 呼叫 component function 後產生描述一段畫面的 React Element 的結果。又 react virtual dom 為樹狀資料結構，當父 component 中包含一個或是多個子 component 時，當父 component render 時，其所包含的子 component 就會跟著進行一次的 render ，將所 render 完成的 react element 裝回上一層的父 component 上，整個過程是由上而下，會一直持續遍歷到最底層的 component，最後會拼裝成一個完整樹狀結構的 react element。\n\nre-render 則指的是當 component 的 props 或 state 資料發生變化時，react 會重新呼叫 component function 並重新 render 一次，會根據新的原始資料重新產生一份新的 react element，並透過 diff 演算法比對新舊的 react element，找出差異的部分，最後再進行 DOM 更新。\n\n### re-render 的時機點：\n\n1. component 本身 `setState` 更新資料\n2. 父層 component 資料更新傳入子 component\n3. Content provider 的 component 更新時\n\n## 為什麼 component 命名中的首字母必須為大寫？\n\n原是負責轉譯 react jsx transpiler 的 babel 會去根據首字母的大小寫去決定要轉譯成哪一種標籤類型。\n\n- 首字母為小寫： transpiler 會將其當作是字串並且傳入 `React.createElement()`方法作為第一個參數，ex: `React.createElement('div')`。最後取得實際相對的 DOM 元素。\n\n- 首字母為大寫： transpiler 會將其當作是變數名稱，會判斷為 component function 並且傳入 `React.createElement()`方法作為第一個參數，ex: `React.createElement(Hello)`。最後取得一段描述畫面的 React Element。\n\n## 正確呼叫 component 的方式\n\n有一個 component function 如下：\n\n```jsx\nfunction MyComponent() {\n  return <h1>Hello!</h1>;\n}\n```\n\n`<MyComponent />` 和 `{ MyComponent() }`有什麼差異？\n\n```jsx\nconst element1 = <MyComponent />;\nconsole.log(element1); //印出來會是 <MyComponent />;\n```\n\n當 `const element1 = <MyComponent />;` 這行被執行完成後，`MyComponent` component function 其實還沒有被呼叫到。\n\n```jsx\nconst element1 = <MyComponent />;\nconst element2 = MyComponent();\nconsole.log(\"element1\", element1);\nconsole.log(\"element2\", element2);\n```\n\n1. `<MyComponent />`\n\n```jsx\nconst element1 = <MyComponent />;\nconsole.log(\"element1\", element1);\n```\n\n![](./element1.png)\n\n2. `{MyComponent()}`\n\n```jsx\nconst element2 = MyComponent();\nconsole.log(\"element2\", element2);\n```\n\n![](./element2.png)\n\n這兩者種呼叫的方式差異在於：\n\n- `<MyComponent />`:\n\n  - Component 類型的 react component 有延遲執行的特性，\n    當程式碼執行到 `<MyComponent />` 會先告訴 react 這個父 component 有什麼結構，在 return 完成後會去 reconciler 觀察是否轉換成 DOM element，之後才會交給 renderer 去處理 DOM element。\n\n  - `<MyComponent />`在這裡的意義就是告訴 react 我想要在這裡產生一個 MyComponent 實例/ Fiber Node，但其實還沒有被呼叫，真正被呼叫是等父 component 建立 React element 後、描述完畫面才會進行呼叫子 component。\n\n- `MyComponent()`:\n\n  - React 會將它視為是一個普通的 function，當程式碼執行到 `MyComponent()` 會立即執行 `MyComponent()`。在 runtime 時 JavaScript engine 分辨不出來要建立一個 component 實例，只是會單純作為描述 React element 的表達式。\n  - React 並不會將 `MyComponent()` 視為 component，而且也不應該將 call `MyComponent()` 去呼叫 component，原因在於 component 能夠帶有 state 是因為 react 對 hook 加料，所以當以不正確的方式去呼叫 component 時，就不是在 React 機制底下運作，進而導致 hook 壞掉，產生難以追蹤的 bug。\n\n```jsx\nconst MyComponent = () => {\n  return (\n    <div>\n      <h1>Hello World</h1>\n    </div>\n  );\n};\n\nfunction App() {\n  return (\n    <main>\n      {MyComponent()}\n      <MyComponent />\n    </main>\n  );\n}\n\nexport default App;\n```\n\n上方的程式碼其實就等同於：\n\n```jsx\nfunction App() {\n  return (\n    <main>\n      {\n        <div>\n          <h1>Hello World</h1>\n        </div>\n      }\n      <MyComponent />\n    </main>\n  );\n}\n\nexport default App;\n```\n\n### React 延遲呼叫特性\n\n一定要使用 `React.createElement()` 產生 component 才能要求 react 去延遲呼叫 component function 和產生 component 實例，延遲呼叫的好處是可以在內容未更動的情況下避免 re-render。\n\n將子 component 定義在 父 component 的外部並且使用 `{}` 的方式呼叫，當父 component 因狀態更新而 re-render 時，子 component 會因被 react 判斷為同一個 component 所以不會重新 render。\n例子：\n\n<CodeSandbox codeSandboxId=\"all-compoent-m36qz8?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clvdx88xq00063b6jopw379v7%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clvdx88xq00023b6jgabzj7lc%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clvdx88xq00033b6j335wgwcz%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clvdx88xq00053b6jnfsof8pq%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clvdx88xq00023b6jgabzj7lc%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvdx88xp00013b6jgryjlq92%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.js%2522%257D%255D%252C%2522id%2522%253A%2522clvdx88xq00023b6jgabzj7lc%2522%252C%2522activeTabId%2522%253A%2522clvdx88xp00013b6jgryjlq92%2522%257D%252C%2522clvdx88xq00053b6jnfsof8pq%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvdx88xq00043b6j6s1i1d8u%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clvdx88xq00053b6jnfsof8pq%2522%252C%2522activeTabId%2522%253A%2522clvdx88xq00043b6j6s1i1d8u%2522%257D%252C%2522clvdx88xq00033b6j335wgwcz%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clvdx88xq00033b6j335wgwcz%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D\" />\n\n從中可以發現 App component 因為點擊的 button 而更新了 count 的 state，資料驅動畫面更新，在執行到 `{Child}` 的時候 ChildComponent 並不會跟著 re-render，接著執行至 `<ChildComponent />` ChildComponent 就會進行 re-render 重新建立一個 React element ，這是因為即使 `<ChildComponent />` 長相一樣，但其時它們的 reference 是不同的，所以 react 會判斷為不同的 component。\n\n### React 如何判斷是不是一個 component 實例\n\n在上方曾提到過負責轉譯 jsx 的 transpiler 是透過首字母的大寫去判斷 component function ，但是對於 React 來說，React 則是透過呼叫方式來判斷，首字母的大小寫定義對 React 來說並沒有意義。\n\n```js\nconst foo = () => {\n  return <div />;\n};\n```\n\n使用 `React.createElement `方法來呼叫 `foo` ，會被 React 視為是一個 component 實例。但是不能被放在 JSX 語法中，因為 transpiler 會將其視為是一個字串，試圖轉換成 DOM element。\n\n所以 React 判斷為一個 component 實例的方式是一定要透過 React element 的方式呼叫 component function。ex: `<Component/>`。使用 React element 呼叫才能讓 react 去 `React.createElement `方法產生 component 實例達成延遲呼叫的特性，可以從 component 實例取出資料並且讓 hook 正常運作，另外也可以藉由 React 內建的優化機制檢查在兩次 render 過程中是否為同一個 component 類型，近而減少避免不必要的 re-render。\n","createdAt":"2025-08-16T08:43:55.571Z","updatedAt":"2025-08-16T08:43:55.571Z","publishedAt":"2025-08-16T08:43:55.572Z","locale":null,"author":null}}
{"type":"api::post.post","id":117,"data":{"documentId":"dkxzgjyyq5fki2hn0xjdp6et","slug":"08-react-state","title":"08-React 畫面更新的發動機－state 初探","date":"2025-08-16T08:43:55.580Z","description":"","content":"## React state 的本質？ state 在 React 的畫面管理機制中扮演的角色是什麼？\n\nstate 是一種臨時的且可以用來更新記憶應用程式的狀態。在 React 的畫面管理機制中，React 藉由發現 state 的資料更新，去驅動畫面跟著 state 的變動完成相對應的更新。\n\n在 React 單向資料流的機制中，原始資料的 state 是驅動初始畫面渲染完成的成因，可以更新的原始資料 state 就是作為 React 更新畫面的變因，是執行單向資料流的手段，使資料的變動與畫面更新是可靠且更容易預測的。\n\n## state 跟 component 的關係是什麼？\n\ncomponent 可以說是 state 的容器，每一個 component 都有自己的 state，而 state 必須依附在 component 上去記憶原始資料的狀態，當 component 中的 state 資料更新的時候就會重新渲染畫面，該 component 與其中的子孫 component 也會跟著重繪、re-render，因此 component 也有限縮畫面重繪的範圍的功能。\n\n在 function component 中，state 使用 `useState` 這個 hook 來定義與存取 state 資料。\n\n## 為什麼 `useState` 的回傳值是一個陣列？\n\n```jsx\nconst [state, setState] = useState(initialState);\n```\n\n`useState` hook 會接受一個初始值 `initialState` 作為 state 的原始資料，並且會回傳一組陣列，在陣列中第一個元素 `state` 指的是此次 render 當前的值，第二個元素 `setState` 是一個函式，用來更新 `state` 的值。\n\n使用陣列解構可以讓開發者更容易取得與便於讓開發者根據商業邏輯自行命名 state 與 setState 函式並且賦值，如此一來，當 component 中有多個 state 時，開發者可以更容易區分與管理，避免命名衝突。\n\n## React 是如何辨識並區分同一個 component 中的多個 state？\n\n在同一個 component 中，有可能同時進行呼叫多次 `useState` hook 來定義多個 state，React 透過固定的呼叫順序來區分，因此在 hook 就會有嚴格的呼叫限制：hook 只能在 function component 的最上層呼叫，不能在條件式、迴圈、巢狀 function component 中呼叫。\n\nReact 內建的機制會存在一個有序的表去根據這些 hook 的呼叫順序去紀錄 hook 的狀態，因此當 component 執行一次 render 時就會依據順序去取得對應的 state 資料。\n\n## 同一個 component 在多個地方被呼叫，它們之間的 state 資料會互通嗎？為什麼？\n\n即使是同一個 component，當其在不同地方被呼叫到就會產一個新的 component 實例，雖然長相類似但其實是不同的個體，在 component 中 state 資料也會是獨立的，因此不會互通。\n","createdAt":"2025-08-16T08:43:55.584Z","updatedAt":"2025-08-16T08:43:55.584Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":118,"data":{"documentId":"dkxzgjyyq5fki2hn0xjdp6et","slug":"08-react-state","title":"08-React 畫面更新的發動機－state 初探","date":"2025-08-16T08:43:55.580Z","description":"","content":"## React state 的本質？ state 在 React 的畫面管理機制中扮演的角色是什麼？\n\nstate 是一種臨時的且可以用來更新記憶應用程式的狀態。在 React 的畫面管理機制中，React 藉由發現 state 的資料更新，去驅動畫面跟著 state 的變動完成相對應的更新。\n\n在 React 單向資料流的機制中，原始資料的 state 是驅動初始畫面渲染完成的成因，可以更新的原始資料 state 就是作為 React 更新畫面的變因，是執行單向資料流的手段，使資料的變動與畫面更新是可靠且更容易預測的。\n\n## state 跟 component 的關係是什麼？\n\ncomponent 可以說是 state 的容器，每一個 component 都有自己的 state，而 state 必須依附在 component 上去記憶原始資料的狀態，當 component 中的 state 資料更新的時候就會重新渲染畫面，該 component 與其中的子孫 component 也會跟著重繪、re-render，因此 component 也有限縮畫面重繪的範圍的功能。\n\n在 function component 中，state 使用 `useState` 這個 hook 來定義與存取 state 資料。\n\n## 為什麼 `useState` 的回傳值是一個陣列？\n\n```jsx\nconst [state, setState] = useState(initialState);\n```\n\n`useState` hook 會接受一個初始值 `initialState` 作為 state 的原始資料，並且會回傳一組陣列，在陣列中第一個元素 `state` 指的是此次 render 當前的值，第二個元素 `setState` 是一個函式，用來更新 `state` 的值。\n\n使用陣列解構可以讓開發者更容易取得與便於讓開發者根據商業邏輯自行命名 state 與 setState 函式並且賦值，如此一來，當 component 中有多個 state 時，開發者可以更容易區分與管理，避免命名衝突。\n\n## React 是如何辨識並區分同一個 component 中的多個 state？\n\n在同一個 component 中，有可能同時進行呼叫多次 `useState` hook 來定義多個 state，React 透過固定的呼叫順序來區分，因此在 hook 就會有嚴格的呼叫限制：hook 只能在 function component 的最上層呼叫，不能在條件式、迴圈、巢狀 function component 中呼叫。\n\nReact 內建的機制會存在一個有序的表去根據這些 hook 的呼叫順序去紀錄 hook 的狀態，因此當 component 執行一次 render 時就會依據順序去取得對應的 state 資料。\n\n## 同一個 component 在多個地方被呼叫，它們之間的 state 資料會互通嗎？為什麼？\n\n即使是同一個 component，當其在不同地方被呼叫到就會產一個新的 component 實例，雖然長相類似但其實是不同的個體，在 component 中 state 資料也會是獨立的，因此不會互通。\n","createdAt":"2025-08-16T08:43:55.584Z","updatedAt":"2025-08-16T08:43:55.584Z","publishedAt":"2025-08-16T08:43:55.586Z","locale":null,"author":null}}
{"type":"api::post.post","id":119,"data":{"documentId":"jeak9qszvhk56u45t8ysrs2d","slug":"reconciliation","title":"React 畫面更新的流程機制：reconcilliation","date":"2025-08-16T08:43:55.594Z","description":"在 component 畫面管理機制中， component 的渲染機制可以分成兩個階段，分別是 render phase 和 commit phase。 Render phase 在 Render 階段，component 會進行渲染，並且產生 react element。 Commit phase 在 Commit 階段，component 會把產生的 react element 畫面結構提交並處理到實際的瀏覽器 DOM 上面。","content":"\n在 component 畫面管理機制中， component 的渲染機制可以分成兩個階段，分別是 render phase 和 commit phase。\n\n## Render phase\n\n在 Render 階段，component 會進行渲染，並且產生 react element。\n\n## Commit phase\n\n在 Commit 階段，component 會把產生的 react element 畫面結構提交並處理到實際的瀏覽器 DOM 上面。\n\n### 第一次 render component\n\n#### Render phase\n\n1. 執行 component function 產生以 props 和 state 描述 component 畫面的 react element。\n2. 接著將生成的 react element 交到 Commit phase 處理。\n\n#### Commit phase\n\n1. mount:\n   這時由於是第一次 render，因此瀏覽器中並沒有 component 相對應的 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。\n2. mounted:\n   使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器。\n\n### re-render component\n\n#### Render phase\n\n1. 執行 component function 以新版本的 props 和 state 產生描述 component 畫面的 react element。\n2. 將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異。\n3. 將差異的部分交到 Commit phase 處理。\n\n#### Commit phase\n\n1. 只操作新舊 react element 差異所對應的 DOM element。\n\n## React reconciliation\n\n當呼叫 `setState` 後會發起 component re-render，React 會啟動 reconciliation 流程，最終更新瀏覽器的 DOM 並反映在畫面上。這個過程分為兩個主要階段：Render phase 和 Commit phase。component 內的子孫 component 也會連帶觸發 re-render：\n\n1. 呼叫 `setState` 更新資料\n   當呼叫 `setState` 時，React 並不會立即更新狀態。`setState` 是一個非同步操作，React 會將這個狀態更新加入一個任務隊列中，並且會自動將多個 `setState` 操作合併進行批次更新（batch update）。\n\n2. 檢查 state 是否有變化\n   React 會執行 [Object.is()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)，檢查 state 新舊資料是否有變化。\n   - 如果沒有變化，代表資料沒有更新也就不需要更新畫面，接下來的流程就會中斷。\n   - 如果有變化，就是資料有更新，接著就會進行 re-render。\n\n### Render phase\n\n3. 重新執行 Component function\n   re-render 會執行 component function 並以新版本的 props 和 state 產生新的 react element。\n4. Diffing\n   接著，react 會將前一份產生的舊版 react element 與新版 react element 使用 diffing 演算法來找出樹狀結構差異之處。\n\n### Commit phase\n\n5. 更新 DOM\n   比較完成後，根據差異的的部分所對應的 DOM element 進行操作， 這個更新過程會在瀏覽器的主執行緒上進行，包括更新 DOM 樹和應用 CSS 樣式，最後更新到瀏覽器 DOM 上。\n\n## `Object.is()` 拿掉會影響 reconciliation 嗎？\n\n並不會，`Object.is()`就只是個讓效能優化、減少 re-render 的檢查機制，沒有使用 `Object.is()` 檢查 state 就是直接讓 component 直接進行 re-render。\n","createdAt":"2025-08-16T08:43:55.619Z","updatedAt":"2025-08-16T10:25:15.178Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":121,"data":{"documentId":"qrar8k9aez765rmoww3xssoa","slug":"10-component-componet","title":"10-如何在子 component 裡觸發更新 父 componet 的資料","date":"2025-08-16T08:43:55.630Z","description":"","content":"## 為什麼 React 並沒有也不需要子 component 向上溝通父 component 的專門機制？\n\nReact 的核心概念就是單向資料流，資料只能由上而下傳遞，不需要有子 component 向上溝通父 component 的專門機制的原因在於：\n\n1. `setState` 的函式可以透過 props 傳遞至子 component 。\n\n2. 呼叫 `setState` 函式更新 state 資料和觸發 re-render component 是固定的，因為在子 component 呼叫由父 component 傳下來的 `setState` 就會去更新父 component 的 state，當 state 更新就會 re-render 父 component。\n\n3. 父 component 的 state 資料更新時，React 就會根據新版本的 props 去 re-render 子 component。\n\n基於以上三個 React 的特性就足以達成這個目的，因此 React 並沒有也不需要子 component 向上溝通父 component 的專門機制。\n\n## 如何在子 component 裡觸發更新父 component 資料？\n\n利用 props 將父 component 的 `setState` 方法傳遞給子 component，子 component 接收到`setState` 方法便可以在需要的時候去呼叫這個方法，進而更新父 component 的資料，當父 component 的資料更新時，React 就會 re-render 子 component。\n","createdAt":"2025-08-16T08:43:55.634Z","updatedAt":"2025-08-16T08:43:55.634Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":122,"data":{"documentId":"qrar8k9aez765rmoww3xssoa","slug":"10-component-componet","title":"10-如何在子 component 裡觸發更新 父 componet 的資料","date":"2025-08-16T08:43:55.630Z","description":"","content":"## 為什麼 React 並沒有也不需要子 component 向上溝通父 component 的專門機制？\n\nReact 的核心概念就是單向資料流，資料只能由上而下傳遞，不需要有子 component 向上溝通父 component 的專門機制的原因在於：\n\n1. `setState` 的函式可以透過 props 傳遞至子 component 。\n\n2. 呼叫 `setState` 函式更新 state 資料和觸發 re-render component 是固定的，因為在子 component 呼叫由父 component 傳下來的 `setState` 就會去更新父 component 的 state，當 state 更新就會 re-render 父 component。\n\n3. 父 component 的 state 資料更新時，React 就會根據新版本的 props 去 re-render 子 component。\n\n基於以上三個 React 的特性就足以達成這個目的，因此 React 並沒有也不需要子 component 向上溝通父 component 的專門機制。\n\n## 如何在子 component 裡觸發更新父 component 資料？\n\n利用 props 將父 component 的 `setState` 方法傳遞給子 component，子 component 接收到`setState` 方法便可以在需要的時候去呼叫這個方法，進而更新父 component 的資料，當父 component 的資料更新時，React 就會 re-render 子 component。\n","createdAt":"2025-08-16T08:43:55.634Z","updatedAt":"2025-08-16T08:43:55.634Z","publishedAt":"2025-08-16T08:43:55.635Z","locale":null,"author":null}}
{"type":"api::post.post","id":123,"data":{"documentId":"otepfp3q7qsqux9j8r6bldjy","slug":"11-batch-update-updater-function","title":"11.深入理解 batch update 與 updater function","date":"2025-08-16T08:43:55.642Z","description":"","content":"import CodeSandbox from \"../../../src/components/mdx/CodeSandbox.jsx\";\n\n## batch update\n\n`setState` 的資料更新後會觸發 component re-render，react 會在將所有執行的事件完成後，才會進行 re-render。\n\n<CodeSandbox codeSandboxId=\"batch-update-sglxr9?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clvnk1xmq00063b6jb3oifd5y%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clvnk1xmq00023b6juqyzn2kd%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clvnk1xmq00033b6jwvh3ib50%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clvnk1xmq00053b6jx8mem72v%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clvnk1xmq00023b6juqyzn2kd%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvnk1xmq00013b6jjcsksb5f%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.js%2522%257D%255D%252C%2522id%2522%253A%2522clvnk1xmq00023b6juqyzn2kd%2522%252C%2522activeTabId%2522%253A%2522clvnk1xmq00013b6jjcsksb5f%2522%257D%252C%2522clvnk1xmq00053b6jx8mem72v%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvnk1xmq00043b6jxhtib4qx%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clvnk1xmq00053b6jx8mem72v%2522%252C%2522activeTabId%2522%253A%2522clvnk1xmq00043b6jxhtib4qx%2522%257D%252C%2522clvnk1xmq00033b6jwvh3ib50%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clvnk1xmq00033b6jwvh3ib50%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D\" />\n\n在上面的例子中：\n\n1. react 執行 App compoent function 後會產生描述畫面的 React element ，並將這個 React element 產生相對應的 DOM element 渲染到瀏覽器上。\n\n2. 在 App component 中初始的 count state 是 0 ,clickCount state 是 0\n\n3. 當點擊 button 後會去執行 `handleClick` function\n\n4. - 當執行到 `setCount(1)`時，react 會將這個更新的動作依照順序放到一個代執行計算佇列 (queue)中\n\n   - 此時的佇列依序由舊至新有：`setCount(1)`\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n5. - 當執行到 `setCount(3)`時，react 會將這個更新的動作放到佇列 (queue)中\n\n   - 此時的佇列由舊至新依序有：`setCount(1)`、`setCount(3)`\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n6. - 當執行到 `setCount(5)`時，react 會將這個更新的動作放到佇列 (queue)中\n\n   - 此時的佇列由舊至新依序有：`setCount(1)`、`setCount(3)`、`setCount(5)`\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n7. - 當執行到 `setClickCount((clickCount) => clickCount + 1)`時，react 會將這個更新的動作放到佇列 (queue)中\n\n   - 此時的佇列由舊至新依序有：`setCount(1)`、`setCount(3)`、`setCount(5)`、setClickCount((clickCount) => clickCount + 1)\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n8. - 執行完所有的事件後，react 會依照最新佇列的順序自動合併相同的 `setState` 方法，並且只執行最後一次的 `setState` 方法，\n\n   - 此時 count 的值為 5，\n   - 此時 clickCount 的值為 1\n\n9. 更新 state 後才會進行一次 re-render。\n\nbatch update 的機制就是 React 會自動將所有的 `setState` 方法依序合併成一次更新，藉此可以省去每更新一次 state 就進行一次 re-render 的效能問題，也可以避免半成品的資料進行 render。\n\n## `flushSync` api\n\n大多數的情況下 react 都會自動幫我們處理好 `setState` 合併更新資料，但如果想要針對某些狀態需要當下就觀察到 DOM element 就可以使用 `flushSync` 方法，`flushSync` 可以指定某些 `setState` 方法不要 batch update，而是立刻 re-render。\n\n但是使用 `flushSync` 需要注意的是 `flushSync` blocking 的，如果 DOM 處理太久會阻擋後續的畫面更新繼續進行，可能會造成畫面卡頓。\n\n## updater function\n\nupdater function 可以作為參數傳入 `setState` 方法。\n\n    ```jsx\n    const [count, setCount] = useState(0);\n    const handleClick = () => {\n        //highlight-next-line\n      setCount((prevCount) => prevCount + 1);\n       //(prevCount) => prevCount + 1 就是 updater function\n    };\n    ```\n\n在這個例子中，updater function 會讓 `setCount` 根據到目前為止的 `count` 值 prevCount 去計算產生新的 `count` 值。\n\n### 需要使用 updater function 的情境\n\n- 需要拿到當下 state 持續做計算\n- 可以在子元件中直接去拿到 state 的值\n","createdAt":"2025-08-16T08:43:55.647Z","updatedAt":"2025-08-16T08:43:55.647Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":124,"data":{"documentId":"otepfp3q7qsqux9j8r6bldjy","slug":"11-batch-update-updater-function","title":"11.深入理解 batch update 與 updater function","date":"2025-08-16T08:43:55.642Z","description":"","content":"import CodeSandbox from \"../../../src/components/mdx/CodeSandbox.jsx\";\n\n## batch update\n\n`setState` 的資料更新後會觸發 component re-render，react 會在將所有執行的事件完成後，才會進行 re-render。\n\n<CodeSandbox codeSandboxId=\"batch-update-sglxr9?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clvnk1xmq00063b6jb3oifd5y%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clvnk1xmq00023b6juqyzn2kd%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clvnk1xmq00033b6jwvh3ib50%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clvnk1xmq00053b6jx8mem72v%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clvnk1xmq00023b6juqyzn2kd%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvnk1xmq00013b6jjcsksb5f%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.js%2522%257D%255D%252C%2522id%2522%253A%2522clvnk1xmq00023b6juqyzn2kd%2522%252C%2522activeTabId%2522%253A%2522clvnk1xmq00013b6jjcsksb5f%2522%257D%252C%2522clvnk1xmq00053b6jx8mem72v%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvnk1xmq00043b6jxhtib4qx%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clvnk1xmq00053b6jx8mem72v%2522%252C%2522activeTabId%2522%253A%2522clvnk1xmq00043b6jxhtib4qx%2522%257D%252C%2522clvnk1xmq00033b6jwvh3ib50%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clvnk1xmq00033b6jwvh3ib50%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D\" />\n\n在上面的例子中：\n\n1. react 執行 App compoent function 後會產生描述畫面的 React element ，並將這個 React element 產生相對應的 DOM element 渲染到瀏覽器上。\n\n2. 在 App component 中初始的 count state 是 0 ,clickCount state 是 0\n\n3. 當點擊 button 後會去執行 `handleClick` function\n\n4. - 當執行到 `setCount(1)`時，react 會將這個更新的動作依照順序放到一個代執行計算佇列 (queue)中\n\n   - 此時的佇列依序由舊至新有：`setCount(1)`\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n5. - 當執行到 `setCount(3)`時，react 會將這個更新的動作放到佇列 (queue)中\n\n   - 此時的佇列由舊至新依序有：`setCount(1)`、`setCount(3)`\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n6. - 當執行到 `setCount(5)`時，react 會將這個更新的動作放到佇列 (queue)中\n\n   - 此時的佇列由舊至新依序有：`setCount(1)`、`setCount(3)`、`setCount(5)`\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n7. - 當執行到 `setClickCount((clickCount) => clickCount + 1)`時，react 會將這個更新的動作放到佇列 (queue)中\n\n   - 此時的佇列由舊至新依序有：`setCount(1)`、`setCount(3)`、`setCount(5)`、setClickCount((clickCount) => clickCount + 1)\n   - 此時 count 的值為 0\n   - 此時 clickCount 的值為 0\n\n8. - 執行完所有的事件後，react 會依照最新佇列的順序自動合併相同的 `setState` 方法，並且只執行最後一次的 `setState` 方法，\n\n   - 此時 count 的值為 5，\n   - 此時 clickCount 的值為 1\n\n9. 更新 state 後才會進行一次 re-render。\n\nbatch update 的機制就是 React 會自動將所有的 `setState` 方法依序合併成一次更新，藉此可以省去每更新一次 state 就進行一次 re-render 的效能問題，也可以避免半成品的資料進行 render。\n\n## `flushSync` api\n\n大多數的情況下 react 都會自動幫我們處理好 `setState` 合併更新資料，但如果想要針對某些狀態需要當下就觀察到 DOM element 就可以使用 `flushSync` 方法，`flushSync` 可以指定某些 `setState` 方法不要 batch update，而是立刻 re-render。\n\n但是使用 `flushSync` 需要注意的是 `flushSync` blocking 的，如果 DOM 處理太久會阻擋後續的畫面更新繼續進行，可能會造成畫面卡頓。\n\n## updater function\n\nupdater function 可以作為參數傳入 `setState` 方法。\n\n    ```jsx\n    const [count, setCount] = useState(0);\n    const handleClick = () => {\n        //highlight-next-line\n      setCount((prevCount) => prevCount + 1);\n       //(prevCount) => prevCount + 1 就是 updater function\n    };\n    ```\n\n在這個例子中，updater function 會讓 `setCount` 根據到目前為止的 `count` 值 prevCount 去計算產生新的 `count` 值。\n\n### 需要使用 updater function 的情境\n\n- 需要拿到當下 state 持續做計算\n- 可以在子元件中直接去拿到 state 的值\n","createdAt":"2025-08-16T08:43:55.647Z","updatedAt":"2025-08-16T08:43:55.647Z","publishedAt":"2025-08-16T08:43:55.648Z","locale":null,"author":null}}
{"type":"api::post.post","id":125,"data":{"documentId":"sdg7zvp7vtcsja600r91dt8e","slug":"12-react-immutable-state","title":"12-維持 React 資料流可靠性的關鍵：immutable state","date":"2025-08-16T08:43:55.655Z","description":"","content":"## JavaScript 的資料型別\n\n### 原始型別 primitive\n\n- number\n- string\n- boolean\n- null\n- undefined\n- symbol\n- bigint\n\n### 物件型別 object\n\n除了原始型別外，其他的都是物件型別，包含：物件和陣列\n\n### 原始型別與物件型別的差異\n\n|          | 原始型別       | 物件型別                 |\n| -------- | -------------- | ------------------------ |\n| 賦值     | 將值賦予至變數 | 將記憶體的位址賦予至變數 |\n| 增加屬性 | 不可以         | 可以                     |\n\n## mutable 與 immutable\n\n### immutable 不可變的\n\n指的就是資料被建立後就不可以被事後修改。\n\n原始型別的特性是 immutable，當值建立之後也會在記憶體中產生相對應的內容，而這個內容是不可以被修改的，所以當變數被重新賦值的時候，只能產生一個新的值取代舊的值，同時，變數會重新指向新的值。\n\n原始型別的值被賦予給其他變數時，是將值複製一份給新的變數，所以當新的變數被修改時，不會影響到原本的變數。\n\n### mutable 可變的\n\n物件型別在建立時會在記憶體中產生一個位址，變數就會指向這個位址 reference。\n\n物件本身的屬性內容是可以被修改的 mutable，對物件的屬性或是內容做修改的動作就是 mutate ，因為物件型別的資料是傳遞記憶體位址，所以當物件的內容被修改時，這個變數的 reference 並不會被修改，但是當物件型別被賦予給其他變數時，由於是將記憶體的位址複製一份給新的變數，所以當新的變數被修改時，會影響到原本的變數。\n\n## 必須在 React 中保持 state 資料的 immutable 的原因\n\nreact element 是某一次 render 畫面結構的歷史紀錄，是不可以被修改的，否則 React 資料流的可靠性就會被破壞，其核心機制也可能因此無法正常運作，基於這個原因，state 資料也是 component 某一次 render 的狀態資料，必須是 immutable 的。\n\n在 React 中，當呼叫 `setState` 方法更新 state 資料時，會透過 `Object.is()`，檢查物件或陣列的 reference 是否相同，完全不會去檢查新舊物件或陣列的資料內容是否相同，因此當 state 資料被 mutate 時，就會造成 React 無法正確判斷 state 資料是否有變化，\n\n在 state 被非同步的事件讀取時，也會需要保持 state 資料的 immutable，因為有可能需要根據過去render 的 state 歷史紀錄來做商業邏輯的判斷。\n\n必須保持 state 資料的 immutable 的另外一個原因是則是 react 效能優化機制仰賴檢查資料的 reference 是否相同作為判斷：\n\n- `useEffect`\n- `useMemo`\n- `useCallback`\n- `React.memo`\n\n如果直接 mutate 物件或陣列的 state 資料，就會造成這些 React 效能機制因即使 state 的內容改變了但 state 的 reference 沒有改變而做出錯誤的判斷，導致機制異常，進而影響 React 效能優化的效果。\n\n因此在 React 中如果我們要更新陣列或物件的 state 資料，必須確保新的 state 陣列或物件的 reference 是不同的，應該要產生一個符合資料內容的全新物件或陣列，而不是手動直接修改原始資料， reference 與前一次不同才能讓 React 正確判斷 state 資料是否有變化，進而正確的更新畫面。\n","createdAt":"2025-08-16T08:43:55.660Z","updatedAt":"2025-08-16T08:43:55.660Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":126,"data":{"documentId":"sdg7zvp7vtcsja600r91dt8e","slug":"12-react-immutable-state","title":"12-維持 React 資料流可靠性的關鍵：immutable state","date":"2025-08-16T08:43:55.655Z","description":"","content":"## JavaScript 的資料型別\n\n### 原始型別 primitive\n\n- number\n- string\n- boolean\n- null\n- undefined\n- symbol\n- bigint\n\n### 物件型別 object\n\n除了原始型別外，其他的都是物件型別，包含：物件和陣列\n\n### 原始型別與物件型別的差異\n\n|          | 原始型別       | 物件型別                 |\n| -------- | -------------- | ------------------------ |\n| 賦值     | 將值賦予至變數 | 將記憶體的位址賦予至變數 |\n| 增加屬性 | 不可以         | 可以                     |\n\n## mutable 與 immutable\n\n### immutable 不可變的\n\n指的就是資料被建立後就不可以被事後修改。\n\n原始型別的特性是 immutable，當值建立之後也會在記憶體中產生相對應的內容，而這個內容是不可以被修改的，所以當變數被重新賦值的時候，只能產生一個新的值取代舊的值，同時，變數會重新指向新的值。\n\n原始型別的值被賦予給其他變數時，是將值複製一份給新的變數，所以當新的變數被修改時，不會影響到原本的變數。\n\n### mutable 可變的\n\n物件型別在建立時會在記憶體中產生一個位址，變數就會指向這個位址 reference。\n\n物件本身的屬性內容是可以被修改的 mutable，對物件的屬性或是內容做修改的動作就是 mutate ，因為物件型別的資料是傳遞記憶體位址，所以當物件的內容被修改時，這個變數的 reference 並不會被修改，但是當物件型別被賦予給其他變數時，由於是將記憶體的位址複製一份給新的變數，所以當新的變數被修改時，會影響到原本的變數。\n\n## 必須在 React 中保持 state 資料的 immutable 的原因\n\nreact element 是某一次 render 畫面結構的歷史紀錄，是不可以被修改的，否則 React 資料流的可靠性就會被破壞，其核心機制也可能因此無法正常運作，基於這個原因，state 資料也是 component 某一次 render 的狀態資料，必須是 immutable 的。\n\n在 React 中，當呼叫 `setState` 方法更新 state 資料時，會透過 `Object.is()`，檢查物件或陣列的 reference 是否相同，完全不會去檢查新舊物件或陣列的資料內容是否相同，因此當 state 資料被 mutate 時，就會造成 React 無法正確判斷 state 資料是否有變化，\n\n在 state 被非同步的事件讀取時，也會需要保持 state 資料的 immutable，因為有可能需要根據過去render 的 state 歷史紀錄來做商業邏輯的判斷。\n\n必須保持 state 資料的 immutable 的另外一個原因是則是 react 效能優化機制仰賴檢查資料的 reference 是否相同作為判斷：\n\n- `useEffect`\n- `useMemo`\n- `useCallback`\n- `React.memo`\n\n如果直接 mutate 物件或陣列的 state 資料，就會造成這些 React 效能機制因即使 state 的內容改變了但 state 的 reference 沒有改變而做出錯誤的判斷，導致機制異常，進而影響 React 效能優化的效果。\n\n因此在 React 中如果我們要更新陣列或物件的 state 資料，必須確保新的 state 陣列或物件的 reference 是不同的，應該要產生一個符合資料內容的全新物件或陣列，而不是手動直接修改原始資料， reference 與前一次不同才能讓 React 正確判斷 state 資料是否有變化，進而正確的更新畫面。\n","createdAt":"2025-08-16T08:43:55.660Z","updatedAt":"2025-08-16T08:43:55.660Z","publishedAt":"2025-08-16T08:43:55.661Z","locale":null,"author":null}}
{"type":"api::post.post","id":127,"data":{"documentId":"mly51qqc3x8urq17lg7pysia","slug":"immutable-update","title":"Immutable update","date":"2025-08-16T08:43:55.668Z","description":"Shallow clone 與 deep clone 的區別 首先要講到 Javascript 「物件傳址」的特性，在 Javascript 中物件在建立的時候會將記憶體的位址賦予至變數上，常常有多個變數共用同一個位址，所以 mutate 其中一個物件的屬性的內容時，其他的變數也會受到影響，就是因為他們共用同一個記憶體位址。 Shallow clone Shallow clone 又稱淺複製，當想要將物件重新賦予至另外一個物件的時候又不想要修改其原始值，就可以使用 Shallow clone 將物件內第一層的屬性複製到另外一個 reference 上，這樣既原來的物件的 reference...","content":"\nimport CodeSandbox from \"../../../src/components/mdx/CodeSandbox.jsx\";\n\n## Shallow clone 與 deep clone 的區別\n\n首先要講到 Javascript 「物件傳址」的特性，在 Javascript 中物件在建立的時候會將記憶體的位址賦予至變數上，常常有多個變數共用同一個位址，所以 mutate 其中一個物件的屬性的內容時，其他的變數也會受到影響，就是因為他們共用同一個記憶體位址。\n\n## Shallow clone\n\nShallow clone 又稱淺複製，當想要將物件重新賦予至另外一個物件的時候又不想要修改其原始值，就可以使用 Shallow clone **將物件內第一層的屬性複製到另外一個 reference 上**，這樣既原來的物件的 reference 不同，也可以避免修改到原始物件的屬性。\n\n### Shallow clone 的方法\n\n#### [spread 語法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n\nconst copyBySpread = { ...memberInfo }; //使用 spread 語法複製物件 memberInfo\n\nconsole.log(\"copyBySpread === memberInfo\", copyBySpread === memberInfo); //false\n//可以確定 copyBySpread 與 memberInfo 這兩個物件的 reference 不同的\n\nconsole.log(\n  \"copyBySpread.hobbies === memberInfo.hobbies\",\n  copyBySpread.hobbies === memberInfo.hobbies,\n); //true\n\n//memberInfo 中的 hobbies 屬性是一個陣列，物件的比對 === 就是其記憶體的位址，\n//可以確定 copyBySpread 與 memberInfo 這兩個物件的 hobbies 這個屬性都是指向同一個 reference 的，\n//所以當修改 copyBySpread.hobbies 的內容時，也會影響到 memberInfo.hobbies 的內容。\n```\n\n那如果想要淺複製物件內巢狀的物件或物件可以這麼做：\n\n```js\nconst copyNestBySpread = {\n  ...memberInfo, //先淺複製 memberInfo 第一層的屬性\n  hobbies: [...memberInfo.hobbies], //在 copyNestBySpread 物件中新增 hobbies 屬性，然後將 memberInfo.hobbies 陣列淺複製到 copyNestBySpread.hobbies\n};\n\n//這時候再次檢查 copyNestBySpread.hobbies 與 memberInfo.hobbies 的 reference 是否相同\nconsole.log(\n  \"copyNestBySpread.hobbies === memberInfo.hobbies\",\n  copyNestBySpread.hobbies === memberInfo.hobbies,\n); //false\n// 這時候修改 copyNestBySpread.hobbies 的內容就不會影響到 memberInfo.hobbies 的內容\n```\n\n使用 spread 展開運算符的好處是語法相對簡潔，讓程式碼容易閱讀。\n\n#### [Object.assign()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n\nconst copyByAssign = Object.assign({}, memberInfo); ////使用 Object.assign() 複製物件 memberInfo\n\nconsole.log(\"copyByAssign === memberInfo\", copyByAssign === memberInfo); //false\n\nconsole.log(\n  \"copyByAssign.hobbies === memberInfo.hobbies\",\n  copyByAssign.hobbies === memberInfo.hobbies,\n); //true\n```\n\n## Deep clone\n\nDeep clone 又稱深複製，相對淺複製僅是將物件的第一層複製，深複製則是將物件的所有層級都複製一份，深複製當遇到巢狀物件或是陣列時，就會進行深層的遍歷，將每一次層的值都進行複製，如此一來複製出來的物件當被修改時就不會影響到原來的物件。\n\n### Deep clone 的方法\n\n#### `JSON.parse(JSON.stringify(...))`\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n\n//先將 memberInfo 物件轉換成 JSON 字串，再將 JSON 字串轉換成物件\nfunction deepCopy(item) {\n  return JSON.parse(JSON.stringify(item));\n}\n\nconst deepCopyByJSON = deepCopy(memberInfo);\n\nconsole.log(\"deepCopyByJSON === memberInfo\", deepCopyByJSON === memberInfo); //false\nconsole.log(\n  \"deepCopyByJSON.hobbies === memberInfo.hobbies\",\n  deepCopyByJSON.hobbies === memberInfo.hobbies,\n); //false\n```\n\n但是使用 `JSON.parse(JSON.stringify(...))` 進行深複製時，如果物件內的屬性有不可以序列化的值，就會導致深複製失敗。ex: `undefined`、`function`、`symbol`、`BigInt`、`Date`、`RegExp`、`Error`、`Map`、`Set`\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n  getMoreInfo: function getMoreInfo() {\n    return null;\n  },\n  createdTime: new Date(\"2024-06-10\"),\n};\n\nfunction deepCopy(item) {\n  return JSON.parse(JSON.stringify(item));\n}\n\nconst deepCopyByJSON = deepCopy(memberInfo);\n```\n\n![](./deepClone1.png)\n`deepCopyByJSON.createdTime`跟`memberInfo.createdTime`的值就不同了，因為`Date`物件無法被序列化。\n\n![](./deepClone2.png)\n`deepCopyByJSON.getMoreInfo`的值為 undefined，因為 function 也無法被序列化。\n\n#### `structuredClone(value)`\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n//使用 structuredClone 深複製物件 memberInfo\nconst deepCopyByStructuredClone = structuredClone(memberInfo);\n\nconsole.log(\n  \"deepCopyByStructuredClone.hobbies === memberInfo.hobbies\",\n  deepCopyByStructuredClone.hobbies === memberInfo.hobbies\n);//false\n\n`deepCopyByStructuredClone.hobbies` 跟 `memberInfo.hobbies` 的 reference 不同\n```\n\n但是同樣的 `structuredClone` 也無法處理 `function`、`Date`、`RegExp`、`Error`、`Map`、`Set` 等不可序列化的值。\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n  getMoreInfo: function getMoreInfo() {\n    return null;\n  },\n  createdTime: new Date(\"2024-06-10\"),\n};\n\nconst deepCopyByStructuredClone = structuredClone(memberInfo);\n```\n\n![](./deepClone3.png)\n當物件內有不可序列化的值時，直接使用`structuredClone` 就會直接報錯。\n\n#### 手寫遞迴函式\n\n```js\n//map（用於存儲已複製物件的 WeakMap），在 WeakMap 中，鍵必須是物件。\n\nfunction cloneDeep(obj, map = new WeakMap()) {\n  //如果 map 中已經有 obj 的複製，則直接返回該複製。這可以防止循環參照導致的無窮遞歸。\n  if (map.has(obj)) {\n    return map.get(obj);\n  }\n\n  //首先排除非物件類型的，檢查傳入的 obj 是否為 null 或是原始型別，這是因為這些類型的值在 JavaScript 中是按值傳遞的，所以不需要複製。\n  if (obj === null || typeof obj !== \"object\" || typeof value === \"function\") {\n    return obj;\n  }\n\n  //如果 obj 是 Date 的實例，則創建一個新的相同的 Date 實例並返回。\n  if (obj instanceof Date) return new Date(obj);\n\n  //如果 obj 是 RegExp 的實例，則創建一個新的相同的 RegExp 實例並返回。\n  if (obj instanceof RegExp) return new RegExp(obj);\n\n  //函式輸出 output 值，如果 obj 是陣列，則輸出為空陣列，如果 obj 是一個普通物件，則 output 的原型會被設置為 obj 的原型，以保留原型鏈。\n\n  const output = Array.isArray(obj)\n    ? []\n    : Object.create(Object.getPrototypeOf(obj));\n\n  //將 obj 和 output 的對應關係存入 map\n  map.set(obj, output);\n\n  //使用 Reflect.ownKeys(obj) 獲取 obj 的所有自有屬性鍵（包括符號和不可枚舉的屬性）\n  //遍歷所有的鍵，對每個鍵對應的值進行深度複製，並將複製的結果存入 output。\n  for (const key of Reflect.ownKeys(obj)) {\n    const val = obj[key];\n    //對當前鍵對應的值進行深度複製，並將複製的結果存入 output。\n    output[key] = cloneDeep(val, map);\n  }\n  return output;\n}\n\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n  getMoreInfo: function getMoreInfo() {\n    return null;\n  },\n  createdTime: new Date(\"2024-06-10\"),\n};\n\nconst cloneDeepMemberInfo = cloneDeep(memberInfo);\n\nconsole.log(\"cloneDeepMemberInfo.getMoreInfo\", cloneDeepMemberInfo.getMoreInfo);\nconsole.log(\"memberInfo.getMoreInfo\", memberInfo.getMoreInfo);\n\nconsole.log(\"cloneDeepMemberInfo.createdTime\", cloneDeepMemberInfo.createdTime);\nconsole.log(\"memberInfo.createdTime\", memberInfo.createdTime);\n```\n\n![](./deepClone4.png)\n![](./deepClone5.png)\n\n## 為什麼以 deep clone 來進行物件或陣列資料的 immutable update 不是一個好方法?\n\n簡單來說，使用 deep clone 操作物件資料會使 React 效能優化機制失效。\n\n這裡就舉一個例子來進行說明\n\n<CodeSandbox codeSandboxId=\"immutable-update-shallow-deep-clone-forked-8rgd8d?file=%2Fsrc%2FApp.jsx%3A20%2C29&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clvkron4200063b6iily2ii69%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clvkron4200023b6if4n611kn%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clvkron4200033b6impvz28zp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clvkron4200053b6i1eep83jr%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clvkron4200023b6if4n611kn%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvkron4200013b6iidkrwdor%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.js%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522id%2522%253A%2522clvlpejjd00023b6i228pr0my%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522initialSelections%2522%253A%255B%257B%2522startLineNumber%2522%253A20%252C%2522startColumn%2522%253A29%252C%2522endLineNumber%2522%253A20%252C%2522endColumn%2522%253A29%257D%255D%252C%2522filepath%2522%253A%2522%252Fsrc%252FApp.jsx%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522id%2522%253A%2522clvkron4200023b6if4n611kn%2522%252C%2522activeTabId%2522%253A%2522clvlpejjd00023b6i228pr0my%2522%257D%252C%2522clvkron4200053b6i1eep83jr%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvkron4200043b6ibahll584%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clvkron4200053b6i1eep83jr%2522%252C%2522activeTabId%2522%253A%2522clvkron4200043b6ibahll584%2522%257D%252C%2522clvkron4200033b6impvz28zp%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clvkron4200033b6impvz28zp%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D\" />\n\n`React.memo()` 是一個效能優化的方法，它將 component 包裹起來，每當有 props 傳入 component 時會使用 `Object.is（）` 檢查這次的 props 與前次的 props 是否相同，當 component 的 props 沒有變動時，就不會重新 render，這樣可以避免不必要的 re-render，提升效能。\n\n在這個例子中，App component 中有一個被 memo() 包裹住的 Child component。\n\n### 使用 deep clone 進行 state 更新\n\n```jsx\nimport { memo, useState } from \"react\";\n\nfunction Child({ fooObj }) {\n  console.log(\"render Child\");\n  return <h1>child: {fooObj.b}</h1>;\n}\n\nconst MemoizedChild = memo(Child);\n\nexport default function App() {\n  console.log(\"render App\");\n  const [data, setData] = useState({\n    count: 0,\n    foo: { b: 100 },\n  });\n\n  const updateCountWithDeepClone = () => {\n    // 使用 deep clone 複製 data 物件並且賦值給 newData\n    const newData = structuredClone(data);\n    // 更新 newData 的 count 屬性\n    newData.count += 1;\n    // 更新 data 的 state\n    setData(newData);\n  };\n\n  return (\n    <div>\n      <h2>count: {data.count} </h2>\n      <button onClick={updateCountWithDeepClone}>\n        Update Count With Deep Clone\n      </button>\n      <MemoizedChild fooObj={data.foo} />\n    </div>\n  );\n}\n```\n\n當 component 第一次 mounted 掛載至瀏覽器後：\n\n1. 點擊 Update Count With Deep Clone button\n\n2. 會呼叫 `updateCountWithDeepClone function`\n\n3. 在 `updateCountWithDeepClone function` 中會使用 `structuredClone` 進行 deep clone data 物件並且賦值給 newData\n\n4. 更新 newData 的 count 屬性\n\n5. 更新 data 的 state\n\n6. React 會執行 `Object.is() ` 檢查發現 state 更新了\n\n7. 進入 component reconciliation 階段，執行 App function 產生以 props 和 state 描述 component 畫面的 react element，這時就會印出 `render App`。\n\n8. 將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異就是 state，然後更新 `<h2>count: {data.count} </h2>`。\n\n9. 當執行到 `<MemoizedChild fooObj={data.foo} />` 時，雖然 `data.foo` 的值看似沒有改變，但是 React 發現 props 有變，當 App Component render 完成後，就會執行 memoized Child component function，這時會印出 `render Child`。\n\n這是因為使用了 deep Clone 更新了 state 資料，又 deep Clone 所將物件中每一層的每一個屬性都經過遍歷複製，即使沒發生更新的內層資料也會產生全新的參考，因此，此時當使用 `object.is()` 檢查傳入 `<MemoizedChild fooObj={data.foo} />` 的 props 時，就會發現 props 有變動，所以會重新 re-render，進而印出 `render Child`。\n\n從上述可以知道，對於 React 來說，使用 deep clone 進行 state 更新會使得某些 React 效能優化的手段失效，導致每一次 state 的更新都是全新的物件、全新的參考，即使該屬性的值沒有變更，而使得效能優化機制失去參考相等性。\n\n### 使用 shallow clone 進行 state 更新\n\n```jsx\nimport { memo, useState } from \"react\";\n\nfunction Child({ fooObj }) {\n  console.log(\"render Child\");\n  return <h1>child: {fooObj.b}</h1>;\n}\n\nconst MemoizedChild = memo(Child);\n\nexport default function App() {\n  console.log(\"render App\");\n  const [data, setData] = useState({\n    count: 0,\n    foo: { b: 100 },\n  });\n\n  const updateCountWithShallowClone = () => {\n    setData({\n      ...data,\n      count: data.count + 1,\n    });\n  };\n\n  return (\n    <div>\n      <h2>count: {data.count} </h2>\n      <button onClick={updateCountWithShallowClone}>\n        Update Count With Shallow Clone\n      </button>\n      <MemoizedChild fooObj={data.foo} />\n    </div>\n  );\n}\n```\n\n當 component 第一次 mounted 掛載至瀏覽器後：\n\n1. 點擊 Update Count With Shallow Clone button\n\n2. 會呼叫 `updateCountWithShallowClone function`\n\n3. 在 `updateCountWithShallowClone function` 中會展開運算符淺複製 data 物件，然後更新 count 屬性，最後 setState 更新 data 的 state。\n\n4. 更新 count 屬性\n\n5. 最後 setState 更新 data 的 state\n\n6. React 會執行 `Object.is()` 檢查發現 state 更新了\n\n7. 進入 component reconciliation 階段，執行 App function 產生以 props 和 state 描述 component 畫面的 react element，這時就會印出 `render App`。\n\n8. 將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異就是 state，然後更新 `<h2>count: {data.count} </h2>`。\n\n最後的執行結果就是傳入 `<MemoizedChild fooObj={data.foo} />` 的 props 並沒有變動，所以不會重新 re-render，也就不會印出 `render Child`，只有 App component 會重新 render。\n\n對於 React 來說資料比較機制就是為了減少重複產生 react element 的次數，React 不需要知道實際的資料細節，檢查原始型別時直接互比值、檢查物件時只需要比對參考是否相同，當物件資料的參考相同，React 就會當作資料沒變，不管物件內容如何改變，React 都不會重新產生新的 react element 來 render，因此更新 state 時不應該 mutate 原始資料，而是應該產生新的物件這樣就會產生一個新的 Reference，透過 shallow clone 複製原始物件的屬性到新的物件，只要根據更新的部分去修改相對應的值，這樣既不會 mutate 到原始資料，維持物件 immutable，也可以提供 React 效能優化機制參考的相等性。\n","createdAt":"2025-08-16T08:43:55.711Z","updatedAt":"2025-08-16T10:25:15.051Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":129,"data":{"documentId":"pa7jwi8tvdd1hgcma0t2ivry","slug":"component-life-cycle","title":"Component 的三大生命週期","date":"2025-08-16T08:43:55.722Z","description":"Component 的三大生命週期 生命週期就是指一個 React Component 在被創建到被銷毀的過程中，會經歷的一系列階段。 一. Mount Mount 流程會在 component 以 React component 的形式第一次出現在畫面上時觸發。 render phase: 1. React 會執行 component function 以傳入的 props 和 state 產生初始畫面區塊的 react element。","content":"\n## Component 的三大生命週期\n\n生命週期就是指一個 React Component 在被創建到被銷毀的過程中，會經歷的一系列階段。\n\n### 一. Mount\n\nMount 流程會在 component 以 React component 的形式第一次出現在畫面上時觸發。\n\n#### render phase:\n\n1. React 會執行 component function 以傳入的 props 和 state 產生初始畫面區塊的 react element。\n2. 此時 React 內部會建立 fiber node 以儲存 component 的實例，這個 component 實例會包含 component 畫面結構、state、side effect...等。\n3. 接著將生成的 react element 交到 commit phase 處理。\n\n#### commit phase:\n\n1. 由於此時是第一次 render，瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。\n2. 使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n3. 此時 component 就會被掛載到瀏覽器的畫面上，可以在實際的 DOM Element 中找到相對應的實例的 DOM element。\n\n#### 執行 side effect:\n\n執行 useEffect hook 中的 副作用。\n\n### 二. Update\n\nUpdate 流程會在 component 存在於畫面中，當 component 的 props 或 state 資料發生變化時觸發 re-render。在 react 中能夠觸發 re-render 的手段就是使用 `setState` 去更新 state 資料，而 component 有可能會因為父層或祖父層的 component `setState` 去更新 state 而傳入新的 props 而觸發 re-render；也有可能因為 component 本身 state 更新了而觸發 re-render。\n\n#### render phase:\n\n1. React 會執行 component function 以新版本傳入的 props 和 state 重新產生 react element。\n2. 接著將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異。\n3. 將差異的部分交到 commit phase 處理。\n\n#### commit phase:\n\n只會去操作新舊 react element 差異所對應的實際 DOM element。\n\n#### 清除前一次 render 的 side effect:\n\n執行前一次 useEffect hook 中定義的清除副作用 cleanup 函式。\n\n#### 執行本次 render 的 side effect\n\n### 三. Unmount\n\n當 component 在 re-render 後在新畫面中被移除時，就會觸發 unmount 流程。\n\n1. 會先將 component 從瀏覽器的實際 DOM element 中移除。\n2. 接著會執行最後一次 useEffect hook 中副作用中的 cleanup 函式，以清除留下的副作用影響。\n3. 移除 React 內部的 fiber node。\n","createdAt":"2025-08-16T08:43:55.777Z","updatedAt":"2025-08-16T10:25:15.065Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":131,"data":{"documentId":"ij8mpiivh8xhu05nrsl1sfp6","slug":"effect","title":"React 中的副作用處理：effect 初探","date":"2025-08-16T08:43:55.789Z","description":"React 在 component function 中提供了一個 useEffect hook 來 隔絕和管理副作用 。React 在每次 render 之後執行 useEffect。 副作用 side effect 副作用指的是當函式被呼叫時，除了回傳值以外，還會對外部環境產生影響的操作。常見的副作用包括： - 呼叫 API - 操作 DOM（例如手動新增事件監聽器） - 設定計時器（例如 setTimeout、setInterval） - 訂閱事件（例如 WebSocket 或其他事件系統） - 修改全域變數 使用 useEffect hook 處理副作用的原因 若直接在...","content":"\nReact 在 component function 中提供了一個 `useEffect` hook 來 **隔絕和管理副作用** 。React 在每次 render 之後執行 `useEffect`。\n\n## 副作用 side effect\n\n副作用指的是當函式被呼叫時，除了回傳值以外，還會對外部環境產生影響的操作。常見的副作用包括：\n\n- 呼叫 API\n- 操作 DOM（例如手動新增事件監聽器）\n- 設定計時器（例如 setTimeout、setInterval）\n- 訂閱事件（例如 WebSocket 或其他事件系統）\n- 修改全域變數\n\n## 使用 useEffect hook 處理副作用的原因\n\n若直接在 component function 中處理副作用，會造成以下問題：\n\n- 重複副作用執行：由於函式多次執行而產生疊加副作用會造成 react 無法預測行為，可能導致資料流或程式邏輯無法正常運作。\n- 效能問題： 容易阻塞函式計算，導致產生 react element 的速度變慢，進而造成畫面更新的延遲。\n- 無法清理副作用：直接操作 DOM 或設置計時器時，無法在 component 卸載時自動清理這些副作用，可能導致記憶體洩漏。\n\n## 以 useEffect hook 處理副作用的步驟\n\n```jsx\nimport React, { useEffect } from \"react\";\nimport axios from \"axios\";\nfunction MyComponent() {\n  const [id, setId] = useState(1);\n\n  useEffect(() => {\n    // 定義副作用，例如呼叫 API\n    console.log(\"Component rendered\");\n    axios.get(`https://api.example.com/data${id}`).then((response) => {\n      console.log(response.data);\n    });\n    // 可選的 cleanup 函式，會在下一次 effect 執行前或 component 卸載時執行\n    return () => {\n      console.log(\"Cleanup before the next effect or on unmount\");\n    };\n  }, [id]); // 依賴陣列，當陣列中的值有變動時才會執行副作用\n\n  return <div>My Component</div>;\n}\n```\n\n1. 在 component function 中使用 `useEffect` hook。\n2. 在 `useEffect` hook 中定義副作用函式，例如呼叫 API。\n3. 如果有需要清除副作用，可以在副作用函式中回傳一個 cleanup 函式。\n4. 在 dependencies array 中傳入依賴陣列，以跳過執行不需要的 render 副作用。\n\n---\n\n## 實例練習 1\n\n[12. useEffect](https://bigfrontend.dev/react-quiz/useEffect)\n\n```JSX\n// This is a React Quiz from BFE.dev\n\nimport React, { useEffect, useState } from 'react'\nimport ReactDOM from 'react-dom'\n\nfunction App() {\n  const [state, setState] = useState(0)\n  console.log(state)\n\n  useEffect(() => {\n    setState(state => state + 1)\n  }, [])\n\n  useEffect(() => {\n    console.log(state)\n    setTimeout(() => {\n      console.log(state)\n    }, 100)\n  }, [])\n\n  return null\n}\n\nReactDOM.render(<App/>, document.getElementById('root'))\n\n```\n\n## 解題 1\n\n1. 初始渲染， 執行`console.log(state)`，這時的 state 是 0，所以會印出 0。\n\n2. 第一個 useEffect hook，`setState(state => state + 1)` 會等到所有的 side effect 都執行完後才會執行。\n\n3. 第二個 useEffect hook 中的 `console.log(state)` 會印出 0，這時的 state 是 0，所以會印出 0。\n\n4. 當遇到第二個 useEffect hook 中的 `setTimeout` 會在 100ms 後執行，所以根據 event loop 的機制會被放到宏任務 queue 中，等到 call stack 空了之後才會執行。\n\n5. `setState` 觸發 re-render：當 `setState(state => state + 1)` 被執行後，React 會進行一次重新渲染，state 的值會從 0 更新為 1，觸發 component re-render。\n\n6. 重新渲染後：重新渲染的 `console.log(state)`：在重新渲染過程中，state 現在是 1，所以新的 `console.log(state)` 會印出 1。7. 宏任務執行：`setTimeout` 的 callback 會在 100 毫秒後執行，這時 callback 內的 `console.log(state)` 會依然使用最初 `setTimeout` 被註冊時的閉包環境中的 state 值，該值仍然是初次渲染時的 0，因此會印出 0。\n\n```\n0\n0\n1\n0\n```\n\n## 實例練習 2\n\n[24. useEffect() timing](https://bigfrontend.dev/react-quiz/useeffect-timing)\n\n```JSX\nimport * as React from \"react\";\nimport { useState, useEffect } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { screen, fireEvent } from \"@testing-library/dom\";\n\nfunction App() {\n  const [state, setState] = useState(0)\n  console.log(1)\n\n  useEffect(() => {\n    console.log(2)\n  }, [state])\n\n  Promise.resolve().then(() => console.log(3))\n\n  setTimeout(() => console.log(4), 0)\n\n  const onClick = () => {\n    console.log(5)\n    setState(num => num + 1)\n    console.log(6)\n  }\n  return <div>\n    <button onClick={onClick}>click me</button>\n  </div>\n}\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App/>)\n\nsetTimeout(() => fireEvent.click(screen.getByText('click me')), 100)\n\n```\n\n## 解題 2\n\n1. 初始渲染，執行 `console.log(1)`，印出 `1`。\n2. 執行 `useEffect` hook 中的 `console.log(2)`，印出 `2`。\n3. 將 `Promise.resolve().then(() => console.log(3))` 放到微任務隊列，等待同步程式執行完畢後執行。\n4. 將 `setTimeout(() => console.log(4), 0)` 放到宏任務隊列，等待同步程式執行完畢後執行。\n5. 事件處理 (onClick)：\n\n- React 在 100 毫秒後模擬點擊按鈕。\n- 將 `onClick` callback 放到事件隊列，放到宏任務隊列，等待同步程式執行完畢後執行。\n\n6. 從微任務隊列中取出 `Promise.resolve().then(() => console.log(3))`，執行 `console.log(3)`，印出 `3`。\n7. 從宏任務隊列中取出 `setTimeout(() => console.log(4), 0)`，執行 `console.log(4)`，印出 `4`。\n8. 從宏任務隊列中取出 `onClick` callback，執行 `console.log(5)`，印出 `5`，`setState(num => num + 1)` 會等到所有的 side effect 都執行完後才會執行。\n9. `console.log(6)`，印出 `6`。\n10. 執行 `setState(num => num + 1)`，觸發 re-render，重新執行 component function，state 從 0 變成 1。\n11. 重新渲染後，執行 `console.log(1)`，印出 `1`。\n12. 執行 `useEffect` hook 中的 `console.log(2)`，印出 `2`。\n13. 將 `Promise.resolve().then(() => console.log(3))` 放到微任務隊列，等待同步程式執行完畢後執行。\n14. 將 `setTimeout(() => console.log(4), 0)` 放到宏任務隊列，等待同步程式執行完畢後執行。\n15. 從微任務隊列中取出 `Promise.resolve().then(() => console.log(3))`，執行 `console.log(3)`，印出 `3`。\n16. 從宏任務隊列中取出 `setTimeout(() => console.log(4), 0)`，執行 `console.log(4)`，印出 `4`。\n\n```\n1\n2\n3\n4\n5\n6\n1\n2\n3\n4\n```\n","createdAt":"2025-08-16T08:43:55.825Z","updatedAt":"2025-08-16T10:25:15.077Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":133,"data":{"documentId":"wxb8rapsef0brw9rxmdkwevk","slug":"ueseffect","title":"uesEffect 其實不是 functional component 的 API","date":"2025-08-16T08:43:55.836Z","description":"","content":"\nuseEffect hook 最主要的作用在於處理與畫面無關的 side effect，並非是 functional component 的生命週期API，因為這個處理副作用的 hook 不論呼叫幾次都不應該影響的資料流或是程式邏輯。\n\n## useEffect 的 dependencies 機制設計的目的\n\nuseEffect 的 dependencies 機制設計的目的是為了讓 React 能夠正確地同步資料，並且優化效能。\n在 dependencies 中傳入 side effect 函式所需要依賴的資料，react 就會在每一個渲染時使用\n`object.is` 來比較前後兩次的 dependencies 依賴的原始資料否有變化，若有變化就會執行 side effect 函式，沒有就可以跳過這次 side effect 的執行。\n\ndependencies 並非是為了控制 side effect 執行的時機或商業邏輯，而是為了讓 react 可以正確地同步化資料，所以應誠實地填寫有依賴到的原始資料到 dependencies 中。\n\n## 在 useEffect 中，根據 dependencies 的不同情境運作的方式：\n\n### dependencies 為空陣列\n\n```jsx\nimport React, { useEffect, useState } from \"react\";\nfunction App() {\n  useEffect(() => {\n    console.log(\"Component rendered\");\n  }, []);\n  return <div>My Component</div>;\n}\n```\n\n運作流程：\n\n- render：\n\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段：瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。然後使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n  - mount： 執行 side effect，印出 \"Component rendered\"。\n\n- re-render: 假設之後因畫面更新觸發 re-render，由於 dependencies 為空陣列，react 會比較前後兩次的 dependencies 依賴的原始資料，發現沒有變化，因此不會執行 side effect。\n\n### dependencies 中傳入 useState\n\n```jsx\nimport React, { useEffect, useState } from \"react\";\nfunction App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"Component rendered\");\n  }, [count]);\n  return (\n    <div>\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\n        Click me\n      </button>\n      <div>{count}</div>\n    </div>\n  );\n}\n```\n\n運作流程：\n\n- render：\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段：瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。然後使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n  - mount： 執行 side effect，印出 \"Component rendered\"。\n- re-render:\n  - 當點擊 button 時觸發 `setCount((prevCount)=>prevCount+1)`，count 的值更新到 1。\n  - `object.is()` 檢查前後兩次的 count 值，發現有變化，因此進入 reconciliation 階段，重新 render。\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段： 將前後兩次的 react element 進行樹狀結構的比較，找出差異，並且只會去操作新舊 react element 差異所對應的實際 DOM element。\n  - mount : 透過 `object.is()`檢查 `useEffect` dependencies 中所有的項目，發現所依賴的資料 count 值有變化，因此執行 side effect，印出 \"Component rendered\"。\n\n### 不傳入 dependencies\n\n```jsx\nimport React, { useEffect, useState } from \"react\";\nfunction App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"Component rendered\");\n  });\n  return (\n    <div>\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\n        Click me\n      </button>\n      <div>{count}</div>\n    </div>\n  );\n}\n```\n\n運作流程：\n\n- render：\n\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段：瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。然後使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n  - mount： 執行 side effect，印出 \"Component rendered\"。\n\n- re-render: 假設之後因畫面更新觸發 re-render，沒有傳入 dependencies，因此沒有參考的依賴資料，只要重新渲染就會執行一次 side effect，印出 \"Component rendered\"。\n\n## 總結：\n\n- 空陣列：useEffect 只在初次 mount 時執行一次，不會再執行。\n- 傳入依賴項：依賴項改變時執行副作用函式，狀態變化正確同步。\n- 無依賴項：每次渲染都會執行副作用，這可能會導致不必要的效能問題。\n","createdAt":"2025-08-16T08:43:55.856Z","updatedAt":"2025-08-16T09:03:07.101Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":135,"data":{"documentId":"w50ao2j0q5pig4w4tvh2d1j3","slug":"usecallback-usememo","title":"useCallback 與 useMemo 的正確使用時機","date":"2025-08-16T08:43:55.867Z","description":"","content":"\n## `useCallback`的用途和使用時機\n\n`useCallback` hook 最主要的作用在於幫助其他 React 效能優化的手段維持正常，例如：React.`memo`、`useMemo`、`useEffect` 等等，而非效能優化。\n\n將函式傳入 `useCallback` hook ，並且傳入一個依賴陣列，`useCallback` hook 會回傳一個 memoized 函式，這個 memoized 函式只有在依賴陣列中的值有變化時才會重新計算，否則會回傳上一次的函式。\n以下是一個簡單的範例說明：\n\n### 使用 `useCallback` hook 前\n\n```jsx Card.tsx\nimport React, { memo } from \"react\";\nfunction Card ({ count , handleClick }:props){\n    return (\n        <div>\n            <div>{count}</div>\n            <Button onClick={handleClick}>Click me</Button>\n        </div>\n    );\n}\nexport default memo(Card);\n```\n\n```jsx App.tsx\nimport React, { useState, useCallback } from \"react\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const updateCount = () => {\n    setCount((prevCount) => prevCount + 1);\n  };\n  const handleClick = () => {\n    alert(count);\n  };\n\n  return (\n    <div>\n      <Card count={count} handleClick={handleClick} />\n      <Button onClick={updateCount}>Update count</Button>\n    </div>\n  );\n}\nexport default App;\n```\n\n在這個例子中，`handleClick` 這個函式在每一次 render 的過程中都會重新產生一個新的函式，這樣會導致 `Card` 元件因為感知到 props 中的 `handleClick` 函式有變化而重新渲染。\n\n在這裡看起來似乎沒什麼問題，但是問題在 `Card` 元件被包裹在 `React.memo` 中，`React.memo`是 hoc (higher-order component) ，會在元件 re-render 的時候檢查 props 是否有變化，如果有變化就會重新渲染，否則就會透過快取返回上一次的結果，以達到效能優化的目的。\n\n但是在上方的例子中，可以看到 `handleClick` 函式在每次 render 時都會重新產生一個新的函式，每一次 re-render 傳入的 props 的 `handleClick` 都是不同的函式進而導致 `Card` 元件重新渲染，如此一來，就失去了 `React.memo` 原有的效能優化的目的。\n\n### 使用 `useCallback` hook 後\n\n```jsx Card.tsx\nimport React, { memo } from \"react\";\nfunction Card ({ count , handleClick }:props){\n    return (\n        <div>\n            <div>{count}</div>\n            <Button onClick={handleClick}>Click me</Button>\n        </div>\n    );\n}\nexport default memo(Card);\n```\n\n```jsx App.tsx\nimport React, { useState, useCallback } from \"react\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const updateCount = () => {\n    setCount((prevCount) => prevCount + 1);\n  };\n  const handleClick = useCallback(() => {\n    alert(count);\n  }, [count]);\n\n  return (\n    <div>\n      <Card count={count} handleClick={handleClick} />\n      <Button onClick={updateCount}>Update count</Button>\n    </div>\n  );\n}\nexport default App;\n```\n\n可以上方 `handleClick` 使用 `useCallback` hook 來包裹，並且傳入一個依賴陣列 `[count]`，當 count 資料有變化時，`handleClick`才會重新產生一個新的函式，否則會回傳上一次的函式，`Card` 元件所包裹的`react.memo`就可以正常運作，達到效能優化的目的。\n\n如此一來可以讓函式可以參與資料流的變化，進而幫助 React hook dependencies 判斷資料流的邏輯運作正常。\n\n## `useMemo`的用途和使用時機\n\n`useMemo` 用法跟 `useCallback` 類似，但是 `useMemo` 是用來快取陣列、物件或者是通常來用處理複雜的計算，以節省效能。\n\n```jsx\nimport React, { useState, useMemo } from \"react\";\nfunction App() {\n  const [count, setCount] = useState(0);\n  const isEven = useMemo(() => {\n    return count % 2 === 0;\n  }, [count]);\n  return (\n    <div>\n      <div>{count}</div>\n      <div>{isEven ? \"Even\" : \"Odd\"}</div>\n      <Button onClick={() => setCount((prev) => prev + 1)}>Increment</Button>\n    </div>\n  );\n}\n```\n\n在以上的例子中，我們實作一個 button 來增加 count 的值，並且使用 `useMemo` hook 來快取 `isEven` 變數，當 count 的值有變化時，`isEven` 變數才會重新計算，否則會快取回傳上一次的結果。\n","createdAt":"2025-08-16T08:43:55.902Z","updatedAt":"2025-08-16T08:43:55.902Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":136,"data":{"documentId":"w50ao2j0q5pig4w4tvh2d1j3","slug":"usecallback-usememo","title":"useCallback 與 useMemo 的正確使用時機","date":"2025-08-16T08:43:55.867Z","description":"","content":"\n## `useCallback`的用途和使用時機\n\n`useCallback` hook 最主要的作用在於幫助其他 React 效能優化的手段維持正常，例如：React.`memo`、`useMemo`、`useEffect` 等等，而非效能優化。\n\n將函式傳入 `useCallback` hook ，並且傳入一個依賴陣列，`useCallback` hook 會回傳一個 memoized 函式，這個 memoized 函式只有在依賴陣列中的值有變化時才會重新計算，否則會回傳上一次的函式。\n以下是一個簡單的範例說明：\n\n### 使用 `useCallback` hook 前\n\n```jsx Card.tsx\nimport React, { memo } from \"react\";\nfunction Card ({ count , handleClick }:props){\n    return (\n        <div>\n            <div>{count}</div>\n            <Button onClick={handleClick}>Click me</Button>\n        </div>\n    );\n}\nexport default memo(Card);\n```\n\n```jsx App.tsx\nimport React, { useState, useCallback } from \"react\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const updateCount = () => {\n    setCount((prevCount) => prevCount + 1);\n  };\n  const handleClick = () => {\n    alert(count);\n  };\n\n  return (\n    <div>\n      <Card count={count} handleClick={handleClick} />\n      <Button onClick={updateCount}>Update count</Button>\n    </div>\n  );\n}\nexport default App;\n```\n\n在這個例子中，`handleClick` 這個函式在每一次 render 的過程中都會重新產生一個新的函式，這樣會導致 `Card` 元件因為感知到 props 中的 `handleClick` 函式有變化而重新渲染。\n\n在這裡看起來似乎沒什麼問題，但是問題在 `Card` 元件被包裹在 `React.memo` 中，`React.memo`是 hoc (higher-order component) ，會在元件 re-render 的時候檢查 props 是否有變化，如果有變化就會重新渲染，否則就會透過快取返回上一次的結果，以達到效能優化的目的。\n\n但是在上方的例子中，可以看到 `handleClick` 函式在每次 render 時都會重新產生一個新的函式，每一次 re-render 傳入的 props 的 `handleClick` 都是不同的函式進而導致 `Card` 元件重新渲染，如此一來，就失去了 `React.memo` 原有的效能優化的目的。\n\n### 使用 `useCallback` hook 後\n\n```jsx Card.tsx\nimport React, { memo } from \"react\";\nfunction Card ({ count , handleClick }:props){\n    return (\n        <div>\n            <div>{count}</div>\n            <Button onClick={handleClick}>Click me</Button>\n        </div>\n    );\n}\nexport default memo(Card);\n```\n\n```jsx App.tsx\nimport React, { useState, useCallback } from \"react\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const updateCount = () => {\n    setCount((prevCount) => prevCount + 1);\n  };\n  const handleClick = useCallback(() => {\n    alert(count);\n  }, [count]);\n\n  return (\n    <div>\n      <Card count={count} handleClick={handleClick} />\n      <Button onClick={updateCount}>Update count</Button>\n    </div>\n  );\n}\nexport default App;\n```\n\n可以上方 `handleClick` 使用 `useCallback` hook 來包裹，並且傳入一個依賴陣列 `[count]`，當 count 資料有變化時，`handleClick`才會重新產生一個新的函式，否則會回傳上一次的函式，`Card` 元件所包裹的`react.memo`就可以正常運作，達到效能優化的目的。\n\n如此一來可以讓函式可以參與資料流的變化，進而幫助 React hook dependencies 判斷資料流的邏輯運作正常。\n\n## `useMemo`的用途和使用時機\n\n`useMemo` 用法跟 `useCallback` 類似，但是 `useMemo` 是用來快取陣列、物件或者是通常來用處理複雜的計算，以節省效能。\n\n```jsx\nimport React, { useState, useMemo } from \"react\";\nfunction App() {\n  const [count, setCount] = useState(0);\n  const isEven = useMemo(() => {\n    return count % 2 === 0;\n  }, [count]);\n  return (\n    <div>\n      <div>{count}</div>\n      <div>{isEven ? \"Even\" : \"Odd\"}</div>\n      <Button onClick={() => setCount((prev) => prev + 1)}>Increment</Button>\n    </div>\n  );\n}\n```\n\n在以上的例子中，我們實作一個 button 來增加 count 的值，並且使用 `useMemo` hook 來快取 `isEven` 變數，當 count 的值有變化時，`isEven` 變數才會重新計算，否則會快取回傳上一次的結果。\n","createdAt":"2025-08-16T08:43:55.902Z","updatedAt":"2025-08-16T08:43:55.902Z","publishedAt":"2025-08-16T08:43:55.903Z","locale":null,"author":null}}
{"type":"api::post.post","id":137,"data":{"documentId":"z9l5nslvwmqnwbml18onntzq","slug":"useref","title":"useRef 的使用情境","date":"2025-08-16T08:43:55.912Z","description":"","content":"\n# useRef 的使用情境\n\n## `useRef` 是什麼？\n\n`useRef` 是 React 提供的 hook，用來創建一個 可變（mutable）的引用對象，可以用來存取 DOM 元素或保存跨越多次渲染的資料，且在資料變動時不會觸發 re-render。\n\n## `useRef` 的使用情境\n\n### 1. 存取 DOM 元素\n\n`useRef` 最常見的使用情境之一是存取 DOM 元素，讓我們可以直接操作原生 DOM。\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  const inputRef = useRef(null);\n  return (\n    <div>\n      <label htmlFor=\"name\">name:</label>\n      <input ref={inputRef} type=\"text\" />\n      <div>\n        <button onClick={() => inputRef.current.focus()}>Click to Focus</button>\n      </div>\n    </div>\n  );\n}\n```\n\n在這個例子中，我們使用 `useRef` hook 來存取 `input` 元素，並且在 `button` 的 `onClick` 事件中，使用 `inputRef.current.focus()` 來 focus 到 input 元素。\n\n### 2.保存跨 re-render 的值\n\n除了存取 DOM，u`useRef` 也可以用來保存那些不會因為 component re-render 而失去的值。\n\n```jsx live title=\"index.jsx\"\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const renderCount = useRef(0);\n\n  renderCount.current += 1;\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Component rendered {renderCount.current} times</p>\n      <button onClick={() => setCount((prev) => prev + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\n在這個例子中，renderCount 使用 `useRef` 來保存 render 的次數，這樣就不會因為 `count` 的改變而重新 render。\n\ncount 使用 `useState` 來保存當前計數器的值 count。，當 `count` 改變時，會重新 render，但是 renderCount 不會受到影響。\n\n初始渲染時，`renderCount.current` 會是 1，當 `count` 改變時，`renderCount.current` 會持續增加。\n\n### 3. 保存前一個 state 的值\n\n`useRef` 還可以用來追蹤 component 在前一次 render 中的 state 值。\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  const [name, setName] = useState(\"Alice\");\n  const prevName = useRef(\"\");\n\n  useEffect(() => {\n    prevName.current = name;\n  }, [name]);\n\n  return (\n    <div>\n      <p>Current name: {name}</p>\n      <p>Previous name: {prevName.current}</p>\n      <button onClick={() => setName(\"Bob\")}>Change Name</button>\n    </div>\n  );\n}\n```\n\n在這個例子中，我們使用 `useRef` 來保存前一個 `name` 的值。每次 `name` 改變時，`prevName.current` 都會更新為上一次的 `name`。\n\n### 4. 追蹤某個 effect 副作用是否已經執行過\n\n在某些情況下，我們需要避免副作用多次執行，這時可以使用 useRef 來追蹤是否已經執行過某個操作。\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  const hasFetched = useRef(false);\n\n  useEffect(() => {\n    if (!hasFetched.current) {\n      console.log(\"Fetching data...\");\n      hasFetched.current = true;\n    }\n  }, []);\n\n  return <div>Data has been fetched</div>;\n}\n```\n\n這個例子使用 `hasFetched` 來追蹤是否已經執行過 fetch data 的操作。當 `hasFetched.current` 為 `false` 時，會執行 `console.log(\"Fetching data...\")`，並將 `hasFetched.current` 設為 `true`，這樣就可以避免重複執行 fetch data 的操作。\n\n---\n\n## 實例練習\n\n[13. useRef](https://bigfrontend.dev/react-quiz/useRef)\n\n```jsx\n// This is a React Quiz from BFE.dev\n\nimport * as React from \"react\";\nimport { useRef, useEffect, useState } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\nfunction App() {\n  const ref = useRef(null);\n  const [state, setState] = useState(1);\n\n  useEffect(() => {\n    setState(2);\n  }, []);\n\n  console.log(ref.current?.textContent);\n\n  return (\n    <div>\n      <div ref={state === 1 ? ref : null}>1</div>\n      <div ref={state === 2 ? ref : null}>2</div>\n    </div>\n  );\n}\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(<App />);\n```\n\n## 解題\n\n### 初始渲染\n\n在初始渲染，react 呼叫 App component function 產生 react element ，並且轉換相對應的 DOM 掛載到螢幕上。\n\n執行 `console.log(ref.current?.textContent)`，因為 useRef 的初始值是 `null` 所以印出 `undefined`。\n\n`state` 為 1，因此第一個 div 元素被引用。\n\n接著，react 執行 `useEffect` 中 `setState(2)` 會觸發 re-render。\n\n### re-render\n\n重新呼叫 App component function 產生 react element 經過 diff 比較後更新 DOM。\n\n執行 `console.log(ref.current?.textContent)`，因為 `useRef` 保存了上一次的值，所以印出\n\"1\"。\n\n`state` 更新為 2，第一個 div 元素的 `ref` 被設為 `null`，第二個 div 元素被引用。\n","createdAt":"2025-08-16T08:43:55.931Z","updatedAt":"2025-08-16T08:43:55.931Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":138,"data":{"documentId":"z9l5nslvwmqnwbml18onntzq","slug":"useref","title":"useRef 的使用情境","date":"2025-08-16T08:43:55.912Z","description":"","content":"\n# useRef 的使用情境\n\n## `useRef` 是什麼？\n\n`useRef` 是 React 提供的 hook，用來創建一個 可變（mutable）的引用對象，可以用來存取 DOM 元素或保存跨越多次渲染的資料，且在資料變動時不會觸發 re-render。\n\n## `useRef` 的使用情境\n\n### 1. 存取 DOM 元素\n\n`useRef` 最常見的使用情境之一是存取 DOM 元素，讓我們可以直接操作原生 DOM。\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  const inputRef = useRef(null);\n  return (\n    <div>\n      <label htmlFor=\"name\">name:</label>\n      <input ref={inputRef} type=\"text\" />\n      <div>\n        <button onClick={() => inputRef.current.focus()}>Click to Focus</button>\n      </div>\n    </div>\n  );\n}\n```\n\n在這個例子中，我們使用 `useRef` hook 來存取 `input` 元素，並且在 `button` 的 `onClick` 事件中，使用 `inputRef.current.focus()` 來 focus 到 input 元素。\n\n### 2.保存跨 re-render 的值\n\n除了存取 DOM，u`useRef` 也可以用來保存那些不會因為 component re-render 而失去的值。\n\n```jsx live title=\"index.jsx\"\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const renderCount = useRef(0);\n\n  renderCount.current += 1;\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Component rendered {renderCount.current} times</p>\n      <button onClick={() => setCount((prev) => prev + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\n在這個例子中，renderCount 使用 `useRef` 來保存 render 的次數，這樣就不會因為 `count` 的改變而重新 render。\n\ncount 使用 `useState` 來保存當前計數器的值 count。，當 `count` 改變時，會重新 render，但是 renderCount 不會受到影響。\n\n初始渲染時，`renderCount.current` 會是 1，當 `count` 改變時，`renderCount.current` 會持續增加。\n\n### 3. 保存前一個 state 的值\n\n`useRef` 還可以用來追蹤 component 在前一次 render 中的 state 值。\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  const [name, setName] = useState(\"Alice\");\n  const prevName = useRef(\"\");\n\n  useEffect(() => {\n    prevName.current = name;\n  }, [name]);\n\n  return (\n    <div>\n      <p>Current name: {name}</p>\n      <p>Previous name: {prevName.current}</p>\n      <button onClick={() => setName(\"Bob\")}>Change Name</button>\n    </div>\n  );\n}\n```\n\n在這個例子中，我們使用 `useRef` 來保存前一個 `name` 的值。每次 `name` 改變時，`prevName.current` 都會更新為上一次的 `name`。\n\n### 4. 追蹤某個 effect 副作用是否已經執行過\n\n在某些情況下，我們需要避免副作用多次執行，這時可以使用 useRef 來追蹤是否已經執行過某個操作。\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  const hasFetched = useRef(false);\n\n  useEffect(() => {\n    if (!hasFetched.current) {\n      console.log(\"Fetching data...\");\n      hasFetched.current = true;\n    }\n  }, []);\n\n  return <div>Data has been fetched</div>;\n}\n```\n\n這個例子使用 `hasFetched` 來追蹤是否已經執行過 fetch data 的操作。當 `hasFetched.current` 為 `false` 時，會執行 `console.log(\"Fetching data...\")`，並將 `hasFetched.current` 設為 `true`，這樣就可以避免重複執行 fetch data 的操作。\n\n---\n\n## 實例練習\n\n[13. useRef](https://bigfrontend.dev/react-quiz/useRef)\n\n```jsx\n// This is a React Quiz from BFE.dev\n\nimport * as React from \"react\";\nimport { useRef, useEffect, useState } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\nfunction App() {\n  const ref = useRef(null);\n  const [state, setState] = useState(1);\n\n  useEffect(() => {\n    setState(2);\n  }, []);\n\n  console.log(ref.current?.textContent);\n\n  return (\n    <div>\n      <div ref={state === 1 ? ref : null}>1</div>\n      <div ref={state === 2 ? ref : null}>2</div>\n    </div>\n  );\n}\n\nconst root = createRoot(document.getElementById(\"root\"));\nroot.render(<App />);\n```\n\n## 解題\n\n### 初始渲染\n\n在初始渲染，react 呼叫 App component function 產生 react element ，並且轉換相對應的 DOM 掛載到螢幕上。\n\n執行 `console.log(ref.current?.textContent)`，因為 useRef 的初始值是 `null` 所以印出 `undefined`。\n\n`state` 為 1，因此第一個 div 元素被引用。\n\n接著，react 執行 `useEffect` 中 `setState(2)` 會觸發 re-render。\n\n### re-render\n\n重新呼叫 App component function 產生 react element 經過 diff 比較後更新 DOM。\n\n執行 `console.log(ref.current?.textContent)`，因為 `useRef` 保存了上一次的值，所以印出\n\"1\"。\n\n`state` 更新為 2，第一個 div 元素的 `ref` 被設為 `null`，第二個 div 元素被引用。\n","createdAt":"2025-08-16T08:43:55.931Z","updatedAt":"2025-08-16T08:43:55.931Z","publishedAt":"2025-08-16T08:43:55.934Z","locale":null,"author":null}}
{"type":"api::post.post","id":139,"data":{"documentId":"gra657d7tal3p75tu3k2i321","slug":"reac-native-current-arch","title":"reac-native-current-arch","date":"2025-08-16T08:43:55.947Z","description":"解析 React Native 現行架構（Current Architecture）原理 長久以來，React Native 的效能問題一直為人詬病，為了解決這個問題，React Native 開發團隊針對舊有的架構進行了重構，並在 0.68 版本推出了新架構（New Architecture）。接下來，我會分享原來的架構是 Javascript 如何與 natvie 溝通，究竟面臨了什麼問題？讓 React Native 開發團隊決定重構。","content":"\n# 解析 React Native 現行架構（Current Architecture）原理\n\n長久以來，React Native 的效能問題一直為人詬病，為了解決這個問題，React Native 開發團隊針對舊有的架構進行了重構，並在 0.68 版本推出了新架構（New Architecture）。接下來，我會分享原來的架構是 Javascript 如何與 natvie 溝通，究竟面臨了什麼問題？讓 React Native 開發團隊決定重構。\n\n要來了解現行架構是怎麼運作，先來認識幾個重要的概念：\n\n## Keywords\n\n### Javascript Engine\n\n就是指執行 Javascript 程式碼的環境。\n\n- [Hermes](https://reactnative.dev/docs/hermes):\n  是基於 React Native 打造的 JS Engine，在 React Native 0.70 版時被設為預設的 JS Engine。\n\n- [JavaScriptCore](https://developer.apple.com/documentation/javascriptcore):\n  Apple 開發的 JS Engine，較舊版本的 React Native 會使用這個引擎。\n\n### JSON 序列化（serizlized）\n\n就是把資料轉換成 JSON 格式的過程，反之， JSON 反序列化就是把 JSON 格式轉成原始資料的過程。\n\n### Yoga engine\n\n是一種跨平台佈局引擎（Layout engine），主要是用來計算使用者畫面中 UI 元素的位置，藉此生成每一個 React shadow node 的位置與大小，ex:把 Flexbox 佈局轉換成原生平台的佈局樣式。\n\n# React Native 利用三個主要執行緒（threads）進行運作\n\n- UI Thread/ Native Thread：\n  是 UI Manager 負責處理用戶的介面操作 Andriod 跟 iOS 畫面的渲染邏輯，以及呼叫原生 api、運行原生模組。\n- JavaScript Thread:\n  主要是 JS Engine 使用，負責運行 JS Bundle 中的 JavaScript 程式碼，處理邏輯。\n- Shadow thread:\n  負責原生的佈局，提供給 yoga 引擎使用，其負責在渲染主機畫面（host screen）前計算佈局中元素的位子與大小。\n\n# 現行架構（Current Architecture）\n\n![https://ithelp.ithome.com.tw/upload/images/20230924/20162496DhGCCLaxPg.png](https://ithelp.ithome.com.tw/upload/images/20230924/20162496DhGCCLaxPg.png)\n\n## 現行架構運作的流程\n\nreact 經過 Metro 打包編譯後產生 JS Bundle，JS Bundle 在 JavaScriptcore （JavaScript 引擎）的環境下執行，JavaScript 的程式碼與原生的程式碼透過 **橋接（Bridge）** 的方式溝通。\n\n橋接（Bridge）是如何進行溝通呢？ 原生模組（Native module） 透過 Bridge 封裝成 JavaScript 接口提供給 JavaScript 引擎呼叫 Native 的方法。\n\nNative 與 JavaScript 之間溝通的方法是使用非同步的 JSON 序列化與反序列化方式去傳遞與轉換資料，也就是 JS thread 會傳送以 JSON 序列化的訊息並且以字串符發送到 Bridge，Bridge 會優化這個訊息並且傳遞到 UI Thread/ Native Thread，UI Thread/ Native Thread 收後解密這條訊息，然後根據這條訊息去執行原生的程式碼。\n\n當應用程式啟動時，UI Manager 會下載所有的原生模組，React 會在 JavaScript Thread 執行產生 React Element Tree ，一旦渲染時就會透過 Bridge 發佈變更的指令到 Shadow Thread，創造 React Shadow Tree （似 React Virtual DOM 功能），顯示應用程序的 UI 的佈局和結構來比對 UI 需進行哪些更改，然後透過 yoga 引擎去計算 UI 元素在原生螢幕的位置和大小，一旦 Yoga 完成布局計算，React Native 的 UI Manager 就會將使用原生平台特定的 API 轉換成原生的 Host View Tree 並且通知 UI Thread 使用原生元素在用戶的螢幕上呈現變更後的 UI。\n\n## 現行架構使用橋接（Bridge）存在的一些問題\n\n- 操作是非同步(asynchronous)的：\n  原生或 JavaScript 其中一端傳遞消息到 Bridge ，需要等另外一端處理這些消息，即使這個等待很沒必要。Bridge 就像是一條單線道的橋，當兩端都有車想要通過時，必須先等待其中一端過橋，另一端的車子才能過橋，曠時費力。\n\n- 只能在單一執行緒(single-threaded)上進行：\n  JavaScript 只能在單一的 thread 上運行，所以會導致某些計算必須等待這個 thread 完成。\n\n- 序列化造成效能消耗大:\n  由於透過 JSON 格式傳遞消息，每一次都經過序列化跟反序列化，造成效能的開銷很大。\n\n以上的原因導致效能不佳，也連帶了影響使用者體驗。舉例來說，有一個很長的列表，當使用者在使用手勢快速向下滑動的時候，就很可能在剩下的資料回傳之前看到螢幕出現白屏。造成白屏的原因就在於：\n\n1. 原生的 onScroll 事件傳遞到 JavaScript Thread\n2. JavaScript 去呼叫 api 取得新的資料\n3. JavaScript 取得資料後把新的佈局細節傳給 shadow tree\n4. shadow tree 透過 Yoga engine 計算好佈局的細節後，傳送到原生的 UI\n\n當使用者操作速度一快，Bridge 就塞車了～畫面也就因此卡住了。\n\n#### 參考資料\n\n- [React Native 原理与实践](https://juejin.cn/post/6916452544956858382#heading-18)\n- [React Native: Understanding Threads.](https://brooklinmyers.medium.com/react-native-understanding-threads-e026c7d62bb2)\n- [React Native’s bridge, under the hood](https://medium.com/@samwhadams/react-native-under-the-hood-80677cf9bf96)\n- [React Native 渲染原理](https://zhuanlan.zhihu.com/p/388681402)\n- [Does React Native have a 'Virtual DOM'?](https://stackoverflow.com/questions/41804855/does-react-native-have-a-virtual-dom)\n\n:::note\n\n本篇文章原先發佈於[ithome](https://ithelp.ithome.com.tw/articles/10326761)\n","createdAt":"2025-08-16T08:43:55.951Z","updatedAt":"2025-08-16T10:25:15.094Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":141,"data":{"documentId":"f86eik6bjvt71hf8wvijljp8","slug":"reac-native-new-arch","title":"reac-native-new-arch","date":"2025-08-16T08:43:55.959Z","description":"解析 React Native 新架構（New Architecture） 原理 在 DAY20 解析 React Native 現行架構（Current Architecture）原理 理解了現行架構使用橋接（bridge）溝通的缺點後，接著就要了解現行架構 React Native 開發團隊如何改進？在新的架構中又如何加強與原生模組的通訊？ 同樣的，幾個新架構的重要關鍵字必須先瞭解一下： Keywords codeGen 一個靜態類型的檢查器，會在應用程式建構 (App build time) 的時候，將靜態類型的 Javascript 程式碼（Typescript、Flow）翻譯成...","content":"\n# 解析 React Native 新架構（New Architecture） 原理\n\n在 [DAY20 解析 React Native 現行架構（Current Architecture）原理](https://ithelp.ithome.com.tw/articles/10326761) 理解了現行架構使用橋接（bridge）溝通的缺點後，接著就要了解現行架構 React Native 開發團隊如何改進？在新的架構中又如何加強與原生模組的通訊？\n\n同樣的，幾個新架構的重要關鍵字必須先瞭解一下：\n\n## Keywords\n\n### codeGen\n\n一個靜態類型的檢查器，會在**應用程式建構** (App build time) 的時候，將靜態類型的 Javascript 程式碼（Typescript、Flow）翻譯成 Fabric 和 Turbo Modules 使用的原生程式碼 和 JSI 需要的 C++。\n使用 codeGen 可以減少開發維護原生模組或程式碼的成本，只要提供 typed JavaScript 即可產生原生的程式碼了。\n\n### JSI （JavaScript Interface）\n\n一個輕量的 API，可以用於任何 JavaScript virtual machine，讓不同的平台可以用不同的 JavaScript 引擎。\nJSI 是用 C++ 寫的，它將 JavaScript 引擎嵌入 C++ 應用程式中。\n\n透過 JSI 可以直接讓 JavaScript 程式碼呼叫原生程式碼的函數，獲取原生對象的引用，然後同步地使用這些引用來訪問原生功能，不需要使用 JSON 序列化轉換資料的過程，就可以提升溝通效率。\n\n例如，想要打開手機的相機，就可以透過 JavaScript 去呼叫原生拍照的 Api ，打開相機的這項任務就會在原生程式碼中執行。\n\n### Fabric\n\nFabric 是新的 UI 渲染系統，旨在提升框架與主機平台（host platforms：原生端的平台）互用性、加強 JavaScript 與原生線程的溝通。\n\nFabric 向 JavaScript 提供了本身的函式，使用 JSI 讓 Hermes 跟原生端（C++ core）透過 ref functions 直接溝通。\n\nFabric 可以直接在 C++ 中創建 Shadow Tree，以減少渲染特定元素的步驟。\n\n### Turbo Modules\n\n就是加強版的原生模組系統（Native modules）。\n\n### Hermes\n\n針對 Android 運行 React Native 優化的 JavaScript 引擎。從版本 0.69 起 Hermes 便被設為預設的 JavaScript 引擎。\n\n# 新架構（New Architecture）\n\n![https://ithelp.ithome.com.tw/upload/images/20230924/20162496oJzBAEMebk.png](https://ithelp.ithome.com.tw/upload/images/20230924/20162496oJzBAEMebk.png)\n以下透過從應用程式的建構到啟動說明新架構運作的流程。\n\n一. 應用程式建構階段 App Build time：\n當開發人員將 React Native 打包為 APK 檔案或 IPA 檔案時，透過 build 指令將 JavaScript 編譯成 bytecode，同時透過 Codegen 將 Javascript 程式碼轉換成 c++。\n\n二. 應用程式運行階段 App Run time：\n當使用者打開應用程式時\n\n1. 應用程式會讀取 bytecode 檔案，並透過 Hermes JavaScript 引擎執行。\n2. JavaScript 直接透過 JSI 跟原生模組溝通。\n3. Turbo Module 直接透過 JSI 與 JavaScript 溝通。\n4. JavaScript 中的 React 元件將會透過 Fabric 去渲染原生 UI 畫面，同時 Fabric 也是使用 JSI 跟原生模組、JavaScript 溝通。\n5. Fabric 會使用 Yoga 引擎去計算使用者介面的佈局。\n6. Fabric 使用 Fabric Renderer 在使用者螢幕上繪製用戶介面元素，並且呼叫原生圖形 API 去處理手勢、動畫..等功能。\n\n## 新架構的改變\n\n- JSI 取代了原來的 Bridge\n- Fabric 取代了原來的 UI manerger\n- Turbo Modules 取代了原來的 Native modules\n- JavaScript 引擎不再侷限於 JavaScriptCore\n\n## 新架構帶來的效益\n\n### JSI\n\n- 使用 JSI 接口讓 native code 可以更有效率地與 Javascript 通訊。\n\n### Fabric\n\n- 使 React Native 應用程式更好地與原生應用程式的視圖之間交互運作，這意味著 React Native 可以更輕鬆地嵌入並與原生視圖（host views）進行互動，使應用程式在不同平台上更具靈活性和一致性。\n- 透過整合 React Suspense 可以更有效地取得資料。\n\n### Turbo Modules\n\n- 使用強型別的接口在不同平台可以保持一致性。\n- 舊架構中，在應用程式啟動時就要載入全部的原生模組，但是 Turbo Modules 可以啟用模組 Lazy loading ，根據需求下載需要的原生模組，讓應用程式啟動的速度更快。\n\n### Hermes\n\n- 更快的 TTI（time to interactive）：TTI 就是只當點下應用程式圖示到第一個畫面 (screen) 渲染完成的時間。根據 Meta 的研究，iOS 花費的時間下降了 63%、Android 下降 51%。打開應用程式的速度變快了。\n- 更小的應用程式 bundle。\n- 記憶體耗用量(Memory consumption) 減少。\n- 促進 JavaScript 跟原生溝通的效率。\n\n# 小結\n\n- 靜態型別的檢查提升了 JavaScript 與原生的相容性。\n- 新架構藉由響應式與流暢的介面提升了使用者體驗。\n- 新架構更好的 debug 。\n- 新架構讓手機應用程式啟動變快。\n- 新架構可以同步地處理需要立即執行的任務，而不受非同步的不確定性影響。\n\n目前 React Native 雖然有加入新架構，但是必須再另外設定才能啟用，換句話說就是目前版本還是以現行的架構運行，但可以從 React Native 在 0.68 引入新架構，再到 React Native 0.71 預設使用 TypeScript ，不難發現 React Native 開發團隊正慢慢的把整體專案往符合新架構的方向去調整。或許，預設使用新架構的版本指日可待（？\n\n#### 參考資料\n\n- [React Native 新架构分析](https://juejin.cn/post/6893032764124168206#heading-2)\n- [Deep dive into React Native’s New Architecture](https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd)\n- [ADDING REACT NATIVE TO A COMPLEX APP — PART 2: UNDER THE HOOD](https://www.nearform.com/blog/adding-react-native-to-a-complex-app-part-2-under-the-hood/)\n- [React Native New Architecture in depth (Hermes, JSI, Fabric, Yoga, Turbo Module, Codegen)](https://medium.com/@anisurrahmanbup/react-native-new-architecture-in-depth-hermes-jsi-fabric-fabric-renderer-yoga-turbo-module-1284a192a82b#1f8e)\n- [Why a New Architecture](https://reactnative.dev/docs/the-new-architecture/why)\n- [React Native New Architecture](https://medium.com/@mishraabhishek.11/react-native-new-architecture-937c76547b29)\n- [React Native Architecture: A Conceptual Overview](https://medium.com/@kdsinghak47/react-native-architecture-a-conceptual-overview-7e2794400de)\n\n:::note\n\n本篇文章原先發佈於[ithome](https://ithelp.ithome.com.tw/articles/10326854)\n","createdAt":"2025-08-16T08:43:55.963Z","updatedAt":"2025-08-16T10:25:15.104Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":143,"data":{"documentId":"gfjpxjgu282mvqd0x63omlch","slug":"react-native-versions","title":"react-native-versions","date":"2025-08-16T08:43:55.972Z","description":"React Native 各個版本更新摘要（更新至 0.74） 留意專案目前使用的 React Native 版本 React Native 版本很重要，根據 React Native 的版本號不同，所支援的功能、環境、套件相容性、渲染系統都有所不同，會大大影響後續開發的難易度。所以應去了解手上的版本的內容去設定開發環境的配置。 我整理了以下各版本的更新摘要： 由新版本至舊版本各個版本的更新摘要（0.74 ~ 0.60） React Native 0.74（2024年4月） - 推出 Yoga 3.0： 全新的 layout 引擎 - 支援 align-content:...","content":"\n# React Native 各個版本更新摘要（更新至 0.74）\n\n## 留意專案目前使用的 React Native 版本\n\nReact Native 版本很重要，根據 React Native 的版本號不同，所支援的功能、環境、套件相容性、渲染系統都有所不同，會大大影響後續開發的難易度。所以應去了解手上的版本的內容去設定開發環境的配置。\n我整理了以下各版本的更新摘要：\n\n## 由新版本至舊版本各個版本的更新摘要（0.74 ~ 0.60）\n\n### React Native 0.74（2024年4月）\n\n- 推出 Yoga 3.0： 全新的 layout 引擎\n  - 支援 `align-content: 'space-evenly'`\n  - 支援 `position: 'static'`: 只有在新架構才支援這個屬性\n- 新架構：\n  - [預設 Bridgeless 模式](https://github.com/reactwg/react-native-new-architecture/discussions/174)\n  - onLayout callback 支援 batch update :\n    本來在 onLayout callback 中的每更新一個狀態就會直接重新渲染，新版的 onLayout callback 採用 batch update 也就是將所有 onLayout callback 中的狀態都一次更新後再進行渲染提交，如此可以減少渲染的次數。\n- 新的專案預設使用 Yarn 3\n- Android 最小 SDK 版本提升至 23 (Android 6.0)\n- 刪除已經棄用的 `PropTypes`\n- 刪除已經棄用的 `PushNotificationIOS API`\n\n### React Native 0.73（2023年12月）\n\n- 提升 Debugging\n  - 在 Hermes 在後台捕獲所有 `console.log()` 調用\n- Metro 更穩定的支援 Symlink\n- 支援 Android 14\n- Kotlin 現在是官方使用 React Native 構建的 Android 應用程式的推薦語言。\n  - 快速遷移 Java 到 Kotlin：Android Studio `Code > Convert Java file to Kotlin File`\n- Android Gradle 外掛程式 (AGP) 版本從 7.4.x 更新至 8.1.x。\n- 建立 Android 應用程式必須使用 Java 17\n- Android 最小 SDK 版本提升至 21 (Android 5.0)\n- 新架構：\n  - 新增 Bridgeless 模式\n- 棄用 Flipper 與 React Native 整合: 棄用 Flipper 作為React Native debug 工具\n- 棄用 `@types/react-native`\n- ios 應用程式最低支援版本 13.4\n\n### React Native 0.72（2023年6月）\n\n- Metro 支援 Symlink：主要用來建立 monorepo\n- 開發者體驗提升：\n  - style 樣式錯誤不再以 Redbox 的形式顯示\n  - Hermes 提供可讀性更好的錯誤訊息\n  - 改進 React Native CLI 的錯誤輸出\n  - Hermes 更快編譯與加速 JSON 解析\n- 重新命名 react-native/packages：需要修改路徑、升級到 0.72\n- 移除棄用的元件：Slider、DatePickerIOS、ProgressViewIOS\n\n### React Native 0.71（2023年1月）\n\n- 預設使用 TypeScript\n- 新增 Flexbox gap 屬性\n- 修復 PropTypes： 0.66 的時候把這個屬性棄用，在這個版本又加回來（？\n- 新增 React DevTools 網頁 debug 工具\n- 優化 Hermes 性能：提升 JSON.parse 效能 30%\n- 優化新架構（New Architecture）：減少 build 的時間、Android 刪除大量 C++ 程式碼\n- 刪除 AsyncStorage and MaskedViewIOS\n\n### React Native 0.70（2022年9月）\n\n- 預設使用 Hermes 引擎\n- Codegen 配置修改\n- React Native CLI 更新至 9.0\n- 更新 Android Gradle Plugin 至 7.2.1\n- 更新 Android Gradle version 至 7.5.1\n- 更新 Metro 至 0.72\n\n### React Native 0.69（2022年6月）\n\n- 預設使用 React 18\n- 内建 Hermes\n- 更新 Android Gradle Plugin 至 7.1.1\n- React Native CLI 更新至 8.0\n- Ruby 更新至 2.7.5\n\n### React Native 0.68（2022年3月）\n\n- 更新至 Node 16 LTS ，最低支援到 Node 14\n- 更新 Android Gradle Plugin 至 7.0.1\n- 更新 Metro 至 0.67\n- 更新 Kotlin 至 1.6.10\n- 更新 Android Gradle version 至 7.3\n- 更新 Android compile and target SDK 至 31\n- 使用新架構（New Architecture）：此版開始使用 Fabric 渲染器和TurboModule 系統。有關新架構做了什麼改變可以看這篇 [DAY 21 解析 React Native 新架構（New Architecture） 原理](https://ithelp.ithome.com.tw/articles/10326854)。\n- 強制使用 JSDK 11\n\n### React Native 0.67（2022年1月）\n\n- 更新 Android Gradle version 至 7.2\n- 更新 Android Kotlin version 至 1.5.31\n- 棄用 DatePickerAndroid\n\n### React Native 0.66（2021年10月）\n\n- 支援 Android 12 、 iOS 15\n- 支援 Android 12 新的藍牙權限\n- 提供 Apple Silicon (M1) Mac、 Xcode 13、 iOS 15 更好的支援\n- Hermes 0.9.0\n- 棄用 PropTypes\n\n### React Native 0.65（2021年8月）\n\n- Hermes 0.8 支援：Hermes iOS 此版開始支援 Apple M1 晶片\n- 修正與更新無障礙功能(Accessibility)\n- JCenter 停用：不再使用 JCenter 來分發原生模組。\n- 支援 Android Gradle Plugin 7\n\n### React Native 0.64（2021年3月）\n\n- ios 支援 [Hermes](https://hermesengine.dev/)：藉由降低內存利用率、減少下載大小等方法，使用 Hermes Javascript 引擎可提升 React Native 效能。\n- Metro 配置選項 Inline Requires：縮短啟用時間\n- Hermes 支援 Proxy\n- React 17\n- 棄用 Android API levels 16-20.\n- 最低版本 Xcode 12、 CocoaPods 1.10\n- Node.js 版本支援Node 10 - Node 12\n\n### React Native 0.63（2020年7月）\n\n- LogBox 功能：改進了錯誤和警告的顯示方式，提高了可讀性。\n- Pressable 元件\n- 停止支援 iOS 9 和 Node.js 8\n\n### React Native 0.62（2020年3月）\n\n- 將 Flipper 設為預設 debugg 的開發者工具\n- 新增 dark mode 功能： Appearance module、useColorScheme hook\n\n- React Native 0.61（2019年9月）：\n\n  - Fast Refresh 功能：提高了開發體驗。\n\n- React Native 0.60（2019年7月）：\n  - 導入自動連結（Auto Linking）：取代原本的 rnpm，安裝套件將自動連結原生模組，減少連結過程的複雜性。\n  - AndroidX 支援：專案中有使用 Android 原生的程式碼或依賴的項目必須手動遷移。\n  - 預設使用 CocoaPods: ios 專案管理套件的工具\n\n如果你的接手專案低於 0.60 就要再好好考慮一下維護的成本，在升版本或維護的過程會比0.60 以上的版本難度更高，因為沒有 Auto Linking 你需要自己做好依賴與原生模組的連結。\n\n從上面各版更新的內容，我們可以從版本迭代中發現更動的幅度很大，所以在接手專案時，應該根據版號去設置環境，甚至了解該版號支援哪些內容，才可以更快上手，避免在環境建置的時候踩坑。\n\n## 根據版號內容去檢查目前專案的環境\n\n### 幫你檢查目前專案建置情況\n\n在終端機輸入：\n\n```\nnpx @react-native-community/cli doctor\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20230909/201624969pz9MA36hi.png](https://ithelp.ithome.com.tw/upload/images/20230909/201624969pz9MA36hi.png)\n透過這個指令，它會幫你檢查環境是否相容，並且列出錯誤訊息，當下即可修正。但，即使修正了這些錯誤，你的專案還是開不起來？可能就需要檢查更細節的內容了。\n\n### 取得目前專案的環境\n\n在終端機輸入：\n\n```\nnpx react-native info\n```\n\n會取得你目前的專案的環境，他會詳細地列出所有有關這個專案的環境：\n\n```\ninfo Fetching system and libraries information...\nSystem:\n  OS: macOS 13.5.1\n  CPU: (10) arm64 Apple M2 Pro\n  Memory: 614.67 MB / 32.00 GB\n  Shell:\n    version: \"5.9\"\n    path: /bin/zsh\nBinaries:\n  Node:\n    version: 16.19.1\n    path: ~/.nvm/versions/node/v16.19.1/bin/node\n  Yarn:\n    version: 1.22.19\n    path: /opt/homebrew/bin/yarn\n  npm:\n    version: 8.19.3\n    path: ~/.nvm/versions/node/v16.19.1/bin/npm\n  Watchman:\n    version: 2023.07.24.00\n    path: /opt/homebrew/bin/watchman\nManagers:\n  CocoaPods:\n    version: 1.12.1\n    path: /Users/ashely/.rvm/gems/ruby-2.7.6/bin/pod\nSDKs:\n  iOS SDK:\n    Platforms:\n      - DriverKit 22.4\n      - iOS 16.4\n      - macOS 13.3\n      - tvOS 16.4\n      - watchOS 9.4\n  Android SDK:\n    API Levels:\n      - \"27\"\n      - \"28\"\n      - \"30\"\n      - \"33\"\n      - \"33\"\n      - \"34\"\n    Build Tools:\n      - 30.0.2\n      - 30.0.3\n      - 33.0.0\n      - 33.0.1\n      - 33.0.2\n      - 34.0.0\n    System Images:\n      - android-21 | ARM 64 v8a\n      - android-21 | Google APIs ARM 64 v8a\n      - android-23 | ARM 64 v8a\n      - android-24 | ARM 64 v8a\n      - android-26 | ARM 64 v8a\n      - android-28 | ARM 64 v8a\n      - android-28 | Google ARM64-V8a Play ARM 64 v8a\n      - android-29 | ARM 64 v8a\n      - android-33 | Google APIs ARM 64 v8a\n      - android-33 | Google APIs Intel x86_64 Atom\n      - android-34 | Android TV ARM 64 v8a\n      - android-34 | Android TV Intel x86 Atom\n      - android-34 | Google TV ARM 64 v8a\n      - android-34 | Google TV Intel x86 Atom\n      - android-34 | Google APIs ARM 64 v8a\n    Android NDK: Not Found\nIDEs:\n  Android Studio: Not Found\n  Xcode:\n    version: 14.3.1/14E300c\n    path: /usr/bin/xcodebuild\nLanguages:\n  Java:\n    version: 20.0.2\n    path: /usr/bin/javac\n  Ruby:\n    version: 2.7.6\n    path: /Users/ashely/.rvm/rubies/ruby-2.7.6/bin/ruby\nnpmPackages:\n  \"@react-native-community/cli\": Not Found\n  react:\n    installed: 18.2.0\n    wanted: 18.2.0\n  react-native:\n    installed: 0.72.4\n    wanted: 0.72.4\n  react-native-macos: Not Found\nnpmGlobalPackages:\n  \"*react-native*\": Not Found\nAndroid:\n  hermesEnabled: true\n  newArchEnabled: false\niOS:\n  hermesEnabled: true\n  newArchEnabled: false\n```\n\n根據筆者經驗，其中有幾個版號需要特別注意的，常常應用程式 build 失敗都跟這些版號設定有關：\n\n- Node.js\n- CocoaPods\n- iOS SDK\n- Android SDK\n- Java\n- Xcode\n\n通常專案無法編譯，有可能是因為環境與當前 React Native 版本不相容，如果真的建置專案環境時遇到困難，使用 `npx react-native info` 把你的環境列出來會對於你在社群發問時有幫助的。\n\n### 參考資料\n\n[React Native 官方 blog](https://reactnative.dev/blog)\n","createdAt":"2025-08-16T08:43:55.976Z","updatedAt":"2025-08-16T10:25:15.113Z","publishedAt":null,"locale":null,"author":null}}
{"type":"api::post.post","id":147,"data":{"documentId":"wxb8rapsef0brw9rxmdkwevk","slug":"ueseffect","title":"uesEffect 其實不是 functional component 的 API","date":"2025-08-16T08:43:55.836Z","description":"","content":"\nuseEffect hook 最主要的作用在於處理與畫面無關的 side effect，並非是 functional component 的生命週期API，因為這個處理副作用的 hook 不論呼叫幾次都不應該影響的資料流或是程式邏輯。\n\n## useEffect 的 dependencies 機制設計的目的\n\nuseEffect 的 dependencies 機制設計的目的是為了讓 React 能夠正確地同步資料，並且優化效能。\n在 dependencies 中傳入 side effect 函式所需要依賴的資料，react 就會在每一個渲染時使用\n`object.is` 來比較前後兩次的 dependencies 依賴的原始資料否有變化，若有變化就會執行 side effect 函式，沒有就可以跳過這次 side effect 的執行。\n\ndependencies 並非是為了控制 side effect 執行的時機或商業邏輯，而是為了讓 react 可以正確地同步化資料，所以應誠實地填寫有依賴到的原始資料到 dependencies 中。\n\n## 在 useEffect 中，根據 dependencies 的不同情境運作的方式：\n\n### dependencies 為空陣列\n\n```jsx\nimport React, { useEffect, useState } from \"react\";\nfunction App() {\n  useEffect(() => {\n    console.log(\"Component rendered\");\n  }, []);\n  return <div>My Component</div>;\n}\n```\n\n運作流程：\n\n- render：\n\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段：瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。然後使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n  - mount： 執行 side effect，印出 \"Component rendered\"。\n\n- re-render: 假設之後因畫面更新觸發 re-render，由於 dependencies 為空陣列，react 會比較前後兩次的 dependencies 依賴的原始資料，發現沒有變化，因此不會執行 side effect。\n\n### dependencies 中傳入 useState\n\n```jsx\nimport React, { useEffect, useState } from \"react\";\nfunction App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"Component rendered\");\n  }, [count]);\n  return (\n    <div>\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\n        Click me\n      </button>\n      <div>{count}</div>\n    </div>\n  );\n}\n```\n\n運作流程：\n\n- render：\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段：瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。然後使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n  - mount： 執行 side effect，印出 \"Component rendered\"。\n- re-render:\n  - 當點擊 button 時觸發 `setCount((prevCount)=>prevCount+1)`，count 的值更新到 1。\n  - `object.is()` 檢查前後兩次的 count 值，發現有變化，因此進入 reconciliation 階段，重新 render。\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段： 將前後兩次的 react element 進行樹狀結構的比較，找出差異，並且只會去操作新舊 react element 差異所對應的實際 DOM element。\n  - mount : 透過 `object.is()`檢查 `useEffect` dependencies 中所有的項目，發現所依賴的資料 count 值有變化，因此執行 side effect，印出 \"Component rendered\"。\n\n### 不傳入 dependencies\n\n```jsx\nimport React, { useEffect, useState } from \"react\";\nfunction App() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log(\"Component rendered\");\n  });\n  return (\n    <div>\n      <button onClick={() => setCount((prevCount) => prevCount + 1)}>\n        Click me\n      </button>\n      <div>{count}</div>\n    </div>\n  );\n}\n```\n\n運作流程：\n\n- render：\n\n  - render 階段：react 執行 App component function 產出 react element。\n  - commit 階段：瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。然後使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n  - mount： 執行 side effect，印出 \"Component rendered\"。\n\n- re-render: 假設之後因畫面更新觸發 re-render，沒有傳入 dependencies，因此沒有參考的依賴資料，只要重新渲染就會執行一次 side effect，印出 \"Component rendered\"。\n\n## 總結：\n\n- 空陣列：useEffect 只在初次 mount 時執行一次，不會再執行。\n- 傳入依賴項：依賴項改變時執行副作用函式，狀態變化正確同步。\n- 無依賴項：每次渲染都會執行副作用，這可能會導致不必要的效能問題。\n","createdAt":"2025-08-16T08:43:55.856Z","updatedAt":"2025-08-16T09:03:07.101Z","publishedAt":"2025-08-16T09:03:07.106Z","locale":null,"author":null}}
{"type":"api::post.post","id":152,"data":{"documentId":"lsmz17dpsvvar7hbz1lve7pt","slug":"getelementsbyclassname","title":"getElementsByClassName() 手寫實作","date":"2025-08-16T08:43:54.154Z","description":"","content":"\n# getElementsByClassName() 手寫實作\n\n`getElementsByClassName()` 是一個 DOM API，可以用來取得指定 class 名稱的 DOM 元素，並且會回傳一個 HTMLCollection 物件。\n\n## 輸入參數\n\n- 一個 element 作為起始搜尋的根節點。\n- 一個 classNames 字串，包含要搜尋的 class 名稱，可以是單個或多個，用空白分隔。\n\n## 功能需求\n\n- 搜尋 element 的所有後代（不包含自身）是否包含指定的 class 名稱。\n- 如果節點的 classList 包含了所有指定的 class 名稱，就將其加入結果陣列中。\n- 最終返回一個陣列（`Array<Element>`），而非類陣列（`HTMLCollection`）。\n- 不使用 `document.querySelectorAll()`\n\n## 範例\n\n```js\nconst doc = new DOMParser().parseFromString(\n  `<div class=\"foo bar baz\">\n    <span class=\"bar baz\">Span</span>\n    <p class=\"foo baz\">Paragraph</p>\n    <div class=\"foo bar\"></div>\n  </div>`,\n  \"text/html\",\n);\n\ngetElementsByClassName(doc.body, \"foo bar\");\n// [div.foo.bar.baz, div.foo.bar]\n```\n\n## 實作思路\n\n由於 DOM 是樹狀結構，透過 **遞迴** 進行可以方便地遍歷所有的子節點及其後代，並將符合條件的節點加入陣列中。\n\n搜尋的 className 字串可能包含多個 class 名稱，因此需要將其拆分為多個 class 名稱，並逐一檢查是否為目標節點的子集合。\n\n```ts\n//透過 Array.from(a) 將 Set 轉為陣列，並用 every 方法逐一檢查 classList.contains(value) 是否為 true ，就可以確認是否為要找尋的目標 class name。\nfunction isSubset(a: Set<string>, b: DOMTokenList) {\n  return Array.from(a).every((value) => b.contains(value));\n}\n\nexport default function getElementsByClassName(\n  element: Element,\n  //一個 classNames 字串，包含要搜尋的 class 名稱，可以是單個或多個，用空白分隔。\n  classNames: string,\n): Array<Element> {\n  const elements: Array<Element> = [];\n  //首先將輸入的 classNames 字串轉換為一個 Set，便於進行比對。\n  //使用 trim() 移除多餘的空白，並用正規表達式 /\\s+/ 拆分字串為多個 class 名稱。\n  const classNamesSet = new Set(classNames.trim().split(/\\s+/));\n\n  function traverse(el: Element) {\n    if (el == null) {\n      return;\n    }\n    //此函式檢查 classNamesSet 是否為目標節點 classList 的子集合。\n    if (isSubset(classNamesSet, el.classList)) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n```\n","createdAt":"2025-08-16T08:43:45.830Z","updatedAt":"2025-08-16T09:05:28.197Z","publishedAt":"2025-08-16T09:05:28.202Z","locale":null,"author":null}}
{"type":"api::post.post","id":156,"data":{"documentId":"g2k3tkcck36qwnm72lwm2ko9","slug":"2023-ironman-event","title":"2023 iThome 鐵人賽頒獎典禮後記","date":"2025-08-16T08:43:53.992Z","description":"第一次參加了而且完成了 it 鐵人賽的挑戰，雖然這次沒有得獎，但好奇頒獎典禮拿獎的都會是什麼樣的人，還有會有什麼有趣的內容、再加上這次組隊的朋友拿獎了，就決定去頒獎典禮看看。 地點好像跟之前幾屆的一樣在輔大的百鍊廳，從校門口走到百鍊廳有點距離，~~想當初上次來輔大還只是個高中生~~ 開箱：鐵人鍊成獎＋團隊鍊成獎 到了報到處，拿到了一個神秘的紙袋，裡面包含了頒獎典禮的與會吊牌，還有鐵人賽的獎狀、跟個人完賽與團賽的獎牌跟一個鐵人鍊成的紀念卡套，喔，如果有得獎的話，鐵人鍊成獎牌就要上台領獎的時候才會拿到有包含獎項名字的獎牌。（基本上，如果沒得獎的話領完就可以走了（？","content":"\n第一次參加了而且完成了 it 鐵人賽的挑戰，雖然這次沒有得獎，但好奇頒獎典禮拿獎的都會是什麼樣的人，還有會有什麼有趣的內容、再加上這次組隊的朋友拿獎了，就決定去頒獎典禮看看。\n\n![](./20240106_134049.jpg)\n\n<!--truncate-->\n\n地點好像跟之前幾屆的一樣在輔大的百鍊廳，從校門口走到百鍊廳有點距離，~~想當初上次來輔大還只是個高中生~~\n\n![](./20240106_134000.jpg)\n\n## 開箱：鐵人鍊成獎＋團隊鍊成獎\n\n到了報到處，拿到了一個神秘的紙袋，裡面包含了頒獎典禮的與會吊牌，還有鐵人賽的獎狀、跟個人完賽與團賽的獎牌跟一個鐵人鍊成的紀念卡套，喔，如果有得獎的話，鐵人鍊成獎牌就要上台領獎的時候才會拿到有包含獎項名字的獎牌。（基本上，如果沒得獎的話領完就可以走了（？\n\n![](./20240106_172410.jpg)\n\n![](./20240107_155321.jpg)\n\n很特別的是卡套的裡面放了一張卡片，掃了 QRcode 就可以連結到自己的鐵人賽文章。\n\n## 頒獎典禮入場\n\n場地不大，有點糟的是裡面完全收不到訊號，沒網路好焦慮～\n開場後就是一些重要的嘉賓致詞、評審致詞、然後冠軍得獎者致詞以下省略...\n\n![](./20240106_140200.jpg)\n\n![頒發佳作獎](./20240106_154646.jpg)\n\n## 收穫\n\n整場頒獎典禮下來，對我來說最有用的就是評審與一些得獎者講述了**撰寫鐵人賽的幾個重要的技巧**:\n\n- 1.平常的時候就可以多搜集幾個素材，就可以此畫出一個架構延伸內容。\n- 2.文章寫完一定要重新讀過一遍。\n- 3.圖片的比例大小會影響閱讀文章的感受。\n- 4.文章是要寫給別人閱讀的，所以字字句句需要能夠清楚表達所要傳達資訊。\n- 5.最棒的題材就是你的實務經驗。\n\n蠻有趣的是，評審有提到這次有用 ChatGpt 分析參賽者的文章做為評分的參考 XD 也有人提到他們可以辨別文章是不是 ChatGpt\n寫的，方法就是看看文章有沒有錯別字，因為 it 人國文都不太好，文章多少都會有錯別字 XD\n\n## 感想\n\n看完頒獎典禮，真心的覺得這些得獎的人真的好強，好幾個人同時報了兩組還都有拿到獎，不禁懷疑這些人都不用睡嗎？！也有人第一次參賽就拿冠軍的超厲害！\n\n老實說，我覺得要連續不中斷寫 30 天文章(而且能兼顧文章品質的)真的太痛苦了～幸好這次是組團參加，不然我一定撐不下去的，但是藉由這次的經驗讓我好好重新把過去開發時沒弄清楚的觀念重新整理過，也是個很不錯的收穫！\n\n下一屆如果要參加的話，我應該會先把整體的架構先理清楚，早一點把一些內容整理好，希望到時候我可以有時間參加。\n\n這麼『痛苦』的經驗，我推薦各位工程師有機會務必要體驗一下哈哈，除了體驗將知識內化的過程，還有提升自己寫能**讓別人看得懂**的文件的能力。\n","createdAt":"2025-08-16T08:43:45.526Z","updatedAt":"2025-08-16T10:25:14.789Z","publishedAt":"2025-08-16T10:25:14.792Z","locale":null,"author":null}}
{"type":"api::post.post","id":157,"data":{"documentId":"z0vua2p52z8jwz174ekzp9bc","slug":"2024-iroman","title":"2024 iThome 鐵人賽得獎心得","date":"2025-08-16T08:43:54.057Z","description":"2024 年是我第二次參加 iThome 舉辦的鐵人賽，這次居然入選了 佛心分享組的佳作，看到自己的作品被放到 得獎名單 的網站上，真是感到非常意外啊！ 這次選擇參加佛心分享組就是沒想要跟別人比賽，這樣寫起來壓力比較不會那麼大，雖然還是有連續 30 天發文的壓力，但是主要還是想聚焦於自己，把參加的過程當成一個練習。 參賽的初衷就只是想要加強自己前端技能，想要更清楚的把過去不太懂的知識點再加強，重新梳理一遍，練習用自己的話寫出來，大概就是一個跟自己比賽的過程，因為我很常半途而廢，能完成就覺得很不錯了，更何況得了一個小小的獎，實在是受寵若驚（？","content":"\n![](./2024120902.png)\n2024 年是我第二次參加 iThome 舉辦的鐵人賽，這次居然入選了 **佛心分享組的佳作**，看到自己的作品被放到 [得獎名單](https://ithelp.ithome.com.tw/2024ironman/reward) 的網站上，真是感到非常意外啊！\n\n<!--truncate-->\n\n![](./2024120901.png)\n\n這次選擇參加佛心分享組就是沒想要跟別人比賽，這樣寫起來壓力比較不會那麼大，雖然還是有連續 30 天發文的壓力，但是主要還是想聚焦於自己，把參加的過程當成一個練習。\n\n參賽的初衷就只是想要加強自己前端技能，想要更清楚的把過去不太懂的知識點再加強，重新梳理一遍，練習用自己的話寫出來，大概就是一個跟自己比賽的過程，因為我很常半途而廢，能完成就覺得很不錯了，更何況得了一個小小的獎，實在是受寵若驚（？）\n\n這次鐵人賽的作品：\nhttps://ithelp.ithome.com.tw/users/20162496/ironman/7698\n\n同時也有整理在這邊：\nhttps://wintersprouter.github.io/frontend-notes/docs/tags/2024-i-t鐵人賽\n\n這次好像有得到一個 2024 賽季紀念品，等到時候收到再分享上來。\n","createdAt":"2025-08-16T08:43:45.603Z","updatedAt":"2025-08-16T10:25:14.802Z","publishedAt":"2025-08-16T10:25:14.805Z","locale":null,"author":null}}
{"type":"api::post.post","id":158,"data":{"documentId":"cpukq887lkekoejmqopmat4u","slug":"hosting","title":"Hosting 提升","date":"2025-08-16T08:43:54.231Z","description":"Hosting 提升 Hosting 提升指的是在執行 JavaScript 程式碼之前， JavaScript 引擎會將變數和函式的宣告提升到作用域的頂端。 當瀏覽器運行 Javascript 引擎的時候也就是 runtime 時，會進入創造階段： 創造階段 首先進入創造階段，JavaScript 引擎會會將幫所有的變數和函式準備記憶體的空間，此時的變數與函式會提升。 var 變數的提升 var 變數的宣告會被提升到作用域的的頂端，但賦值（值的初始化）不會被提升。因此，在提升後變數會被初始化為 undefined。","content":"\n# Hosting 提升\n\nHosting 提升指的是在執行 JavaScript 程式碼之前， JavaScript 引擎會將變數和函式的宣告提升到作用域的頂端。\n\n當瀏覽器運行 Javascript 引擎的時候也就是 runtime 時，會進入創造階段：\n\n## 創造階段\n\n首先進入創造階段，JavaScript 引擎會會將幫所有的變數和函式準備記憶體的空間，此時的變數與函式會提升。\n\n### var 變數的提升\n\nvar 變數的宣告會被提升到作用域的的頂端，但賦值（值的初始化）不會被提升。因此，在提升後變數會被初始化為 undefined。\n\n```js\nvar counts = 2;\n```\n\n當提升時可以理解成以下：\n\n```js\nvar counts; //提升到函式作用域的的頂端，這時候的 counts 值是 undefined\ncounts = 2; //此時賦值 2\n```\n\n### const 變數和 let 變數的提升\n\nlet 和 const 宣告也會被提升，但與 var 不同的是，它們不會被初始化為 undefined，而是會進入「暫時死區」（TDZ, Temporal Dead Zone），直到程式執行到宣告它們的那一行為止。如果在此之前訪問它們，會拋出 ReferenceError。\n\n```js\nlet counts = 3;\nconst times = 5;\n```\n\n當提升時可以理解成以下：\n\n```js\ncounts; // ReferenceError 因為尚未被宣告\ntimes; // ReferenceError 因為尚未被宣告\nlet counts = 3; //宣告並且賦值\nconst times = 5; //宣告並且賦值\n```\n\n### 函式陳述式提升\n\n函式陳述式會包完整的函式被提升到作用域頂部，此時的函式是可以在宣告前被呼叫的。\n\n```js\nsayHi();\n\nfunction sayHi() {\n  console.log(\"Hi!\");\n}\n```\n\n當提升時可以理解成以下：\n\n```js\nfunction sayHi() {\n  console.log(\"Hi!\");\n}\n\nsayHi(); //此時呼叫會印出 \"Hi!\"\n```\n\n### 函式表達式提升\n\n視同變數的提升，一樣會被提升到函式作用域的頂部。\n函式表達式的變數宣告部分會被提升，但賦值為函式的部分不會。因此，提升後變數是 undefined，試圖呼叫它會導致錯誤。\n\n```js\nsayHi();\n\nvar sayHi = function () {\n  console.log(\"Hi!\");\n};\n```\n\n當提升時可以理解成以下：\n\n```js\nvar sayHi; //此時的值會是 undefined\nsayHi(); //Uncaught TypeError: sayHi is not a function\nsayHi = function () {\n  console.log(\"Hi!\");\n};\n```\n\n## 執行階段\n\n這時候會實際執行程式碼，並且將值賦予給變數。\n\n---\n\n## 實例練習\n\n[45. Hoisting VI](https://bigfrontend.dev/quiz/Hoisting-VI)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nvar foo = 1;\n(function () {\n  console.log(foo);\n  foo = 2;\n  console.log(window.foo);\n  console.log(foo);\n  var foo = 3;\n  console.log(foo);\n  console.log(window.foo);\n})();\n```\n\n## 解題\n\n```js\n// 創造階段： var foo 會被提升到作用域頂部，但尚未賦值\nvar foo;\nfoo = 1;\n//\n(function () {\n  var foo; // 創造階段：在 IIFE（立即執行函數）內的 var foo 被提升到最頂端，但尚未賦值\n  console.log(foo); //undefined\n  foo = 2;\n  console.log(window.foo); // window.foo 指的是全局變數 foo，它的值在最開始被賦值為 1，所以這裡會輸出 1\n  console.log(foo); // 這裡的 foo 指的是函式內的變數，已經被賦值為 2，所以輸出 2\n  foo = 3;\n  console.log(foo); //3 // 這裡的 foo 指的是函式內的變數，已經被賦值為 3，所以輸出 3\n  console.log(window.foo); //1 // window.foo 指的是全局變數 foo，它的值在最開始被賦值為 1，所以這裡會輸出 1\n})();\n```\n","createdAt":"2025-08-16T08:43:45.971Z","updatedAt":"2025-08-16T10:25:14.826Z","publishedAt":"2025-08-16T10:25:14.828Z","locale":null,"author":null}}
{"type":"api::post.post","id":159,"data":{"documentId":"n68qoyu17sint8l6xv6j3caa","slug":"equality-operator","title":"== 和 === 的差異","date":"2025-08-16T08:43:54.324Z","description":"JavaScript 中 == 和 === 的差異 == 是鬆散比較運算子、===是嚴格比較運算子，兩者最大的不同：==是當等號兩邊 values 的型別不同時，會強制轉換資料型別與值，而 === 不會。 === 嚴格比較 必須等號雙邊的值與型別一致，才會回傳 true，如果型別不同，即使值相同，也會回傳 false。 == 鬆散比較 == 會當等號運算子兩邊值的型別不同時，會在將兩邊的值進行比較之前，強制轉換型別和值，再進行比較。 常見的強制轉換規則 - Boolean,String,Number型別比較時會轉換為數字。 - true 會轉換為 1 ， false 會轉換為 0。","content":"\n# JavaScript 中 == 和 === 的差異\n\n`==` 是鬆散比較運算子、`===`是嚴格比較運算子，兩者最大的不同：`==`是當等號兩邊 values 的型別不同時，會強制轉換資料型別與值，而 `===` 不會。\n\n## `===` 嚴格比較\n\n必須等號雙邊的值與型別一致，才會回傳 `true`，如果型別不同，即使值相同，也會回傳 `false`。\n\n## `==` 鬆散比較\n\n`==` 會當等號運算子兩邊值的型別不同時，會在將兩邊的值進行比較之前，強制轉換型別和值，再進行比較。\n\n### 常見的強制轉換規則\n\n- `Boolean`,`String`,`Number`型別比較時會轉換為數字。\n- `true` 會轉換為 `1` ， `false` 會轉換為 `0`。\n- `null == undefined` 回傳 `true`，因為它們被認為是\"相等的\"，即使型別不同。\n- `null` 和 `undefined` 與其他任何值比較（如數字、布林值、字串等）時，會回傳 `false`。\n- 當一個物件與一個原始值進行比較時，會嘗試使用 `valueOf` 方法將物件轉換為一個原始值。\n- 當一個陣列與一個非陣列值進行比較時，會使用陣列的 `toString` 方法轉換成字串。\n\n## Object.is()\n\n比 `===` 更嚴格的比較，會檢查傳入兩個的值是否為相同值，然後會回傳 Boolean 。\n與 `===` 不同的是：\n\n- `===`會將`-0` 和 `+0` 視為相等，但`Object.is()`視為不同值。\n- `===`會將`NaN`和`NaN`視為不同相等，但`Object.is()`視為相等。\n\n---\n\n## 實例練習1\n\n[10. Equal](https://bigfrontend.dev/quiz/Equal-1)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(0 == false);\nconsole.log(\"\" == false);\nconsole.log([] == false);\nconsole.log(undefined == false);\nconsole.log(null == false);\nconsole.log(\"1\" == true);\nconsole.log(1n == true);\nconsole.log(\" 1     \" == true);\n```\n\n## 解題1\n\n```js\nconsole.log(0 == false);\n```\n\n`true`，因為 `false` 會被強制型別轉換成 `0`，`0 == 0` 值相等。\n\n```js\nconsole.log(\"\" == false);\n```\n\n`true`，因為空字串跟 `false` 會被強制型別轉換成 `0`。\n\n```js\nconsole.log([] == false);\n```\n\n`true`，因為空陣列會先被轉成空字串，空字串會再轉成 `0`，`false` 會被轉成 `0`，`0 == 0` 值相等。\n\n```js\nconsole.log(undefined == false);\n```\n\n`false`，因為 `undefined` 只會與 `null` 寬鬆相等。\n\n```js\nconsole.log(null == false);\n```\n\n`false`，因為 `null` 只會與 `undefined` 寬鬆相等。\n\n```js\nconsole.log(\"1\" == true);\n```\n\n`true`，因為 `\"1\"` 會被轉成 `1` ，`true` 會被轉成 `1` ，`1 == 1` 值相等。\n\n```js\nconsole.log(1n == true);\n```\n\n`true`，因為 `1n` 會從 BigInt 轉成 `1`，`true` 會被轉成 `1` ，`1 == 1` 值相等。\n\n```js\nconsole.log(\" 1     \" == true);\n```\n\n`true`，因為 `\" 1 \"` 會轉成 `1`，true 會被轉成 `1` ，`1 == 1` 值相等。\n\n## 實例練習2\n\n[24. Equality & Sameness](https://bigfrontend.dev/quiz/Equality-Sameness)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(0 == \"0\");\nconsole.log(0 === \"0\");\nconsole.log(Object.is(0, \"0\"));\n\nconsole.log(0 == 0);\nconsole.log(0 === 0);\nconsole.log(Object.is(0, 0));\n\nconsole.log(0 == -0);\nconsole.log(0 === -0);\nconsole.log(Object.is(0, -0));\n\nconsole.log(NaN == NaN);\nconsole.log(NaN === NaN);\nconsole.log(Object.is(NaN, NaN));\n\nconsole.log(0 == false);\nconsole.log(0 === false);\nconsole.log(Object.is(0, false));\n```\n\n## 解題2\n\n```js\nconsole.log(0 == \"0\");\n```\n\n`true`，鬆散比較會強制轉換 `\"0\"` 的型別為 `0` ， `0 == 0` 值相等。\n\n```js\nconsole.log(0 === \"0\");\n```\n\n`false`，因嚴格比較兩邊的型別需相同。\n\n```js\nconsole.log(Object.is(0, \"0\"));\n```\n\n`false`，因 `Object.is` 進行同值嚴格比較，兩個型別不同。\n\n```js\nconsole.log(0 == 0);\n```\n\n`true`，兩邊值相同。\n\n```js\nconsole.log(0 === 0);\n```\n\n`true`，兩邊值相同。\n\n```js\nconsole.log(Object.is(0, 0));\n```\n\n`true`，兩邊值相同。\n\n```js\nconsole.log(0 == -0);\n```\n\n`true`，`0`跟 `-0`在 JavaScript 中鬆散比較被認為是相等的。\n\n```js\nconsole.log(0 === -0);\n```\n\n`true`，`0`跟 `-0`在 JavaScript 中嚴格比較被認為是相等的。\n\n```js\nconsole.log(Object.is(0, -0));\n```\n\n`false`，因 `Object.is` 進行同值嚴格比較認為 `0` 和 `-0` 是不相等的。\n\n```js\nconsole.log(NaN == NaN);\n```\n\n`false`，在 JavaScript 中，`NaN（Not-a-Number)` 與任何值都不相等，包括它自己。\n\n```js\nconsole.log(NaN === NaN);\n```\n\n`false`，在 JavaScript 中，`NaN（Not-a-Number)` 與任何值都不相等，包括它自己。\n\n```js\nconsole.log(Object.is(NaN, NaN));\n```\n\n`true`，因 `Object.is`認為 `NaN` 與 `NaN` 是相等的。\n\n```js\nconsole.log(0 == false);\n```\n\n`true`，因為鬆散比較 `false` 會轉型為 `0` ， `0 == 0` 值相等。\n\n```js\nconsole.log(0 === false);\n```\n\n`false`，因嚴格比較兩邊的型別需相同。\n\n```js\nconsole.log(Object.is(0, false));\n```\n\n`false`，因兩個值的類型不同。\n\n## 實例練習3\n\n[30. Equal II](https://bigfrontend.dev/quiz/Equal-II)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log([1] == 1);\nconsole.log([1] == \"1\");\nconsole.log([\"1\"] == \"1\");\nconsole.log([\"1\"] == 1);\nconsole.log([1] == [\"1\"]);\nconsole.log(new Boolean(true) == 1);\nconsole.log(new Boolean(true) == new Boolean(true));\nconsole.log(Boolean(true) == \"1\");\nconsole.log(Boolean(false) == [0]);\nconsole.log(new Boolean(true) == \"1\");\nconsole.log(new Boolean(false) == [0]);\nconsole.log(null == undefined);\n```\n\n## 解題3\n\n```js\nconsole.log([1] == 1);\n```\n\n`true`，在鬆散比較下，當一個陣列與一個非陣列值進行比較時，會使用陣列的 `toString` 方法轉換成字串，`[1]` 會被轉換為 `\"1\"`，`\"1\"`再轉成 `1`，`1 == 1` 值相等。\n\n```js\nconsole.log([1] == \"1\");\n```\n\n`true`，在鬆散比較下 `[1]` 會轉成`\"1\"`，`\"1\"== \"1\"`值相等。\n\n```js\nconsole.log([\"1\"] == \"1\");\n```\n\n`true`，在鬆散比較下 `[\"1\"]` 會轉成`\"1\"`，`\"1\"== \"1\"`值相等。\n\n```js\nconsole.log([\"1\"] == 1);\n```\n\n`true`，在鬆散比較下 `[\"1\"]` 會轉成`\"1\"`，，`\"1\"`再轉成 `1`，`1 == 1` 值相等。\n\n```js\nconsole.log([1] == [\"1\"]);\n```\n\n`false`，因為 `[\"1\"]`、`[1]` 都是陣列，兩個物件的參考的記憶體位置不相同。\n\n```js\nconsole.log(new Boolean(true) == 1);\n```\n\n`true`，在鬆散比較下，當一個物件與一個原始值進行比較時，JavaScript 會嘗試使用 `valueOf` 方法將物件轉換為一個原始值，`new Boolean(true)`轉成`true`，`true`再轉換成`1`，`1 == 1` 值相等。\n\n```js\nconsole.log(new Boolean(true) == new Boolean(true));\n```\n\n`false`，因為兩個物件相比較時，會檢查兩個物件的參考的記憶體位置是否相同。\n\n```js\nconsole.log(Boolean(true) == \"1\");\n```\n\n`true`，`Boolean(true)` 會返回 `true` ，`true` 轉為 `1` ，\"1\" 轉為 1，`1 == 1` 值相等。\n\n```js\nconsole.log(Boolean(false) == [0]);\n```\n\n`true`，`Boolean(false)` 會返回 `false`，`[0]` 會轉成 `\"0\"`， `false`再轉成 `0`， `\"0\"`再轉成 `0`，`0 == 0`值相等。\n\n```js\nconsole.log(new Boolean(true) == \"1\");\n```\n\n`true`，`new Boolean(true)` 轉成 `true` ， `\"1\"` 轉成 `1`， `true` 再轉成 `1`， `1 == 1`值相等。\n\n```js\nconsole.log(new Boolean(false) == [0]);\n```\n\n`false`，因為 `new Boolean(false)`、`[0]` 分別是陣列跟物件，兩個參考的記憶體位置不相同。\n\n```js\nconsole.log(null == undefined);\n```\n\n`true`，在鬆散比較中 `null` 跟 `undefined` 是相等的。\n","createdAt":"2025-08-16T08:43:46.184Z","updatedAt":"2025-08-16T10:25:14.838Z","publishedAt":"2025-08-16T10:25:14.841Z","locale":null,"author":null}}
{"type":"api::post.post","id":160,"data":{"documentId":"s5a29ap1ucg4uque9k1o3pmw","slug":"event-loop","title":"Event loop 事件循環","date":"2025-08-16T08:43:54.366Z","description":"JavaScript 中的事件循環 event loop 是什麼? JavaScript 是單執行緒的語言，所以一次只能執行一件事。事件循環 Event loop 是可以確保作為單行緒語言的 Javascript 可以在執行環境(瀏覽器或Node.js)中執行非同步 (asynchronous)程式碼而不會阻塞主執行緒的機制。 事件循環 event loop 進行的流程 1. Javascript 的主執行緒開始執行 scripts，並且將同步任務放入執行棧 （call stack），直到該任務完成後才會被移除。","content":"\n# JavaScript 中的事件循環 event loop 是什麼?\n\nJavaScript 是單執行緒的語言，所以一次只能執行一件事。事件循環 Event loop 是可以確保作為單行緒語言的 Javascript 可以在執行環境(瀏覽器或Node.js)中執行非同步 (asynchronous)程式碼而不會阻塞主執行緒的機制。\n\n## 事件循環 event loop 進行的流程\n\n1. Javascript 的主執行緒開始執行 scripts，並且將同步任務放入執行棧 （call stack），直到該任務完成後才會被移除。\n\n   - 棧 stack : 是一種資料結構，特色是先進後出，當程式碼執行時函式會先被放入執行棧的最上方，當函式執行完成就會從最上方移除，接著執行執行棧最上方的函式，直到整個執行棧被清空。\n\n2. 當執行時遇到非同步的任務時，例如：呼叫 api 或 `setTimeout()`，執行環境就會呼叫 Web API or Node.js API 讓其在背景運作。\n\n3. 等待非同步的任務獲得結果後，將其 callback 放到任務隊列(task queues)中。\n\n   - 隊列 queue: 是一種資料結構，特色是先進先出，可以想像是排隊的概念。\n\n   - 任務隊列(task queues)又可以分成微任務和宏任務：\n\n   - 微任務 Micro task queue：\n\n     - Promise.then\n     - Promise.catch\n     - Promise.finally\n     - process.nextTick（Node.js 環境）\n     - MutationObserver（瀏覽器環境）\n     - queueMicrotask()\n\n   - 宏任務 Macro task queue\n\n     - setTimeout()\n     - HTTP 請求\n     - UI handler:clicks, scrolls\n     - setInterval()\n     - script(整體程式碼)\n     - UI 渲染\n     - postMessage\n     - MessageChannel\n\n4. 當執行棧 （call stack）裡面所有的同步任務被執行完，就會去讀取任務隊列(task queues)，然後把任務隊列的第一個任務加到執行棧 （call stack）執行。\n\n   **微任務優先於宏任務**\n\n   - 會優先執行所有的微任務，當所有微任務執行完畢後，如果有新的微任務被添加到隊列中，則繼續依序執行新的微任務，直到微任務隊列清空。\n   - 從宏任務隊列中取出一個任務執行，執行完，事件循環會去檢查微任務的隊列，如果有未執行的微任務就會先把微任務執行完畢。\n\n這個過程會一直無限循環下去，Javascript 有效地去處理非同步與同步的運行，並且可以避免主執行緒阻塞。\n\n＊ 文字較為抽象，這個影片的說明更有助於理解整個觀念：\n[JavaScript Visualized - Event Loop, Web APIs, (Micro)task Queue](https://www.youtube.com/watch?v=eiC58R16hb8)\n\n---\n\n## 實例練習1\n\n[1. Promise order](https://bigfrontend.dev/quiz/1-promise-order)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(1);\nconst promise = new Promise((resolve) => {\n  console.log(2);\n  resolve();\n  console.log(3);\n});\n\nconsole.log(4);\n\npromise\n  .then(() => {\n    console.log(5);\n  })\n  .then(() => {\n    console.log(6);\n  });\n\nconsole.log(7);\n\nsetTimeout(() => {\n  console.log(8);\n}, 10);\n\nsetTimeout(() => {\n  console.log(9);\n}, 0);\n```\n\n---\n\n## 解題1\n\n1. 執行 `console.log(1)`，印出 `1`\n2. 執行 `const promise = new Promise((resolve) => {...}`中的 `console.log(2)`，印出`2`，`console.log(3)`，印出`3`\n3. `console.log(4)`，印出`4`\n4. 將 `promise.then(() => {console.log(5)}).then(() => {console.log(6)})`的 callback 放到微任務隊列，\n5. 執行 `console.log(7)`，印出`7`\n6. 將 `setTimeout(() => {console.log(8)}, 10)`放到宏任務隊列，等待 10ms 後執行。\n7. 將 `setTimeout(() => {console.log(9)}, 0)`放到宏任務隊列，但因為延遲是 0ms，所以這個宏任務會在所有同步代碼執行完後的下一次事件循環中優先執行。\n8. 同步代碼全部執行完畢，檢查微任務隊列，發現有微任務\n   - 將微任務隊列的`promise.then(() => {console.log(5)}).then(() => {console.log(6)})`放到 call stack 執行\n   - 執行`console.log(5)`，印出`5`\n   - 執行`console.log(6)`印出`6`\n9. 檢查微任務隊列，發現沒有微任務，檢查宏任務隊列，發現有宏任務\n   - 執行`setTimeout(() => {console.log(9)}, 0)`，印出`9`\n   - 執行`setTimeout(() => {console.log(8)}, 10)`，印出`8`\n\n## 實例練習2\n\n[47. Promise Order II](https://bigfrontend.dev/quiz/promise-order-II)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(1);\n\nsetTimeout(() => {\n  console.log(2);\n}, 10);\n\nsetTimeout(() => {\n  console.log(3);\n}, 0);\n\nnew Promise((_, reject) => {\n  console.log(4);\n  reject(5);\n  console.log(6);\n})\n  .then(() => console.log(7))\n  .catch(() => console.log(8))\n  .then(() => console.log(9))\n  .catch(() => console.log(10))\n  .then(() => console.log(11))\n  .then(console.log)\n  .finally(() => console.log(12));\n\nconsole.log(13);\n```\n\n## 解題2\n\n1. 執行`console.log(1)`，印出`1`\n2. 把 `setTimeout(() => { console.log(2); }, 10)`放到宏任務隊列，延遲 10ms 後執行。\n3. 把 `setTimeout(() => { console.log(3); }, 0)`放到宏任務隊列中，延遲 0ms，會在事件循環的下一輪執行。\n4. 執行`new Promise((_, reject) => {...})`\n\n   - 執行`console.log(4)`，印出`4`\n   - 執行 `reject(5)`，將 `.catch()` 的回調放入微任務隊列，但不會立即執行\n   - 執行`console.log(6)`，印出`6`\n\n5. 執行`console.log(13)`，印出`13`\n6. 所有同步的程式碼都執行完了，檢查微任務隊列\n   - `reject(5)`觸發`.catch(() => console.log(8))`，印出`8`，\n   - 接著執行 `.then(() => console.log(9))`，印出`9`\n   - 接著執行 `.then(() => console.log(11))`印出`11`\n   - 接著執行 `.then(console.log)`，印出`undefined`\n   - 接著執行 `.finally(() => console.log(12))`，印出`12`\n7. 檢查微任務隊列，發現已清空，執行宏任務隊列\n   - 執行 `setTimeout(() => {console.log(3);}, 0);`印出`3`\n   - 執行 `setTimeout(() => {console.log(2);}, 10);`印出`2`\n\n## 實例練習3\n\n[103. Promise Order III](https://bigfrontend.dev/quiz/Promise-Order-III)\n\n```js\nconst createPromise = () => Promise.resolve(1);\n\nfunction func1() {\n  createPromise().then(console.log);\n  console.log(2);\n}\n\nasync function func2() {\n  await createPromise();\n  console.log(3);\n}\n\nconsole.log(4);\nfunc1();\nfunc2();\n```\n\n## 解題3\n\n1. 執行 `console.log(4)`，印出`4`\n2. 執行 `func1()`\n\n   - 執行`createPromise().then(console.log)`，這裡 `Promise.resolve(1)` 會立即 resolve，將 `console.log` 放到微任務列隊\n   - 執行 `console.log(2)`，印出`2`\n\n3. 執行 `async function func2()`\n\n   - 執行`await createPromise()`，此時`createPromise()`會立即 resolve，並暫停 `func2` 的執行，await 將控制權交還給主執行緒，並將剩下的部分`console.log(3)`放入微任務隊列\n\n4. 所有同步程式碼執行完畢，檢查微任務列隊\n   - 執行`console.log`，又`console.log`為`Promise.resolve(1)`的callback，故會印出`1`\n   - 執行`async function func2()`，執行`console.log(3)`，印出`3`\n","createdAt":"2025-08-16T08:43:46.238Z","updatedAt":"2025-08-16T10:25:14.851Z","publishedAt":"2025-08-16T10:25:14.853Z","locale":null,"author":null}}
{"type":"api::post.post","id":161,"data":{"documentId":"cqvzd675llqokcvfi7l9ac1j","slug":"event-delegation","title":"Event delegation 事件委派","date":"2025-08-16T08:43:54.399Z","description":"JavaScript 中的事件委派 event delegation 事件委派 event delegation 事件委派 event delegation 是一種 JavaScript Pattern，在父層 DOM 元素上只要綁定一個監聽器，底下的子元素就看透過事件冒泡（Event Bubbling）機制觸發父層的監聽器，如此一來就不需要在每一個子元素上綁定個監聽器，只要在其共同的父元素上綁定一個即可。 優點: - 節省記憶體：監聽器數量變少，也就可以提升效能。 - 提高程式碼維護性：處理事件的邏輯只需要在父元素的監聽器寫一次。","content":"\n# JavaScript 中的事件委派 event delegation\n\n## 事件委派 event delegation\n\n事件委派 event delegation 是一種 JavaScript Pattern，在父層 DOM 元素上只要綁定一個監聽器，底下的子元素就看透過**事件冒泡（Event Bubbling）**機制觸發父層的監聽器，如此一來就不需要在每一個子元素上綁定個監聽器，只要在其共同的父元素上綁定一個即可。\n\n優點:\n\n- 節省記憶體：監聽器數量變少，也就可以提升效能。\n- 提高程式碼維護性：處理事件的邏輯只需要在父元素的監聽器寫一次。\n- 可以支援動態元素：可以動態的調整增加子元素，不需要額外的力氣處理綁定或移除子元素上的監聽器。\n\n```html\n<ul id=\"devices\">\n  <li>iPhone 16</li>\n  <li>S24 Ultra</li>\n  <li>Pixel 9 Pro XL</li>\n</ul>\n\n<script>\n  const devices = document.getElementById(\"devices\");\n\n  devices.addEventListener(\"click\", function (event) {\n    if (event.target.tagName === \"LI\") {\n      console.log(event.target.innerText);\n    }\n  });\n</script>\n```\n\n在這個例子中，`devices`作為父元素被綁定監聽器，將當點擊`<li>`，`<li>`就透過事件冒泡向上傳遞到`devices`，接著就可以透過`event.target`來檢查實際觸發事件的子元素是否符合條件，進而執行處理事件的邏輯\n\n## 實例練習\n\n[117. event delegation](https://bigfrontend.dev/problem/event-delegation)\n\nCan you create a function which works like jQuery.on(), that attaches event listeners to selected elements.\n\nIn jQuery, selector is used to target the elements, in this problem, it is changed to a predicate function.\n\n```js\nonClick(\n  // root element\n  document.body,\n  // predicate\n  (el) => el.tagName.toLowerCase() === \"div\",\n  function (e) {\n    console.log(this);\n    // this logs all the `div` element\n  },\n);\n```\n\nevent.stopPropagation() and event.stopImmediatePropagation() should also be supported.\n\nyou should only attach one real event listener to the root element.\n\n## 解題\n\n這題太難了，所以我看了別人的解答試圖去理解。\n\n參考解答：[BFE.dev 117. event delegation | JSer - Front-End Interview questions](https://www.youtube.com/watch?v=TkBQYTi1jJU>)\n\n```js\n// Map<node, Array<[predicate, handler]>>\nconst allHandlers = new Map(); //用來儲存每個 root 元素及其對應的事件處理器。每個 root 都會對應一個 Array，其中存放了多組 [predicate, handler]\n/**\n * @param {HTMLElement} root 根元素，事件監聽器將綁定在這個元素上\n * @param {(el: HTMLElement) => boolean} predicate 判斷函數，用於檢查事件目標是否符合條件\n * @param {(e: Event) => void} handler 事件處理函數，當事件目標符合條件時呼叫\n */\nfunction onClick(root, predicate, handler) {\n  if (allHandlers.has(root)) {\n    //檢查 allHandlers 是否已經儲存了對應的 root 元素。如果已經有，則直接將新的 [predicate, handler] 對添加到該 root 元素的處理器列表中\n    allHandlers.get(root).push([predicate, handler]);\n    //將新的 [predicate, handler] 對添加到該 root 元素的處理器列表中\n    return;\n  }\n  //如果沒有對應的 root 元素，則創建一個新的數組\n  allHandlers.set(root, [[predicate, handler]]);\n  // 然後在 root 上綁定一個 click 事件監聽器\n  root.addEventListener(\n    \"click\",\n    function (e) {\n      // 從事件目標元素 e.target 開始，一層層向上遍歷 DOM 結構，直到到達 root 元素或事件冒泡被停止\n      let el = e.target;\n      const handlers = allHandlers.get(root);\n      let isPropagationStopped = false;\n      e.stopPropagation = () => {\n        //用來手動控制事件傳播，避免事件繼續冒泡到父元素\n        isPropagationStopped = true;\n      };\n      //使用 while (el) 檢查事件目標及其父元素是否符合判斷函數的條件\n      while (el) {\n        let isImmediatePropagationStopped = false;\n        e.stopImmediatePropagation = () => {\n          //isImmediatePropagationStopped 停止傳播事件的同時也停止同一元素上後續的處理器執行\n          isImmediatePropagationStopped = true;\n          isPropagationStopped = true;\n        };\n        for (const [predicate, handler] of handlers) {\n          //predicate(el)：用來判斷當前元素是否符合條件\n          if (predicate(el)) {\n            //執行對應的 handler 處理函式\n            handler.call(el, e);\n            // 檢查是否需要停止事件傳播\n            if (isImmediatePropagationStopped) {\n              break;\n            }\n          }\n        }\n        //如果 isPropagationStopped 設為 true，或者已經遍歷到 root 元素，則停止事件的繼續傳播\n        if (el === root || isPropagationStopped) break;\n        el = el.parentElement;\n      }\n    },\n    false,\n  );\n}\n```\n","createdAt":"2025-08-16T08:43:46.286Z","updatedAt":"2025-08-16T10:25:14.862Z","publishedAt":"2025-08-16T10:25:14.864Z","locale":null,"author":null}}
{"type":"api::post.post","id":162,"data":{"documentId":"q4jmgx1hru1t9rdmeoaaqnbh","slug":"script","title":"<script>, <script async> 和 <script defer> 的差異","date":"2025-08-16T08:43:54.514Z","description":", 和 的差異 透過我們可以適當的控制腳本在瀏覽器載入的時機。 這是預設的腳本加載方式，在網頁渲染的過程中，會使用 在 HTML 中載入 Javascript，當執行到時，瀏覽器會暫停解析 HTML，開始下載 腳本並且立即執行，直到 執行完畢才會繼續解析 HTML 建立 DOM。但是當需要載入的腳本很多的時候，會阻塞頁面渲染，會導致使用者體驗不佳。 - 適用於： 需要立即執行的腳本，特別是那些會影響到 HTML 結構的腳本（例如，使用 document.write() 的腳本）。","content":"\n# `<script>`, `<script async>` 和 `<script defer>` 的差異\n\n透過`<script>`我們可以適當的控制腳本在瀏覽器載入的時機。\n\n## `<script>`\n\n這是預設的腳本加載方式，在網頁渲染的過程中，會使用 `<script>` 在 HTML 中載入 Javascript，當執行到`<script>`時，瀏覽器會暫停解析 HTML，開始下載 `<script>`腳本並且立即執行，直到`<script>` 執行完畢才會繼續解析 HTML 建立 DOM。但是當需要載入的`<script>`腳本很多的時候，會阻塞頁面渲染，會導致使用者體驗不佳。\n\n```html\n<script src=\"index.js\"></script>\n```\n\n- 適用於：\n  需要立即執行的腳本，特別是那些會影響到 HTML 結構的腳本（例如，使用 document.write() 的腳本）。\n\n## Non-Blocking:`<script async>` 和 `<script defer>`\n\n使用 `async` 屬性和 `defer` 屬性可以讓 `<script>` 檔案在一開始就在背景先下載，可以避免腳本阻塞 HTML 解析。\n\n### `<script async>`\n\n`async` 屬性會非同步下載 `<script>`腳本，一旦下載好就立刻執行，開始時執行會停止解析 HTML，但下載本身不會阻塞 HTML 的解析。如果有多個 `<script>` 並不能保證 `<script>` 間執行的順序，也不確定腳本執行的時候 HTML 是否完全解析完成。\n\n- 適用於：\n  不需要依賴 DOM 或者不需要嚴格執行順序的獨立腳本的第三方函式庫，例如：GA。\n\n### `<script defer>`\n\n`defer`屬性會非同步下載 `<script>` 腳本，但是與 `async` 屬性不同的是，`defer` 屬性不會打斷 DOM 建立的過程，而是等到 HTML 解析完成，並且在 `DOMContentLoad` 執行之前執行下載好的腳本，另外，`defer` 會保證 script 是依照 `<script>` 的順序去執行。\n\n- 適用於：\n  依賴 DOM 或是跟其他模組有相互依賴的模組。\n","createdAt":"2025-08-16T08:43:46.502Z","updatedAt":"2025-08-16T10:25:14.876Z","publishedAt":"2025-08-16T10:25:14.878Z","locale":null,"author":null}}
{"type":"api::post.post","id":163,"data":{"documentId":"n2cksk0fuqh49dfbws2q766b","slug":"closure","title":"closure 閉包是什麼？如何應用？","date":"2025-08-16T08:43:54.667Z","description":"closure 閉包是什麼？如何應用？ 閉包是什麼？ closure 函式可以存取其外部函式的變數，即使外部函式已經執行完畢並離開其作用域。可以存取到外部變數的原因在於: JavaScript 使用了語法作用域（lexical scope），在函式定義時會記住函式被定義時的變數環境，並且這些變數會一直存在於記憶體中，只要閉包中的內部函式仍然在使用它們。 當外部函式執行完畢後，通常會釋放其作用域中的變數以節省記憶體。但如果某個內部函式（閉包）仍然引用這些變數，那麼這些變數將不會被釋放，而是持續存在於內部函式的作用域鏈中。","content":"\n# closure 閉包是什麼？如何應用？\n\n## 閉包是什麼？\n\nclosure 函式可以存取其外部函式的變數，即使外部函式已經執行完畢並離開其作用域。可以存取到外部變數的原因在於: JavaScript 使用了語法作用域（lexical scope），在函式定義時會記住函式被定義時的變數環境，並且這些變數會一直存在於記憶體中，只要閉包中的內部函式仍然在使用它們。\n\n當外部函式執行完畢後，通常會釋放其作用域中的變數以節省記憶體。但如果某個內部函式（閉包）仍然引用這些變數，那麼這些變數將不會被釋放，而是持續存在於內部函式的作用域鏈中。\n\n```js\nfunction outerFunction() {\n  let outerVariable = \"I am outside!\";\n\n  function innerFunction() {\n    console.log(outerVariable);\n  }\n\n  return innerFunction;\n}\n\nconst closureFunction = outerFunction();\nclosureFunction(); // I am outside!\n```\n\n- 內部函式 `innerFunction` 是閉包，它記住了 `outerFunction` 的語法作用域，它可以存取到外部變數 `outerVariable`，即使 `outerFunction` 已經執行完畢。\n\n## 閉包的應用\n\n### 資料封裝\n\n閉包可以用來模擬私有變數，使得外部無法直接存取某些變數，只能透過內部函式進行操作。\n\n```js\nfunction createCounter() {\n  let count = 0;\n\n  return function () {\n    count++;\n    console.log(count);\n  };\n}\n\nconst counter = createCounter();\ncounter(); // 1\ncounter(); // 2\n```\n\ncount 只能透過 `counter` 函式來來增加或減少值，外部無法直接存取。\n\n### 模擬私有方法和變數\n\n閉包可以用來模擬類似於物件中的私有變數和方法。\n\n```js\nfunction counter() {\n  let count = 0;\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n\n  function getCount() {\n    return count;\n  }\n\n  return {\n    increment,\n    decrement,\n    getCount,\n  };\n}\nconst teamACounter = counter();\nteamACounter.increment();\nteamACounter.increment();\nteamACounter.decrement();\nconsole.log(teamACounter.getCount()); // 1\nconst teamBCounter = counter();\nteamBCounter.increment();\nteamBCounter.increment();\nconsole.log(teamBCounter.getCount()); // 2\n```\n\n在這個例子中，`count` 變數是私有的，外部無法直接存取，只能透過 `increment`、`decrement` 和 `getCount` 這三個方法來操作。\n同時可以透過閉包的特性，創建多個獨立的 Counter，互不影響。\n\n### 事件處理（Event handlers）和回呼函式（Callbacks）\n\n閉包經常應用於事件處理或回呼函式中，特別是當需要保持一些狀態或變數時。\nReact 中的 `useState` 就是應用了閉包的特性。\n\n```js\nimport React, { useState } from \"react\";\n\nconst Button = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount((prevCount) => prevCount + 1);\n    console.log(`Button clicked ${count} times`);\n  };\n\n  return <button onClick={handleClick}>Click me</button>;\n};\n```\n\n在這個例子中，`handleClick` 函式是閉包，每次點擊按鈕都會增加 `count` 變數的值。\n\n---\n\n## 實例練習\n\n[99. closure](https://bigfrontend.dev/quiz/closure-1)\n\n```js\nlet dev = \"bfe\";\n\nfunction a() {\n  let dev = \"BFE\";\n  return function () {\n    console.log(dev);\n  };\n}\n\ndev = \"bigfrontend\";\n\na()();\n```\n\n## 解題\n\n答案是`\"BFE\"`，因為 `a()` 函式是閉包，它記住了 `a` 函式被定義時的變數環境，即 `dev` 為 \"BFE\"。\n","createdAt":"2025-08-16T08:43:46.710Z","updatedAt":"2025-08-16T10:25:14.887Z","publishedAt":"2025-08-16T10:25:14.889Z","locale":null,"author":null}}
{"type":"api::post.post","id":164,"data":{"documentId":"dalvzazm4whlh6di7x8a2i5g","slug":"prototype","title":"Prototype 原型繼承如何在 JavaScript 運作中？","date":"2025-08-16T08:43:54.744Z","description":"原型繼承如何在 JavaScript 運作中？ 原型 (Prototype) 在 JavaScript 中，每個物件都有一個內部屬性稱為 [[Prototype]]，它指向該物件的原型。原型是一個物件，包含了可以被其他物件共享的屬性和方法。 proto和[[Prototype]] - proto:是大多數現代瀏覽器中暴露出的屬性，允許開發者存取和設置物件的原型（不建議直接使用），proto目前已經棄用了。 - [[Prototype]]：描述了物件與其原型之間的隱藏式連結。","content":"\n# 原型繼承如何在 JavaScript 運作中？\n\n## 原型 (Prototype)\n\n在 JavaScript 中，每個物件都有一個內部屬性稱為 [[Prototype]]，它指向該物件的原型。原型是一個物件，包含了可以被其他物件共享的屬性和方法。\n\n## `__proto__`和`[[Prototype]]`\n\n- `__proto__`:是大多數現代瀏覽器中暴露出的屬性，允許開發者存取和設置物件的原型（不建議直接使用），`__proto__`目前[已經棄用](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)了。\n- `[[Prototype]]`：描述了物件與其原型之間的隱藏式連結。\n\n## 原型鏈(Prototype Chain)\n\n原型鏈有往上查找的特性，當存取一個物件的屬性或方法時，Javascript 會先在物件本身尋找，如果找不到就會沿著原型鏈往上尋找，直到找到為止。原型鏈是由一系列物件組成的，它們通過 **proto** 屬性彼此相連，最終指向 `Object.prototype`，原型鏈的末端。\n\n```js\n//定義一個建構子\nfunction Phone(brand, model) {\n  this.brand = brand;\n  this.model = model;\n}\n//在 Phone.prototype 上定義一個方法，所有 Phone 的實例都能訪問\nphone.prototype.ring = function () {\n  console.log(\"Ring ring!\");\n};\n//使用建構子建立一個物件\nconst myPhone = new Phone(\"Apple\", \"iPhone 16\");\n\n//存取物件的屬性\nconsole.log(myPhone.brand); // Apple\n\n//存取從原型繼承的方法\nmyPhone.ring(); // Ring ring!\n\n//原型鏈\n// myPhone.__proto__ 的原型是 Phone.prototype\nconsole.log(myPhone.__proto__ === Phone.prototype); // true\n\n// Phone.prototype 的原型是 Object.prototype\nconsole.log(Phone.prototype.__proto__ === Object.prototype); // true\n\n// Object.prototype 是原型鏈的終點，其原型為 null\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n在這個範例中，myPhone 是 Phone 建構函數的實例，它的 **proto** 屬性指向 `Phone.prototype`，這樣它可以存取 `Phone.prototype` 上的 `ring` 方法。如果 `Phone.prototype` 上也找不到某個屬性或方法，JavaScript 會繼續沿著原型鏈向上查找，直到達到 `Object.prototype`。\n\nJavaScript 中的原型繼承是基於物件之間的關聯，每個物件都有一個原型物件，通過原型鏈的機制可以實現屬性和方法的繼承，可以實現一個物件從另一個物件繼承屬性和方法，實現程式碼的重用和擴展。\n\n---\n\n## 實例練習 1\n\n[48. Prototype](https://bigfrontend.dev/quiz/prototype)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nfunction Foo() {}\nFoo.prototype.bar = 1;\nconst a = new Foo();\nconsole.log(a.bar);\n\nFoo.prototype.bar = 2;\nconst b = new Foo();\nconsole.log(a.bar);\nconsole.log(b.bar);\n\nFoo.prototype = { bar: 3 };\nconst c = new Foo();\nconsole.log(a.bar);\nconsole.log(b.bar);\nconsole.log(c.bar);\n```\n\n## 解題1\n\n```js\nfunction Foo() {}\nFoo.prototype.bar = 1;\nconst a = new Foo();\nconsole.log(a.bar); //1，Foo.prototype.bar 定義了一個屬性 bar，a 繼承了這個屬性。\n\nFoo.prototype.bar = 2;\nconst b = new Foo();\nconsole.log(a.bar); //2，Foo.prototype.bar 被重新賦值為 2，a 和 b 都繼承了這個屬性。\nconsole.log(b.bar); //2，由於 a 的原型鏈指向 Foo.prototype，所以 a.bar 也變成了 2。\n\nFoo.prototype = { bar: 3 };\nconst c = new Foo();\nconsole.log(a.bar); //2，a 的原型鏈仍然指向舊的 Foo.prototype，所以 a.bar 仍然是 2。\nconsole.log(b.bar); //2，b 的原型鏈仍然指向舊的 Foo.prototype，所以 b.bar 仍然是 2。\nconsole.log(c.bar); //3，Foo.prototype 被重新賦值為一個新物件，c 繼承了這個新物件。\n```\n\n## 實例練習 2\n\n[53. Prototype 2](https://bigfrontend.dev/quiz/prototype2)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nfunction F() {\n  this.foo = \"bar\";\n}\n\nconst f = new F();\nconsole.log(f.prototype);\n```\n\n## 解題2\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nfunction F() {\n  this.foo = \"bar\";\n}\n\nconst f = new F();\nconsole.log(f.prototype); //undefined，f 是 F 的實例，而不是 F 的原型\n```\n","createdAt":"2025-08-16T08:43:46.770Z","updatedAt":"2025-08-16T10:25:14.897Z","publishedAt":"2025-08-16T10:25:14.900Z","locale":null,"author":null}}
{"type":"api::post.post","id":165,"data":{"documentId":"a006suoz4u7nfud7zg1taf5m","slug":"synchronous-asynchronous","title":"synchronous 同步與 asynchronous 非同步","date":"2025-08-16T08:43:54.848Z","description":"同步 synchronous 與非同步 asynchronous 同步 synchronous JavaScript 中同步的概念是指程式碼的執行會依照順序進行，必須等到前一個任務完成後才能執行下一個任務。但是由於 JavaScript 是單一執行緒的程式語言，運行同步程如果其任務執行時間過久很可能會阻塞，在瀏覽器中會出現空白或凍結的情況，這會導致使用者體驗不佳。 這個例子說明了 for 迴圈是一個耗時的同步任務。在執行該迴圈時，瀏覽器將被阻塞，直到任務完成後才會執行 console.log('End')。","content":"\n# 同步 synchronous 與非同步 asynchronous\n\n## 同步 synchronous\n\nJavaScript 中同步的概念是指程式碼的執行會依照順序進行，必須等到前一個任務完成後才能執行下一個任務。但是由於 JavaScript 是單一執行緒的程式語言，運行同步程如果其任務執行時間過久很可能會阻塞，在瀏覽器中會出現空白或凍結的情況，這會導致使用者體驗不佳。\n\n```js\nconsole.log(\"Start\");\nfor (let i = 0; i < 1000000000; i++) {} // 模擬一個耗時的同步任務\nconsole.log(\"End\");\n```\n\n這個例子說明了 `for` 迴圈是一個耗時的同步任務。在執行該迴圈時，瀏覽器將被阻塞，直到任務完成後才會執行 `console.log('End')`。\n\n## 非同步 asynchronous\n\n非同步的程式碼不會阻塞主執行緒，當程式碼遇到非同步任務時，會先將任務交到交給瀏覽器或 Node.js 的背景進行處理，並繼續執行後續的程式碼。而不是等待非同步任務完成。當非同步任務完成後，會通過 `callback` 或 `Promise` 或 `async/await` 來通知 JavaScript 主執行緒，然後再執行相應的回應操作。這有助於提高程式碼的效率和效能。\n\n```js\nconsole.log(\"Start\");\nsetTimeout(() => {\n  console.log(\"Async Task Complete\");\n}, 1000); // 模擬一個 1 秒後完成的非同步任務\nconsole.log(\"End\");\n```\n\n這個例子會先印出 `Start`、`End`，然後再印出 `Async Task Complete`。這是因為 `setTimeout` 是一個非同步任務，當遇到 `setTimeout` 時，會將任務交給瀏覽器背景進行處理，並繼續執行後續的程式碼。\n\n## 總結\n\n| 特性差異 | 同步 (Synchronous)         | 非同步 (Asynchronous)                                             |\n| -------- | -------------------------- | ----------------------------------------------------------------- |\n| 執行順序 | 按照程式碼的順序，逐行執行 | 可以在執行其他程式碼的同時處理背景中的非同步任務                  |\n| 阻塞     | 任務執行時會阻塞後續程式碼 | 任務執行時不會阻塞後續程式碼                                      |\n| 應用場景 | 資料處理、簡單邏輯運算     | 呼叫 http request、計時器、事件監聽器、檔案讀取、資料庫查詢等     |\n| 實現方式 | 順序執行                   | 非同步函式、`Promise`、`async/await`、事件監聽器、`setTimeout` 等 |\n","createdAt":"2025-08-16T08:43:54.912Z","updatedAt":"2025-08-16T10:25:14.911Z","publishedAt":"2025-08-16T10:25:14.914Z","locale":null,"author":null}}
{"type":"api::post.post","id":166,"data":{"documentId":"lud2kvvo4v4gjtjyyl0r1ac6","slug":"anonymous-function","title":"Anonymous function 匿名函式有哪些應用場景?","date":"2025-08-16T08:43:54.929Z","description":"匿名函式有哪些應用場景？ 匿名函式 anonymous function 是指在 JavaScript 中沒有名稱的函式，通常用於一次性的操作或者作為參數傳遞給其他函式，此外，匿名函式不會在編譯階段被提升到作用域的上方（這是函式表達式的特性），因此它們在程式碼執行時才會被解析。匿名函式有許多應用場景，以下是一些常見的例子： 回調函式 Callback function 匿名函式常用於作為回調函式，當某個操作完成後被執行。 這個例子中，箭頭函式 () => {} 就是一個匿名函式，用作 setTimeout 的回調函式，當計時器 1000 ms 後，會執行這個匿名函式。","content":"\n# 匿名函式有哪些應用場景？\n\n匿名函式 anonymous function 是指在 JavaScript 中沒有名稱的函式，通常用於一次性的操作或者作為參數傳遞給其他函式，此外，匿名函式不會在編譯階段被提升到作用域的上方（這是函式表達式的特性），因此它們在程式碼執行時才會被解析。匿名函式有許多應用場景，以下是一些常見的例子：\n\n## 回調函式 Callback function\n\n匿名函式常用於作為回調函式，當某個操作完成後被執行。\n\n```js\nsetTimeout(() => {\n  console.log(\"Task Complete\");\n}, 1000);\n```\n\n這個例子中，箭頭函式 `() => {}` 就是一個匿名函式，用作 `setTimeout` 的回調函式，當計時器 1000 ms 後，會執行這個匿名函式。\n\n## 立即函式 IIFE\n\n立即函式是在定義後就會立刻執行的函式，通常用於創建一個私有作用域，避免變數污染全局作用域。匿名函式在這裡用於定義立即函式。\n\n```js\n{function(){(\n    var a = 1;\n    console.log(a)//1\n)}\n}();\nconsole.log(a)//a is not defined\n```\n\n## 高階函式 Higher-order function\n\n高階函式是指接受一個或多個函式作為參數，或者返回函式。匿名函式常用於作為這類函式的回調。\n例如：`map`、`filter`、`reduce`、`sort` 等方法都接受函式作為參數：\n\n### map\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst squared = numbers.map((num) => num * num);\nconsole.log(squared); // [1, 4, 9, 16, 25]\n```\n\n### filter\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst even = numbers.filter((num) => num % 2 === 0);\nconsole.log(even); // [2, 4]\n```\n\n### reduce\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\nconsole.log(sum); // 15\n```\n\n### sort\n\n```js\nconst numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nconst sorted = numbers.sort((a, b) => a - b);\nconsole.log(sorted); // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n```\n\n## 事件處理 event handler\n\n匿名函式也常用於事件處理器中，這樣可以保持程式碼簡潔，並避免與其他函式名稱產生衝突。\n\n```js\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function () {\n  console.log(\"Button Clicked\");\n});\n```\n\n匿名函式在這裡用作事件處理函式，當按鈕被點擊時，會執行這個匿名函式。\n","createdAt":"2025-08-16T08:43:54.960Z","updatedAt":"2025-08-16T10:25:14.923Z","publishedAt":"2025-08-16T10:25:14.925Z","locale":null,"author":null}}
{"type":"api::post.post","id":167,"data":{"documentId":"mfikce30lwe90em7zfya8avi","slug":"debounce-throttle","title":"手寫 debounce 防抖函式和 throttle 節流函式","date":"2025-08-16T08:43:54.981Z","description":"手寫 debounce 防抖函式和 throttle 節流函式 防抖和節流函式是前端常見的效能優化的技巧，透過這兩個函式可以有效的減少函式被觸發的次數，達到效能優化的目的。 debounce 防抖函式 防抖函式的作用是在一段時間內只執行一次函式。當多次觸發事件時，防抖函式會在最後一次事件觸發後的一段時間內執行一次函式。如果在這段時間內再次觸發事件，計時器會重新計時。 應用場景 - 輸入框搜尋建議：當使用者在搜尋框中輸入時，如果每次按鍵都立即發送請求，這將導致過多的請求。在使用防抖函式後，只有使用者停止輸入一段時間後才會發送搜尋請求。","content":"\n# 手寫 debounce 防抖函式和 throttle 節流函式\n\n防抖和節流函式是前端常見的效能優化的技巧，透過這兩個函式可以有效的減少函式被觸發的次數，達到效能優化的目的。\n\n# debounce 防抖函式\n\n防抖函式的作用是在一段時間內只執行一次函式。當多次觸發事件時，防抖函式會在最後一次事件觸發後的一段時間內執行一次函式。如果在這段時間內再次觸發事件，計時器會重新計時。\n\n## 應用場景\n\n- 輸入框搜尋建議：當使用者在搜尋框中輸入時，如果每次按鍵都立即發送請求，這將導致過多的請求。在使用防抖函式後，只有使用者停止輸入一段時間後才會發送搜尋請求。\n- 按鈕防連點：當使用者連續點擊按鈕時，如果沒有防抖函式，每次點擊都會觸發事件。使用防抖函式後，只有最後一次點擊會觸發事件。\n- 調整瀏覽器大小事件：如果每次窗口大小調整時都進行重新渲染，會造成性能浪費。可以使用防抖讓瀏覽器大小調整完畢後才進行重繪。\n\n## 實例練習\n\n[6. implement basic debounce()](https://bigfrontend.dev/problem/implement-basic-debounce)\n\n```js\n// This is a JavaScript coding problem from BFE.dev\n\n/**\n * @param {(...args: any[]) => any} func\n * @param {number} wait\n * @returns {(...args: any[]) => any}\n */\nfunction debounce(func, wait) {\n  // your code here\n}\n```\n\n## 解題\n\n利用計時器 (setTimeout) 來延遲執行目標函式，當 debounce function 被多次觸發時，會不斷清除舊的 timeoutId 並重新計時，直到停止觸發後才執行 func\n\n```js\n/**\n * @param {(...args: any[]) => any} func 要執行的函式 func\n * @param {number} wait 等待時間 (ms)\n * @returns {(...args: any[]) => any}\n */\n\nfunction debounce(func, wait) {\n  let timeoutId;\n  return function (...args) {\n    // 每一次觸發 debounce function 時會清除之前的 timeoutId\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n    // 重新計時，設定新的 timeoutId\n    // 當 wait 時間內沒有再次觸發 debounce function 時，執行 func\n    timeoutId = setTimeout(() => func(...args), wait);\n  };\n}\n```\n\n# throttle 節流函式\n\n節流函式的作用是的作用是在多次觸發事件中，保證函式在固定的時間間隔內只執行一次。當多次觸發事件時，節流函式會在一段時間內執行一次函式 callback。如果在這段時間內再次觸發事件，函式不會被執行，直到這段時間結束。\n\n## 應用場景\n\n- 滾動事件監聽器：當用戶滾動頁面時，可以使用節流控制事件觸發次數，避免高頻率地調用處理函式。\n- 按鈕點擊：限制點擊按鈕的次數，避免用戶短時間內多次點擊造成多次請求或響應。\n\n## 手寫 throttle 節流函式\n\n1. 檢查時間是否到達，如果到達執行函式，否則不執行。\n2. 設定 timer，等待 wait 時間後清除 timer。\n\n```js\n/**\n * @param {(...args:any[]) => any} func 要執行的函式 func\n * @param {number} wait 等待時間 (ms)\n * @returns {(...args:any[]) => any}\n */\nfunction throttle(func, wait) {\n  let timer = null;\n\n  return function (...args) {\n    // 如果 timer 存在，表示還在節流等待期間，不執行函式\n    if (timer) return;\n\n    // 設定 timer，等到 wait 時間結束後執行 callback 並清除 timer\n    timer = setTimeout(() => {\n      timer = null;\n    }, wait);\n\n    // 時間到，執行 callback 函式\n    func.apply(this, args);\n  };\n}\n```\n","createdAt":"2025-08-16T08:43:55.025Z","updatedAt":"2025-08-16T10:25:14.933Z","publishedAt":"2025-08-16T10:25:14.935Z","locale":null,"author":null}}
{"type":"api::post.post","id":168,"data":{"documentId":"qdm8hfvgjw7pv43x15ibtboi","slug":"interface-type","title":"Interface 和 Type 的差別","date":"2025-08-16T08:43:55.066Z","description":"Interface 和 Type 的差別 1.TypeScript 編譯器推論結果不同 Type 宣告 Type 時，所使用的名稱代表的是其背後的型別結構 Interface Interface 介面宣告時會使用名稱代表 TypeScript 編譯器推論的結果 2.Type 和 Interface 的擴展性差異 Type Type 較適合靜態、變動性較小的資料結構，並且可以表達任一型別。 雖然 Type 無法擴充，但可以使用交集運算子 & 來合併多個 Type。","content":"\n# Interface 和 Type 的差別\n\n## 1.TypeScript 編譯器推論結果不同\n\n### Type\n\n宣告 `Type` 時，所使用的名稱代表的是其背後的型別結構\n\n```typescript\ntype Person = {\n  name: string;\n  age: number;\n  gender: string;\n};\ntype Employee = Person;\n\n/**\n * TypeScript 編譯器推論結果為：\n * type Employee =\n * {\n *   name: string;\n *   age: number;\n *   gender: string;\n * }\n **/\n```\n\n### Interface\n\nInterface 介面宣告時會使用名稱代表 TypeScript 編譯器推論的結果\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n  gender: string;\n}\ntype Employee = Person; // TypeScript 編譯器推論結果為： type Employee = Person\n```\n\n## 2.Type 和 Interface 的擴展性差異\n\n### Type\n\nType 較適合靜態、變動性較小的資料結構，並且可以表達任一型別。\n\n```typescript\ntype Phone = {\n  brand: string;\n  model: string;\n  price: number;\n};\n```\n\n雖然 Type 無法擴充，但可以使用交集運算子 `&` 來合併多個 Type。\n然而，與 Interface 不同的是，Type 不能進行重新開放（declaration merging），這意味著無法多次聲明一個 Type 來合併屬性。\n\n```typescript\ntype Person = {\n  name: string;\n};\n\ntype Employee = Person & {\n  salary: number;\n};\n```\n\n另外，Type 不僅限於物件也可以用於其他型別的別名，像是聯合型別、函數型別、原始型別等。\n\n```typescript\n// 原始型別別名\n\ntype StringAlias = string;\n\n// 聯合型別\ntype UnionType = string | number;\n\n// 函數型別\ntype FunctionType = (a: number, b: number) => number;\n```\n\n### Interface\n\nInterface 的宣告較為靈活，可以用來描述物件、函式、類別、JSON物件等...，並且可以自由的進行擴充。\n\n```typescript\ninterface Person {\n  name: string;\n}\n\ninterface Person {\n  age: number;\n}\n\n// 合併後的 Person 會包含 name 和 age 屬性\nconst person: Person = {\n  name: \"John\",\n  age: 30,\n};\n```\n\nInterface 支持宣告合併（declaration merging），這表示可以多次宣告同一個 Interface，並且 TypeScript 會將它們合併。\n\n```typescript\ninterface Phone {\n  brand: string;\n  model: string;\n  price: number;\n}\n\ninterface SmartPhone extends Phone {\n  os: string;\n}\n```\n","createdAt":"2025-08-16T08:43:55.129Z","updatedAt":"2025-08-16T10:25:14.944Z","publishedAt":"2025-08-16T10:25:14.946Z","locale":null,"author":null}}
{"type":"api::post.post","id":169,"data":{"documentId":"wdqs25ol6zhum5kd88yw6l3d","slug":"01-clamp","title":"01-clamp","date":"2025-08-16T08:43:55.152Z","description":"🔸 題目描述 你正在開發一個處理數值資料的系統。請寫一個名為 clamp 的函式，它需要三個參數： - 一個數值 number - 一個最小值 lower - 一個最大值 upper 此函式應確保輸出的 number 始終落在指定的範圍内，包括最小值和最大值本身。你會如何實作這個 clamp 呢? Tests Solutions","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n你正在開發一個處理數值資料的系統。請寫一個名為 `clamp` 的函式，它需要三個參數：\n\n- 一個數值 `number`\n- 一個最小值 `lower`\n- 一個最大值 `upper`\n\n此函式應確保輸出的 `number` 始終落在指定的範圍内，包括最小值和最大值本身。你會如何實作這個 `clamp` 呢?\n\n```js\n// 在範圍中，返回原值\nclamp(7, 0, 9); // => 7\n\n// 小於 lower，返回 lower\nclamp(-12, -4, 5); // => -4\n\n// 大於 upper，返回 upper\nclamp(18, 3, 9); // => 9\n```\n\n## Tests\n\n```js title=\"test.ts\"\nimport { describe, expect, test } from \"@jest/globals\";\nimport clamp from \"./clamp\";\ndescribe(\"clamp\", () => {\n  test(\"should return the input number when it is within the specified range\", () => {\n    expect(clamp(7, 0, 9)).toBe(7);\n    expect(clamp(3, -5, 5)).toBe(3);\n    expect(clamp(-2, -10, 10)).toBe(-2);\n  });\n\n  test(\"should return the lower bound when the input number is less than the lower bound\", () => {\n    expect(clamp(-5, 0, 9)).toBe(0);\n    expect(clamp(-10, -5, 5)).toBe(-5);\n    expect(clamp(-15, -10, 10)).toBe(-10);\n  });\n\n  test(\"should return the upper bound when the input number is greater than the upper bound\", () => {\n    expect(clamp(10, 0, 9)).toBe(9);\n    expect(clamp(6, -5, 5)).toBe(5);\n    expect(clamp(15, -10, 10)).toBe(10);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```ts title=\"solution1.js\"\n    function clamp(number: number, lower: number, upper: number) {\n    if (number < lower) {\n        return lower;\n    } else if (number > upper) {\n        return upper;\n    } else {\n        return number;\n    }\n    ```\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```ts title=\"solution2.js\"\n    function clamp(number: number, lower: number, upper: number) {\n      return Math.min(upper, Math.max(lower, number));\n    }\n    //使用 Math.max 函數來確保數值不會低於下限，然後使用 Math.min 函數來確保數值不會超過上限\n    ```\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.161Z","updatedAt":"2025-08-16T10:25:14.955Z","publishedAt":"2025-08-16T10:25:14.957Z","locale":null,"author":null}}
{"type":"api::post.post","id":170,"data":{"documentId":"pp1b6qsz8rdm68hbg3sj46wx","slug":"03-compact","title":"03-compact","date":"2025-08-16T08:43:55.196Z","description":"🔸 題目描述 請實作一個 compact 效用函式。 compact 能將輸入的陣列中的 false、null、0、空字串、undefined 和 NaN 都去除，並輸出一個新的陣列。請實作此 compact 函式。 Tests Solutions `","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個 `compact` 效用函式。 `compact` 能將輸入的陣列中的 `false`、`null`、0、空字串、`undefined` 和 NaN 都去除，並輸出一個新的陣列。請實作此 `compact` 函式。\n\n```js\n// 範例一\ncompact([0, 1, false, 2, \"\", 3, \"hello\"]);\n// => [1, 2, 3, 'hello']\n\n// 範例二\ncompact([null, undefined, NaN, \" \"]);\n// =>[' ']\n\n// 範例三\ncompact([{ name: \"Alice\" }, null, { age: 30 }, undefined]);\n// =>[{ name: 'Alice' }, { age: 30 }]\n```\n\n## Tests\n\n```js title=\"test.ts\"\nimport { describe, expect, test } from \"@jest/globals\";\nimport compact from \"./compact\";\n\ndescribe(\"compact\", () => {\n  test(\"removes all falsy values from the array\", () => {\n    expect(compact([0, 1, false, 2, \"\", 3, \"hello\"])).toEqual([\n      1,\n      2,\n      3,\n      \"hello\",\n    ]);\n    expect(compact([null, undefined, NaN, \" \"])).toEqual([\" \"]);\n    expect(compact([{ name: \"Alice\" }, null, { age: 30 }, undefined])).toEqual([\n      { name: \"Alice\" },\n      { age: 30 },\n    ]);\n  });\n\n  test(\"does not remove non-falsy values\", () => {\n    expect(compact([1, 2, 3])).toEqual([1, 2, 3]);\n    expect(compact([\"hello\", \"world\"])).toEqual([\"hello\", \"world\"]);\n    expect(compact([{ name: \"Alice\" }, { age: 30 }])).toEqual([\n      { name: \"Alice\" },\n      { age: 30 },\n    ]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```ts title=\"solution1.ts\"\n    const compact = <T>(arr: T[]): T[] => {\n        return arr.filter(Boolean);\n        //false、null、0、空字串、undefined 和 NaN 都是 falsy value\n    };\n    export default compact;\n    ````\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```ts title=\"solution2.ts\"\n    function compact(array: T[]) : T[] {\n    const result = []\n    for (const value of array) {\n        if (value) {\n        result.push(value)\n        }\n    }\n    return result\n    }\n    export default compact;\n    ```\n    </TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.201Z","updatedAt":"2025-08-16T10:25:14.967Z","publishedAt":"2025-08-16T10:25:14.969Z","locale":null,"author":null}}
{"type":"api::post.post","id":171,"data":{"documentId":"axz5mzycre96dx8vatmgjx3h","slug":"04-difference","title":"04-difference","date":"2025-08-16T08:43:55.215Z","description":"🔸 題目描述 請實作一個名為 difference 的函式，該函式接收兩個陣列作為參數。函式的功能是回傳只在第一個陣列中存在、在第二個陣列中不存在的元素，並且避免對重複值進行多餘的操作。 Tests Solutions `","content":"\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n請實作一個名為 `difference` 的函式，該函式接收兩個陣列作為參數。函式的功能是回傳只在第一個陣列中存在、在第二個陣列中不存在的元素，並且避免對重複值進行多餘的操作。\n\n```js\ndifference([], []); // []\ndifference([1, 1, 2, 3], [2, 3]); // [1, 1]\ndifference([1, 2, 3], [1, 2, 3, 4]); // []\ndifference([4, 3, 2, 1], [1, 2, 3]); // [4]\n```\n\n## Tests\n\n```js\nimport { describe, expect, test } from \"@jest/globals\";\nimport difference from \"./difference\";\n\ndescribe(\"difference\", () => {\n  test(\"returns elements only present in the first array\", () => {\n    expect(difference([], [])).toEqual([]);\n    expect(difference([1, 1, 2, 3], [2, 3])).toEqual([1, 1]);\n    expect(difference([1, 2, 3], [1, 2, 3, 4])).toEqual([]);\n    expect(difference([4, 3, 2, 1], [1, 2, 3])).toEqual([4]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js\n    function difference(array: any[], values: any[]): any[] {\n        const result = [];\n        for (const element of array) {\n            if (!values.includes(element)) {\n                result.push(element);\n            }\n        }\n        return result;\n    }\n    ````\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js\n      function difference(array: any[], values: any[]) {\n        return array.filter((item: any) => !values.includes(item));\n      }\n    ```\n    </TabItem>\n\n  <TabItem value=\"solution3\" label=\"解法三\">\n    ```js\n      function difference(array: any[], values: any[]): any[] {\n        const valuesSet = new Set(values);\n        //將 values 轉換為一個 Set。Set 是一種數據結構，它存儲的元素都是唯一的，並且 Set 提供了一個 has 方法，可以用來快速檢查一個元素是否存在於 Set 中。\n        return array.filter((value) => !valuesSet.has(value));\n        //由於 Set.has 方法的時間複雜度是 O(1)，適合處理非常大的 values 陣列\n        }\n    ```\n    </TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.219Z","updatedAt":"2025-08-16T10:25:14.978Z","publishedAt":"2025-08-16T10:25:14.980Z","locale":null,"author":null}}
{"type":"api::post.post","id":172,"data":{"documentId":"crmn8r61n2vukk6thtg2er9m","slug":"07-fill","title":"07-fill","date":"2025-08-16T08:43:55.265Z","description":"🔸 題目描述 實作 fill 函式，此函式接收四個參數： - 一個陣列 - 要替換的 value - start 索引 - end 索引 該函式會從 start 到 end 索引 (包含 start 但不包含 end) 來把陣列的元素換成 value 。如果未提供 start 索引，則應預設為 0。如果未提供 end 索引，則剩餘元素會被替換為 value。 Tests Solutions","content":"import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n🔸 **題目描述**\n\n實作 `fill` 函式，此函式接收四個參數：\n\n- 一個陣列\n- 要替換的 `value`\n- `start` 索引\n- `end` 索引\n\n該函式會從 `start` 到 `end` 索引 (包含 `start` 但不包含 `end`) 來把陣列的元素換成 `value` 。如果未提供 `start` 索引，則應預設為 0。如果未提供 `end` 索引，則剩餘元素會被替換為 `value`。\n\n```js\nfill([1, 2, 3], \"_\");\n// => ['_', '_', '_']\n\nfill([1, 2], \"*\", 2, 3);\n// => [1, 2]\n\nfill([1, 2, 3, 4, 5], \"_\", 1, -1);\n// => [1, '_', '_', '_', 5]\n```\n\n## Tests\n\n```js\nimport { describe, expect, test } from \"@jest/globals\";\nimport fill from \"./fill\"; // adjust this to your actual file path\n\ndescribe(\"fill\", () => {\n  test(\"fills all elements with the provided value when start and end are not provided\", () => {\n    expect(fill([1, 2, 3], \"_\")).toEqual([\"_\", \"_\", \"_\"]);\n  });\n\n  test(\"does not fill any elements when start is equal to or greater than the array length\", () => {\n    expect(fill([1, 2], \"*\", 2, 3)).toEqual([1, 2]);\n  });\n\n  test(\"fills elements from start to end with the provided value\", () => {\n    expect(fill([1, 2, 3, 4, 5], \"_\", 1, -1)).toEqual([1, \"_\", \"_\", \"_\", 5]);\n  });\n\n  test(\"fills remaining elements with the provided value when end is not provided\", () => {\n    expect(fill([1, 2, 3], \"_\", 1)).toEqual([1, \"_\", \"_\"]);\n  });\n});\n```\n\n## Solutions\n\n<Tabs>\n  <TabItem value=\"solution1\" label=\"解法一\">\n    ```js title=\"solution1.js\"\n    function fill(array, value, start = 0, end = array.length) {\n        if (start < 0) {\n            start = array.length + start;\n        }\n\n        if (end < 0) {\n            end = array.length + end;\n        }\n\n        if (end > array.length) {\n            end = array.length;\n        }\n\n        for (let i = start; i < end; i++) {\n            array[i] = value;\n        }\n\n        return array;\n    }\n\nexport default inRange;\n```\n\n  </TabItem>\n\n  <TabItem value=\"solution2\" label=\"解法二\">\n    ```js title=\"solution2.js\"\n    function fill(array, value, start = 0, end = array.length) {\n        return array.fill(value, start, end);\n    }\n    ```\n\n</TabItem>\n</Tabs>\n","createdAt":"2025-08-16T08:43:55.269Z","updatedAt":"2025-08-16T10:25:14.992Z","publishedAt":"2025-08-16T10:25:14.993Z","locale":null,"author":null}}
{"type":"api::post.post","id":173,"data":{"documentId":"m59cl6ubrnh43b98tf83xj17","slug":"dom-vdom","title":"DOM 與 Virtual DOM","date":"2025-08-16T08:43:55.420Z","description":"DOM DOM (Document Object Model) 是一個網頁樹狀資料結構的物件，用來呈現瀏覽器中的畫面結構。當頁面產生變化時，便是透過操作 DOM 後藉由瀏覽器的渲染引擎重繪來呈現畫面，一旦對 DOM 進行操作，渲染引擎就會自動地將整個畫面重繪。 操作 DOM 對效能的影響 操作 DOM 本身是一個昂貴的效能負擔，如果在短時間內頻繁或大量的更新 DOM 元素，可能會造成畫面卡頓，因為瀏覽器的渲染引擎也會跟著不斷重繪畫面。因此，在前端的針對 DOM 的效能優化就是盡量縮小操作 DOM 的範圍。","content":"\n## DOM\n\nDOM (Document Object Model) 是一個網頁樹狀資料結構的物件，用來呈現瀏覽器中的畫面結構。當頁面產生變化時，便是透過操作 DOM 後藉由瀏覽器的渲染引擎重繪來呈現畫面，一旦對 DOM 進行操作，渲染引擎就會自動地將整個畫面重繪。\n\n## 操作 DOM 對效能的影響\n\n操作 DOM 本身是一個昂貴的效能負擔，如果在短時間內頻繁或大量的更新 DOM 元素，可能會造成畫面卡頓，因為瀏覽器的渲染引擎也會跟著不斷重繪畫面。因此，在前端的針對 DOM 的效能優化就是盡量縮小操作 DOM 的範圍。\n\n## Virtual DOM\n\n為了縮小操作 DOM 的範圍 Virtual DOM 的概念就產生了，簡單來說，Virtual DOM 就是一個虛擬的畫面結構，同時也是描述真實的 DOM 結構。它本身就是由一個個的 DOM 元素組成的樹狀結構，而 DOM 元素的本身就是 Javascript 物件。\n\n與 DOM 的關係，可以比喻成 Virtual DOM 是 DOM 的試做品，在更新 DOM 之前，先產生開發者期望中虛擬的畫面結構，然後再用這個虛擬的畫面結構去實際操作 DOM 。\n\n## Virtual DOM 對於效能的優化\n\n當瀏覽器第一次繪製畫面時會產生實際的 DOM 結構，同時也會產生一個 Virtual DOM 的結構，因此當我們要再更新畫面會是這樣的：\n\n1. 根據資料產生一組新的 Virtual DOM 結構\n2. 將新的 Virtual DOM 結構與舊的 Virtual DOM 結構做比較\n3. 比較新舊之間差異的部分\n4. 將差異的部分更新在真實的 DOM 上\n5. 瀏覽器的渲染引擎會自動重繪畫面\n6. 若新舊的 Virtual DOM 結構一樣，則不會更新 DOM 結構，因此也不會重繪畫面\n\n這樣的做的好處可以，縮小操作 DOM 的範圍，只需要操作真正需要更新的 DOM 元素，可以大大的降低效能的負擔，另外，使用 Virtual DOM 的好處是：Virtual DOM 並不會向真實的 DOM 與瀏覽器的渲染引擎做綁定，因此產生的 JavaScript 物件較為單純，也因此節省了效能。\n","createdAt":"2025-08-16T08:43:55.458Z","updatedAt":"2025-08-16T10:25:15.004Z","publishedAt":"2025-08-16T10:25:15.006Z","locale":null,"author":null}}
{"type":"api::post.post","id":174,"data":{"documentId":"o05cjwkdgizp7a3oltvf2efq","slug":"jsx","title":"JSX 根本不是在 JavaScript 中寫 HTML","date":"2025-08-16T08:43:55.499Z","description":"JSX 語法 JSX 語法是一種語法糖，提供我們在建立 react element 時，用類似撰寫 HTML 語法的體驗，提高可閱讀性與開發體驗。 1. 使用 React.createElement 建立 React Element ２. 使用 JSX 語法建立 React Element JSX 語法透過開發工具轉譯後以上兩者的 react element 結構是一樣的，但是使用 JSX 語法的方式更為簡潔。 JSX 語法本質就是 去呼叫 React.createElement 來建立 React Element 的替代語法，其所回傳的值便是一個 React Element。","content":"\n## JSX 語法\n\nJSX 語法是一種語法糖，提供我們在建立 react element 時，用類似撰寫 HTML 語法的體驗，提高可閱讀性與開發體驗。\n\n1. 使用 React.createElement 建立 React Element\n\n```jsx live \"\nfunction App() {\n  const h1Element = React.createElement(\n    \"h1\",\n    { className: \"title\" },\n    \"Hello World\",\n  );\n  return <div>{h1Element}</div>;\n}\n```\n\n２. 使用 JSX 語法建立 React Element\n\n```jsx live title=\"index.jsx\"\nfunction App() {\n  return (\n    <div>\n      <h1 className=\"title\">Hello World</h1>\n    </div>\n  );\n}\n```\n\nJSX 語法透過開發工具轉譯後以上兩者的 react element 結構是一樣的，但是使用 JSX 語法的方式更為簡潔。\nJSX 語法本質就是 **去呼叫 React.createElement** 來建立 React Element 的替代語法，其所回傳的值便是一個 React Element。\n\n但是 JSX 語法 在瀏覽器中的 JavaScript 引擎是無法直接執行的，所以需要透過 **transpiler** 來將 JSX 語法靜態轉譯成瀏覽器 JavaScript 引擎可以執行的 JavaScript 語法。\n\n## 什麼是 transpiler?\n\ntranspiler (轉譯器)＝ translator (翻譯器) + compiler (編譯器)，也就是將原始的程式碼轉換成另一種程式碼的工具，例如 Babel 就是一個將 JSX 語法轉譯成瀏覽器可以執行的 JavaScript 語法的轉譯器。\n\n## JSX transformer\n\nJSX transformer 負責轉譯 JSX 語法， Babel 就是 react 官方建議的 transpiler\n\n## JSX 語法是經過什麼樣的處理最後才能在瀏覽器中執行並定義畫面？\n\n```js title=\"index.jsx\"\nimport ReactDOM from \"react-dom/client\";\n\nconst rootContainer = document.getElementById(\"root\");\n\nconst root = ReactDOM.createRoot(rootContainer);\n\n// highlight-start\nconst h1Element = React.createElement(\n  \"h1\",\n  { className: \"title\" },\n  \"Hello World\",\n);\n// highlight-end\n\nroot.render(h1Element);\n```\n\nReact 17 後，在開發環境 Build time 、Javascript 還沒有被執行時，經過 Babel JSX transformer 搭配 `jsx-runtime` 轉譯後的程式碼:\n\n```js title=\"output.js\"\nimport ReactDOM from \"react-dom/client\";\n// highlight-next-line\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst rootContainer = document.getElementById(\"root\");\n\nconst root = ReactDOM.createRoot(rootContainer);\n\n// highlight-start\nconst h1Element = _jsx(\"h1\", { className: \"title\" }, \"Hello World\");\n// highlight-end\n\nroot.render(h1Element);\n```\n\n`_jsx` 方法的意思類似呼叫建立 React element 的 `React.createElement` 方法，透過靜態解析JSX 語法的語意來避免一些多餘的資料處理流程，這樣的轉譯過程是在 Build time 時完成的，所以在瀏覽器中 Runtime 執行時，不需要再進行轉譯，直接執行即可。\n","createdAt":"2025-08-16T08:43:55.525Z","updatedAt":"2025-08-16T10:25:15.022Z","publishedAt":"2025-08-16T10:25:15.024Z","locale":null,"author":null}}
{"type":"api::post.post","id":175,"data":{"documentId":"mly51qqc3x8urq17lg7pysia","slug":"immutable-update","title":"Immutable update","date":"2025-08-16T08:43:55.668Z","description":"Shallow clone 與 deep clone 的區別 首先要講到 Javascript 「物件傳址」的特性，在 Javascript 中物件在建立的時候會將記憶體的位址賦予至變數上，常常有多個變數共用同一個位址，所以 mutate 其中一個物件的屬性的內容時，其他的變數也會受到影響，就是因為他們共用同一個記憶體位址。 Shallow clone Shallow clone 又稱淺複製，當想要將物件重新賦予至另外一個物件的時候又不想要修改其原始值，就可以使用 Shallow clone 將物件內第一層的屬性複製到另外一個 reference 上，這樣既原來的物件的 reference...","content":"\nimport CodeSandbox from \"../../../src/components/mdx/CodeSandbox.jsx\";\n\n## Shallow clone 與 deep clone 的區別\n\n首先要講到 Javascript 「物件傳址」的特性，在 Javascript 中物件在建立的時候會將記憶體的位址賦予至變數上，常常有多個變數共用同一個位址，所以 mutate 其中一個物件的屬性的內容時，其他的變數也會受到影響，就是因為他們共用同一個記憶體位址。\n\n## Shallow clone\n\nShallow clone 又稱淺複製，當想要將物件重新賦予至另外一個物件的時候又不想要修改其原始值，就可以使用 Shallow clone **將物件內第一層的屬性複製到另外一個 reference 上**，這樣既原來的物件的 reference 不同，也可以避免修改到原始物件的屬性。\n\n### Shallow clone 的方法\n\n#### [spread 語法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n\nconst copyBySpread = { ...memberInfo }; //使用 spread 語法複製物件 memberInfo\n\nconsole.log(\"copyBySpread === memberInfo\", copyBySpread === memberInfo); //false\n//可以確定 copyBySpread 與 memberInfo 這兩個物件的 reference 不同的\n\nconsole.log(\n  \"copyBySpread.hobbies === memberInfo.hobbies\",\n  copyBySpread.hobbies === memberInfo.hobbies,\n); //true\n\n//memberInfo 中的 hobbies 屬性是一個陣列，物件的比對 === 就是其記憶體的位址，\n//可以確定 copyBySpread 與 memberInfo 這兩個物件的 hobbies 這個屬性都是指向同一個 reference 的，\n//所以當修改 copyBySpread.hobbies 的內容時，也會影響到 memberInfo.hobbies 的內容。\n```\n\n那如果想要淺複製物件內巢狀的物件或物件可以這麼做：\n\n```js\nconst copyNestBySpread = {\n  ...memberInfo, //先淺複製 memberInfo 第一層的屬性\n  hobbies: [...memberInfo.hobbies], //在 copyNestBySpread 物件中新增 hobbies 屬性，然後將 memberInfo.hobbies 陣列淺複製到 copyNestBySpread.hobbies\n};\n\n//這時候再次檢查 copyNestBySpread.hobbies 與 memberInfo.hobbies 的 reference 是否相同\nconsole.log(\n  \"copyNestBySpread.hobbies === memberInfo.hobbies\",\n  copyNestBySpread.hobbies === memberInfo.hobbies,\n); //false\n// 這時候修改 copyNestBySpread.hobbies 的內容就不會影響到 memberInfo.hobbies 的內容\n```\n\n使用 spread 展開運算符的好處是語法相對簡潔，讓程式碼容易閱讀。\n\n#### [Object.assign()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n\nconst copyByAssign = Object.assign({}, memberInfo); ////使用 Object.assign() 複製物件 memberInfo\n\nconsole.log(\"copyByAssign === memberInfo\", copyByAssign === memberInfo); //false\n\nconsole.log(\n  \"copyByAssign.hobbies === memberInfo.hobbies\",\n  copyByAssign.hobbies === memberInfo.hobbies,\n); //true\n```\n\n## Deep clone\n\nDeep clone 又稱深複製，相對淺複製僅是將物件的第一層複製，深複製則是將物件的所有層級都複製一份，深複製當遇到巢狀物件或是陣列時，就會進行深層的遍歷，將每一次層的值都進行複製，如此一來複製出來的物件當被修改時就不會影響到原來的物件。\n\n### Deep clone 的方法\n\n#### `JSON.parse(JSON.stringify(...))`\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n\n//先將 memberInfo 物件轉換成 JSON 字串，再將 JSON 字串轉換成物件\nfunction deepCopy(item) {\n  return JSON.parse(JSON.stringify(item));\n}\n\nconst deepCopyByJSON = deepCopy(memberInfo);\n\nconsole.log(\"deepCopyByJSON === memberInfo\", deepCopyByJSON === memberInfo); //false\nconsole.log(\n  \"deepCopyByJSON.hobbies === memberInfo.hobbies\",\n  deepCopyByJSON.hobbies === memberInfo.hobbies,\n); //false\n```\n\n但是使用 `JSON.parse(JSON.stringify(...))` 進行深複製時，如果物件內的屬性有不可以序列化的值，就會導致深複製失敗。ex: `undefined`、`function`、`symbol`、`BigInt`、`Date`、`RegExp`、`Error`、`Map`、`Set`\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n  getMoreInfo: function getMoreInfo() {\n    return null;\n  },\n  createdTime: new Date(\"2024-06-10\"),\n};\n\nfunction deepCopy(item) {\n  return JSON.parse(JSON.stringify(item));\n}\n\nconst deepCopyByJSON = deepCopy(memberInfo);\n```\n\n![](./deepClone1.png)\n`deepCopyByJSON.createdTime`跟`memberInfo.createdTime`的值就不同了，因為`Date`物件無法被序列化。\n\n![](./deepClone2.png)\n`deepCopyByJSON.getMoreInfo`的值為 undefined，因為 function 也無法被序列化。\n\n#### `structuredClone(value)`\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n};\n//使用 structuredClone 深複製物件 memberInfo\nconst deepCopyByStructuredClone = structuredClone(memberInfo);\n\nconsole.log(\n  \"deepCopyByStructuredClone.hobbies === memberInfo.hobbies\",\n  deepCopyByStructuredClone.hobbies === memberInfo.hobbies\n);//false\n\n`deepCopyByStructuredClone.hobbies` 跟 `memberInfo.hobbies` 的 reference 不同\n```\n\n但是同樣的 `structuredClone` 也無法處理 `function`、`Date`、`RegExp`、`Error`、`Map`、`Set` 等不可序列化的值。\n\n```js\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n  getMoreInfo: function getMoreInfo() {\n    return null;\n  },\n  createdTime: new Date(\"2024-06-10\"),\n};\n\nconst deepCopyByStructuredClone = structuredClone(memberInfo);\n```\n\n![](./deepClone3.png)\n當物件內有不可序列化的值時，直接使用`structuredClone` 就會直接報錯。\n\n#### 手寫遞迴函式\n\n```js\n//map（用於存儲已複製物件的 WeakMap），在 WeakMap 中，鍵必須是物件。\n\nfunction cloneDeep(obj, map = new WeakMap()) {\n  //如果 map 中已經有 obj 的複製，則直接返回該複製。這可以防止循環參照導致的無窮遞歸。\n  if (map.has(obj)) {\n    return map.get(obj);\n  }\n\n  //首先排除非物件類型的，檢查傳入的 obj 是否為 null 或是原始型別，這是因為這些類型的值在 JavaScript 中是按值傳遞的，所以不需要複製。\n  if (obj === null || typeof obj !== \"object\" || typeof value === \"function\") {\n    return obj;\n  }\n\n  //如果 obj 是 Date 的實例，則創建一個新的相同的 Date 實例並返回。\n  if (obj instanceof Date) return new Date(obj);\n\n  //如果 obj 是 RegExp 的實例，則創建一個新的相同的 RegExp 實例並返回。\n  if (obj instanceof RegExp) return new RegExp(obj);\n\n  //函式輸出 output 值，如果 obj 是陣列，則輸出為空陣列，如果 obj 是一個普通物件，則 output 的原型會被設置為 obj 的原型，以保留原型鏈。\n\n  const output = Array.isArray(obj)\n    ? []\n    : Object.create(Object.getPrototypeOf(obj));\n\n  //將 obj 和 output 的對應關係存入 map\n  map.set(obj, output);\n\n  //使用 Reflect.ownKeys(obj) 獲取 obj 的所有自有屬性鍵（包括符號和不可枚舉的屬性）\n  //遍歷所有的鍵，對每個鍵對應的值進行深度複製，並將複製的結果存入 output。\n  for (const key of Reflect.ownKeys(obj)) {\n    const val = obj[key];\n    //對當前鍵對應的值進行深度複製，並將複製的結果存入 output。\n    output[key] = cloneDeep(val, map);\n  }\n  return output;\n}\n\nconst memberInfo = {\n  id: 120,\n  name: \"Andy\",\n  isVip: false,\n  birthday: \"1996/01/12\",\n  hobbies: [\"Photography\", \"Cooking\", \"Painting\"],\n  getMoreInfo: function getMoreInfo() {\n    return null;\n  },\n  createdTime: new Date(\"2024-06-10\"),\n};\n\nconst cloneDeepMemberInfo = cloneDeep(memberInfo);\n\nconsole.log(\"cloneDeepMemberInfo.getMoreInfo\", cloneDeepMemberInfo.getMoreInfo);\nconsole.log(\"memberInfo.getMoreInfo\", memberInfo.getMoreInfo);\n\nconsole.log(\"cloneDeepMemberInfo.createdTime\", cloneDeepMemberInfo.createdTime);\nconsole.log(\"memberInfo.createdTime\", memberInfo.createdTime);\n```\n\n![](./deepClone4.png)\n![](./deepClone5.png)\n\n## 為什麼以 deep clone 來進行物件或陣列資料的 immutable update 不是一個好方法?\n\n簡單來說，使用 deep clone 操作物件資料會使 React 效能優化機制失效。\n\n這裡就舉一個例子來進行說明\n\n<CodeSandbox codeSandboxId=\"immutable-update-shallow-deep-clone-forked-8rgd8d?file=%2Fsrc%2FApp.jsx%3A20%2C29&layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clvkron4200063b6iily2ii69%2522%252C%2522sizes%2522%253A%255B100%252C0%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clvkron4200023b6if4n611kn%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clvkron4200033b6impvz28zp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clvkron4200053b6i1eep83jr%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clvkron4200023b6if4n611kn%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvkron4200013b6iidkrwdor%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252Fsrc%252Findex.js%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%252C%257B%2522id%2522%253A%2522clvlpejjd00023b6i228pr0my%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522initialSelections%2522%253A%255B%257B%2522startLineNumber%2522%253A20%252C%2522startColumn%2522%253A29%252C%2522endLineNumber%2522%253A20%252C%2522endColumn%2522%253A29%257D%255D%252C%2522filepath%2522%253A%2522%252Fsrc%252FApp.jsx%2522%252C%2522state%2522%253A%2522IDLE%2522%257D%255D%252C%2522id%2522%253A%2522clvkron4200023b6if4n611kn%2522%252C%2522activeTabId%2522%253A%2522clvlpejjd00023b6i228pr0my%2522%257D%252C%2522clvkron4200053b6i1eep83jr%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clvkron4200043b6ibahll584%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522UNASSIGNED_PORT%2522%252C%2522port%2522%253A0%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clvkron4200053b6i1eep83jr%2522%252C%2522activeTabId%2522%253A%2522clvkron4200043b6ibahll584%2522%257D%252C%2522clvkron4200033b6impvz28zp%2522%253A%257B%2522tabs%2522%253A%255B%255D%252C%2522id%2522%253A%2522clvkron4200033b6impvz28zp%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Afalse%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D\" />\n\n`React.memo()` 是一個效能優化的方法，它將 component 包裹起來，每當有 props 傳入 component 時會使用 `Object.is（）` 檢查這次的 props 與前次的 props 是否相同，當 component 的 props 沒有變動時，就不會重新 render，這樣可以避免不必要的 re-render，提升效能。\n\n在這個例子中，App component 中有一個被 memo() 包裹住的 Child component。\n\n### 使用 deep clone 進行 state 更新\n\n```jsx\nimport { memo, useState } from \"react\";\n\nfunction Child({ fooObj }) {\n  console.log(\"render Child\");\n  return <h1>child: {fooObj.b}</h1>;\n}\n\nconst MemoizedChild = memo(Child);\n\nexport default function App() {\n  console.log(\"render App\");\n  const [data, setData] = useState({\n    count: 0,\n    foo: { b: 100 },\n  });\n\n  const updateCountWithDeepClone = () => {\n    // 使用 deep clone 複製 data 物件並且賦值給 newData\n    const newData = structuredClone(data);\n    // 更新 newData 的 count 屬性\n    newData.count += 1;\n    // 更新 data 的 state\n    setData(newData);\n  };\n\n  return (\n    <div>\n      <h2>count: {data.count} </h2>\n      <button onClick={updateCountWithDeepClone}>\n        Update Count With Deep Clone\n      </button>\n      <MemoizedChild fooObj={data.foo} />\n    </div>\n  );\n}\n```\n\n當 component 第一次 mounted 掛載至瀏覽器後：\n\n1. 點擊 Update Count With Deep Clone button\n\n2. 會呼叫 `updateCountWithDeepClone function`\n\n3. 在 `updateCountWithDeepClone function` 中會使用 `structuredClone` 進行 deep clone data 物件並且賦值給 newData\n\n4. 更新 newData 的 count 屬性\n\n5. 更新 data 的 state\n\n6. React 會執行 `Object.is() ` 檢查發現 state 更新了\n\n7. 進入 component reconciliation 階段，執行 App function 產生以 props 和 state 描述 component 畫面的 react element，這時就會印出 `render App`。\n\n8. 將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異就是 state，然後更新 `<h2>count: {data.count} </h2>`。\n\n9. 當執行到 `<MemoizedChild fooObj={data.foo} />` 時，雖然 `data.foo` 的值看似沒有改變，但是 React 發現 props 有變，當 App Component render 完成後，就會執行 memoized Child component function，這時會印出 `render Child`。\n\n這是因為使用了 deep Clone 更新了 state 資料，又 deep Clone 所將物件中每一層的每一個屬性都經過遍歷複製，即使沒發生更新的內層資料也會產生全新的參考，因此，此時當使用 `object.is()` 檢查傳入 `<MemoizedChild fooObj={data.foo} />` 的 props 時，就會發現 props 有變動，所以會重新 re-render，進而印出 `render Child`。\n\n從上述可以知道，對於 React 來說，使用 deep clone 進行 state 更新會使得某些 React 效能優化的手段失效，導致每一次 state 的更新都是全新的物件、全新的參考，即使該屬性的值沒有變更，而使得效能優化機制失去參考相等性。\n\n### 使用 shallow clone 進行 state 更新\n\n```jsx\nimport { memo, useState } from \"react\";\n\nfunction Child({ fooObj }) {\n  console.log(\"render Child\");\n  return <h1>child: {fooObj.b}</h1>;\n}\n\nconst MemoizedChild = memo(Child);\n\nexport default function App() {\n  console.log(\"render App\");\n  const [data, setData] = useState({\n    count: 0,\n    foo: { b: 100 },\n  });\n\n  const updateCountWithShallowClone = () => {\n    setData({\n      ...data,\n      count: data.count + 1,\n    });\n  };\n\n  return (\n    <div>\n      <h2>count: {data.count} </h2>\n      <button onClick={updateCountWithShallowClone}>\n        Update Count With Shallow Clone\n      </button>\n      <MemoizedChild fooObj={data.foo} />\n    </div>\n  );\n}\n```\n\n當 component 第一次 mounted 掛載至瀏覽器後：\n\n1. 點擊 Update Count With Shallow Clone button\n\n2. 會呼叫 `updateCountWithShallowClone function`\n\n3. 在 `updateCountWithShallowClone function` 中會展開運算符淺複製 data 物件，然後更新 count 屬性，最後 setState 更新 data 的 state。\n\n4. 更新 count 屬性\n\n5. 最後 setState 更新 data 的 state\n\n6. React 會執行 `Object.is()` 檢查發現 state 更新了\n\n7. 進入 component reconciliation 階段，執行 App function 產生以 props 和 state 描述 component 畫面的 react element，這時就會印出 `render App`。\n\n8. 將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異就是 state，然後更新 `<h2>count: {data.count} </h2>`。\n\n最後的執行結果就是傳入 `<MemoizedChild fooObj={data.foo} />` 的 props 並沒有變動，所以不會重新 re-render，也就不會印出 `render Child`，只有 App component 會重新 render。\n\n對於 React 來說資料比較機制就是為了減少重複產生 react element 的次數，React 不需要知道實際的資料細節，檢查原始型別時直接互比值、檢查物件時只需要比對參考是否相同，當物件資料的參考相同，React 就會當作資料沒變，不管物件內容如何改變，React 都不會重新產生新的 react element 來 render，因此更新 state 時不應該 mutate 原始資料，而是應該產生新的物件這樣就會產生一個新的 Reference，透過 shallow clone 複製原始物件的屬性到新的物件，只要根據更新的部分去修改相對應的值，這樣既不會 mutate 到原始資料，維持物件 immutable，也可以提供 React 效能優化機制參考的相等性。\n","createdAt":"2025-08-16T08:43:55.711Z","updatedAt":"2025-08-16T10:25:15.051Z","publishedAt":"2025-08-16T10:25:15.054Z","locale":null,"author":null}}
{"type":"api::post.post","id":176,"data":{"documentId":"pa7jwi8tvdd1hgcma0t2ivry","slug":"component-life-cycle","title":"Component 的三大生命週期","date":"2025-08-16T08:43:55.722Z","description":"Component 的三大生命週期 生命週期就是指一個 React Component 在被創建到被銷毀的過程中，會經歷的一系列階段。 一. Mount Mount 流程會在 component 以 React component 的形式第一次出現在畫面上時觸發。 render phase: 1. React 會執行 component function 以傳入的 props 和 state 產生初始畫面區塊的 react element。","content":"\n## Component 的三大生命週期\n\n生命週期就是指一個 React Component 在被創建到被銷毀的過程中，會經歷的一系列階段。\n\n### 一. Mount\n\nMount 流程會在 component 以 React component 的形式第一次出現在畫面上時觸發。\n\n#### render phase:\n\n1. React 會執行 component function 以傳入的 props 和 state 產生初始畫面區塊的 react element。\n2. 此時 React 內部會建立 fiber node 以儲存 component 的實例，這個 component 實例會包含 component 畫面結構、state、side effect...等。\n3. 接著將生成的 react element 交到 commit phase 處理。\n\n#### commit phase:\n\n1. 由於此時是第一次 render，瀏覽器實際的 DOM 中並沒有相對應的 component 實例 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。\n2. 使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器 DOM 上。\n3. 此時 component 就會被掛載到瀏覽器的畫面上，可以在實際的 DOM Element 中找到相對應的實例的 DOM element。\n\n#### 執行 side effect:\n\n執行 useEffect hook 中的 副作用。\n\n### 二. Update\n\nUpdate 流程會在 component 存在於畫面中，當 component 的 props 或 state 資料發生變化時觸發 re-render。在 react 中能夠觸發 re-render 的手段就是使用 `setState` 去更新 state 資料，而 component 有可能會因為父層或祖父層的 component `setState` 去更新 state 而傳入新的 props 而觸發 re-render；也有可能因為 component 本身 state 更新了而觸發 re-render。\n\n#### render phase:\n\n1. React 會執行 component function 以新版本傳入的 props 和 state 重新產生 react element。\n2. 接著將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異。\n3. 將差異的部分交到 commit phase 處理。\n\n#### commit phase:\n\n只會去操作新舊 react element 差異所對應的實際 DOM element。\n\n#### 清除前一次 render 的 side effect:\n\n執行前一次 useEffect hook 中定義的清除副作用 cleanup 函式。\n\n#### 執行本次 render 的 side effect\n\n### 三. Unmount\n\n當 component 在 re-render 後在新畫面中被移除時，就會觸發 unmount 流程。\n\n1. 會先將 component 從瀏覽器的實際 DOM element 中移除。\n2. 接著會執行最後一次 useEffect hook 中副作用中的 cleanup 函式，以清除留下的副作用影響。\n3. 移除 React 內部的 fiber node。\n","createdAt":"2025-08-16T08:43:55.777Z","updatedAt":"2025-08-16T10:25:15.065Z","publishedAt":"2025-08-16T10:25:15.067Z","locale":null,"author":null}}
{"type":"api::post.post","id":177,"data":{"documentId":"ij8mpiivh8xhu05nrsl1sfp6","slug":"effect","title":"React 中的副作用處理：effect 初探","date":"2025-08-16T08:43:55.789Z","description":"React 在 component function 中提供了一個 useEffect hook 來 隔絕和管理副作用 。React 在每次 render 之後執行 useEffect。 副作用 side effect 副作用指的是當函式被呼叫時，除了回傳值以外，還會對外部環境產生影響的操作。常見的副作用包括： - 呼叫 API - 操作 DOM（例如手動新增事件監聽器） - 設定計時器（例如 setTimeout、setInterval） - 訂閱事件（例如 WebSocket 或其他事件系統） - 修改全域變數 使用 useEffect hook 處理副作用的原因 若直接在...","content":"\nReact 在 component function 中提供了一個 `useEffect` hook 來 **隔絕和管理副作用** 。React 在每次 render 之後執行 `useEffect`。\n\n## 副作用 side effect\n\n副作用指的是當函式被呼叫時，除了回傳值以外，還會對外部環境產生影響的操作。常見的副作用包括：\n\n- 呼叫 API\n- 操作 DOM（例如手動新增事件監聽器）\n- 設定計時器（例如 setTimeout、setInterval）\n- 訂閱事件（例如 WebSocket 或其他事件系統）\n- 修改全域變數\n\n## 使用 useEffect hook 處理副作用的原因\n\n若直接在 component function 中處理副作用，會造成以下問題：\n\n- 重複副作用執行：由於函式多次執行而產生疊加副作用會造成 react 無法預測行為，可能導致資料流或程式邏輯無法正常運作。\n- 效能問題： 容易阻塞函式計算，導致產生 react element 的速度變慢，進而造成畫面更新的延遲。\n- 無法清理副作用：直接操作 DOM 或設置計時器時，無法在 component 卸載時自動清理這些副作用，可能導致記憶體洩漏。\n\n## 以 useEffect hook 處理副作用的步驟\n\n```jsx\nimport React, { useEffect } from \"react\";\nimport axios from \"axios\";\nfunction MyComponent() {\n  const [id, setId] = useState(1);\n\n  useEffect(() => {\n    // 定義副作用，例如呼叫 API\n    console.log(\"Component rendered\");\n    axios.get(`https://api.example.com/data${id}`).then((response) => {\n      console.log(response.data);\n    });\n    // 可選的 cleanup 函式，會在下一次 effect 執行前或 component 卸載時執行\n    return () => {\n      console.log(\"Cleanup before the next effect or on unmount\");\n    };\n  }, [id]); // 依賴陣列，當陣列中的值有變動時才會執行副作用\n\n  return <div>My Component</div>;\n}\n```\n\n1. 在 component function 中使用 `useEffect` hook。\n2. 在 `useEffect` hook 中定義副作用函式，例如呼叫 API。\n3. 如果有需要清除副作用，可以在副作用函式中回傳一個 cleanup 函式。\n4. 在 dependencies array 中傳入依賴陣列，以跳過執行不需要的 render 副作用。\n\n---\n\n## 實例練習 1\n\n[12. useEffect](https://bigfrontend.dev/react-quiz/useEffect)\n\n```JSX\n// This is a React Quiz from BFE.dev\n\nimport React, { useEffect, useState } from 'react'\nimport ReactDOM from 'react-dom'\n\nfunction App() {\n  const [state, setState] = useState(0)\n  console.log(state)\n\n  useEffect(() => {\n    setState(state => state + 1)\n  }, [])\n\n  useEffect(() => {\n    console.log(state)\n    setTimeout(() => {\n      console.log(state)\n    }, 100)\n  }, [])\n\n  return null\n}\n\nReactDOM.render(<App/>, document.getElementById('root'))\n\n```\n\n## 解題 1\n\n1. 初始渲染， 執行`console.log(state)`，這時的 state 是 0，所以會印出 0。\n\n2. 第一個 useEffect hook，`setState(state => state + 1)` 會等到所有的 side effect 都執行完後才會執行。\n\n3. 第二個 useEffect hook 中的 `console.log(state)` 會印出 0，這時的 state 是 0，所以會印出 0。\n\n4. 當遇到第二個 useEffect hook 中的 `setTimeout` 會在 100ms 後執行，所以根據 event loop 的機制會被放到宏任務 queue 中，等到 call stack 空了之後才會執行。\n\n5. `setState` 觸發 re-render：當 `setState(state => state + 1)` 被執行後，React 會進行一次重新渲染，state 的值會從 0 更新為 1，觸發 component re-render。\n\n6. 重新渲染後：重新渲染的 `console.log(state)`：在重新渲染過程中，state 現在是 1，所以新的 `console.log(state)` 會印出 1。7. 宏任務執行：`setTimeout` 的 callback 會在 100 毫秒後執行，這時 callback 內的 `console.log(state)` 會依然使用最初 `setTimeout` 被註冊時的閉包環境中的 state 值，該值仍然是初次渲染時的 0，因此會印出 0。\n\n```\n0\n0\n1\n0\n```\n\n## 實例練習 2\n\n[24. useEffect() timing](https://bigfrontend.dev/react-quiz/useeffect-timing)\n\n```JSX\nimport * as React from \"react\";\nimport { useState, useEffect } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { screen, fireEvent } from \"@testing-library/dom\";\n\nfunction App() {\n  const [state, setState] = useState(0)\n  console.log(1)\n\n  useEffect(() => {\n    console.log(2)\n  }, [state])\n\n  Promise.resolve().then(() => console.log(3))\n\n  setTimeout(() => console.log(4), 0)\n\n  const onClick = () => {\n    console.log(5)\n    setState(num => num + 1)\n    console.log(6)\n  }\n  return <div>\n    <button onClick={onClick}>click me</button>\n  </div>\n}\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App/>)\n\nsetTimeout(() => fireEvent.click(screen.getByText('click me')), 100)\n\n```\n\n## 解題 2\n\n1. 初始渲染，執行 `console.log(1)`，印出 `1`。\n2. 執行 `useEffect` hook 中的 `console.log(2)`，印出 `2`。\n3. 將 `Promise.resolve().then(() => console.log(3))` 放到微任務隊列，等待同步程式執行完畢後執行。\n4. 將 `setTimeout(() => console.log(4), 0)` 放到宏任務隊列，等待同步程式執行完畢後執行。\n5. 事件處理 (onClick)：\n\n- React 在 100 毫秒後模擬點擊按鈕。\n- 將 `onClick` callback 放到事件隊列，放到宏任務隊列，等待同步程式執行完畢後執行。\n\n6. 從微任務隊列中取出 `Promise.resolve().then(() => console.log(3))`，執行 `console.log(3)`，印出 `3`。\n7. 從宏任務隊列中取出 `setTimeout(() => console.log(4), 0)`，執行 `console.log(4)`，印出 `4`。\n8. 從宏任務隊列中取出 `onClick` callback，執行 `console.log(5)`，印出 `5`，`setState(num => num + 1)` 會等到所有的 side effect 都執行完後才會執行。\n9. `console.log(6)`，印出 `6`。\n10. 執行 `setState(num => num + 1)`，觸發 re-render，重新執行 component function，state 從 0 變成 1。\n11. 重新渲染後，執行 `console.log(1)`，印出 `1`。\n12. 執行 `useEffect` hook 中的 `console.log(2)`，印出 `2`。\n13. 將 `Promise.resolve().then(() => console.log(3))` 放到微任務隊列，等待同步程式執行完畢後執行。\n14. 將 `setTimeout(() => console.log(4), 0)` 放到宏任務隊列，等待同步程式執行完畢後執行。\n15. 從微任務隊列中取出 `Promise.resolve().then(() => console.log(3))`，執行 `console.log(3)`，印出 `3`。\n16. 從宏任務隊列中取出 `setTimeout(() => console.log(4), 0)`，執行 `console.log(4)`，印出 `4`。\n\n```\n1\n2\n3\n4\n5\n6\n1\n2\n3\n4\n```\n","createdAt":"2025-08-16T08:43:55.825Z","updatedAt":"2025-08-16T10:25:15.077Z","publishedAt":"2025-08-16T10:25:15.079Z","locale":null,"author":null}}
{"type":"api::post.post","id":178,"data":{"documentId":"gra657d7tal3p75tu3k2i321","slug":"reac-native-current-arch","title":"reac-native-current-arch","date":"2025-08-16T08:43:55.947Z","description":"解析 React Native 現行架構（Current Architecture）原理 長久以來，React Native 的效能問題一直為人詬病，為了解決這個問題，React Native 開發團隊針對舊有的架構進行了重構，並在 0.68 版本推出了新架構（New Architecture）。接下來，我會分享原來的架構是 Javascript 如何與 natvie 溝通，究竟面臨了什麼問題？讓 React Native 開發團隊決定重構。","content":"\n# 解析 React Native 現行架構（Current Architecture）原理\n\n長久以來，React Native 的效能問題一直為人詬病，為了解決這個問題，React Native 開發團隊針對舊有的架構進行了重構，並在 0.68 版本推出了新架構（New Architecture）。接下來，我會分享原來的架構是 Javascript 如何與 natvie 溝通，究竟面臨了什麼問題？讓 React Native 開發團隊決定重構。\n\n要來了解現行架構是怎麼運作，先來認識幾個重要的概念：\n\n## Keywords\n\n### Javascript Engine\n\n就是指執行 Javascript 程式碼的環境。\n\n- [Hermes](https://reactnative.dev/docs/hermes):\n  是基於 React Native 打造的 JS Engine，在 React Native 0.70 版時被設為預設的 JS Engine。\n\n- [JavaScriptCore](https://developer.apple.com/documentation/javascriptcore):\n  Apple 開發的 JS Engine，較舊版本的 React Native 會使用這個引擎。\n\n### JSON 序列化（serizlized）\n\n就是把資料轉換成 JSON 格式的過程，反之， JSON 反序列化就是把 JSON 格式轉成原始資料的過程。\n\n### Yoga engine\n\n是一種跨平台佈局引擎（Layout engine），主要是用來計算使用者畫面中 UI 元素的位置，藉此生成每一個 React shadow node 的位置與大小，ex:把 Flexbox 佈局轉換成原生平台的佈局樣式。\n\n# React Native 利用三個主要執行緒（threads）進行運作\n\n- UI Thread/ Native Thread：\n  是 UI Manager 負責處理用戶的介面操作 Andriod 跟 iOS 畫面的渲染邏輯，以及呼叫原生 api、運行原生模組。\n- JavaScript Thread:\n  主要是 JS Engine 使用，負責運行 JS Bundle 中的 JavaScript 程式碼，處理邏輯。\n- Shadow thread:\n  負責原生的佈局，提供給 yoga 引擎使用，其負責在渲染主機畫面（host screen）前計算佈局中元素的位子與大小。\n\n# 現行架構（Current Architecture）\n\n![https://ithelp.ithome.com.tw/upload/images/20230924/20162496DhGCCLaxPg.png](https://ithelp.ithome.com.tw/upload/images/20230924/20162496DhGCCLaxPg.png)\n\n## 現行架構運作的流程\n\nreact 經過 Metro 打包編譯後產生 JS Bundle，JS Bundle 在 JavaScriptcore （JavaScript 引擎）的環境下執行，JavaScript 的程式碼與原生的程式碼透過 **橋接（Bridge）** 的方式溝通。\n\n橋接（Bridge）是如何進行溝通呢？ 原生模組（Native module） 透過 Bridge 封裝成 JavaScript 接口提供給 JavaScript 引擎呼叫 Native 的方法。\n\nNative 與 JavaScript 之間溝通的方法是使用非同步的 JSON 序列化與反序列化方式去傳遞與轉換資料，也就是 JS thread 會傳送以 JSON 序列化的訊息並且以字串符發送到 Bridge，Bridge 會優化這個訊息並且傳遞到 UI Thread/ Native Thread，UI Thread/ Native Thread 收後解密這條訊息，然後根據這條訊息去執行原生的程式碼。\n\n當應用程式啟動時，UI Manager 會下載所有的原生模組，React 會在 JavaScript Thread 執行產生 React Element Tree ，一旦渲染時就會透過 Bridge 發佈變更的指令到 Shadow Thread，創造 React Shadow Tree （似 React Virtual DOM 功能），顯示應用程序的 UI 的佈局和結構來比對 UI 需進行哪些更改，然後透過 yoga 引擎去計算 UI 元素在原生螢幕的位置和大小，一旦 Yoga 完成布局計算，React Native 的 UI Manager 就會將使用原生平台特定的 API 轉換成原生的 Host View Tree 並且通知 UI Thread 使用原生元素在用戶的螢幕上呈現變更後的 UI。\n\n## 現行架構使用橋接（Bridge）存在的一些問題\n\n- 操作是非同步(asynchronous)的：\n  原生或 JavaScript 其中一端傳遞消息到 Bridge ，需要等另外一端處理這些消息，即使這個等待很沒必要。Bridge 就像是一條單線道的橋，當兩端都有車想要通過時，必須先等待其中一端過橋，另一端的車子才能過橋，曠時費力。\n\n- 只能在單一執行緒(single-threaded)上進行：\n  JavaScript 只能在單一的 thread 上運行，所以會導致某些計算必須等待這個 thread 完成。\n\n- 序列化造成效能消耗大:\n  由於透過 JSON 格式傳遞消息，每一次都經過序列化跟反序列化，造成效能的開銷很大。\n\n以上的原因導致效能不佳，也連帶了影響使用者體驗。舉例來說，有一個很長的列表，當使用者在使用手勢快速向下滑動的時候，就很可能在剩下的資料回傳之前看到螢幕出現白屏。造成白屏的原因就在於：\n\n1. 原生的 onScroll 事件傳遞到 JavaScript Thread\n2. JavaScript 去呼叫 api 取得新的資料\n3. JavaScript 取得資料後把新的佈局細節傳給 shadow tree\n4. shadow tree 透過 Yoga engine 計算好佈局的細節後，傳送到原生的 UI\n\n當使用者操作速度一快，Bridge 就塞車了～畫面也就因此卡住了。\n\n#### 參考資料\n\n- [React Native 原理与实践](https://juejin.cn/post/6916452544956858382#heading-18)\n- [React Native: Understanding Threads.](https://brooklinmyers.medium.com/react-native-understanding-threads-e026c7d62bb2)\n- [React Native’s bridge, under the hood](https://medium.com/@samwhadams/react-native-under-the-hood-80677cf9bf96)\n- [React Native 渲染原理](https://zhuanlan.zhihu.com/p/388681402)\n- [Does React Native have a 'Virtual DOM'?](https://stackoverflow.com/questions/41804855/does-react-native-have-a-virtual-dom)\n\n:::note\n\n本篇文章原先發佈於[ithome](https://ithelp.ithome.com.tw/articles/10326761)\n","createdAt":"2025-08-16T08:43:55.951Z","updatedAt":"2025-08-16T10:25:15.094Z","publishedAt":"2025-08-16T10:25:15.096Z","locale":null,"author":null}}
{"type":"api::post.post","id":179,"data":{"documentId":"f86eik6bjvt71hf8wvijljp8","slug":"reac-native-new-arch","title":"reac-native-new-arch","date":"2025-08-16T08:43:55.959Z","description":"解析 React Native 新架構（New Architecture） 原理 在 DAY20 解析 React Native 現行架構（Current Architecture）原理 理解了現行架構使用橋接（bridge）溝通的缺點後，接著就要了解現行架構 React Native 開發團隊如何改進？在新的架構中又如何加強與原生模組的通訊？ 同樣的，幾個新架構的重要關鍵字必須先瞭解一下： Keywords codeGen 一個靜態類型的檢查器，會在應用程式建構 (App build time) 的時候，將靜態類型的 Javascript 程式碼（Typescript、Flow）翻譯成...","content":"\n# 解析 React Native 新架構（New Architecture） 原理\n\n在 [DAY20 解析 React Native 現行架構（Current Architecture）原理](https://ithelp.ithome.com.tw/articles/10326761) 理解了現行架構使用橋接（bridge）溝通的缺點後，接著就要了解現行架構 React Native 開發團隊如何改進？在新的架構中又如何加強與原生模組的通訊？\n\n同樣的，幾個新架構的重要關鍵字必須先瞭解一下：\n\n## Keywords\n\n### codeGen\n\n一個靜態類型的檢查器，會在**應用程式建構** (App build time) 的時候，將靜態類型的 Javascript 程式碼（Typescript、Flow）翻譯成 Fabric 和 Turbo Modules 使用的原生程式碼 和 JSI 需要的 C++。\n使用 codeGen 可以減少開發維護原生模組或程式碼的成本，只要提供 typed JavaScript 即可產生原生的程式碼了。\n\n### JSI （JavaScript Interface）\n\n一個輕量的 API，可以用於任何 JavaScript virtual machine，讓不同的平台可以用不同的 JavaScript 引擎。\nJSI 是用 C++ 寫的，它將 JavaScript 引擎嵌入 C++ 應用程式中。\n\n透過 JSI 可以直接讓 JavaScript 程式碼呼叫原生程式碼的函數，獲取原生對象的引用，然後同步地使用這些引用來訪問原生功能，不需要使用 JSON 序列化轉換資料的過程，就可以提升溝通效率。\n\n例如，想要打開手機的相機，就可以透過 JavaScript 去呼叫原生拍照的 Api ，打開相機的這項任務就會在原生程式碼中執行。\n\n### Fabric\n\nFabric 是新的 UI 渲染系統，旨在提升框架與主機平台（host platforms：原生端的平台）互用性、加強 JavaScript 與原生線程的溝通。\n\nFabric 向 JavaScript 提供了本身的函式，使用 JSI 讓 Hermes 跟原生端（C++ core）透過 ref functions 直接溝通。\n\nFabric 可以直接在 C++ 中創建 Shadow Tree，以減少渲染特定元素的步驟。\n\n### Turbo Modules\n\n就是加強版的原生模組系統（Native modules）。\n\n### Hermes\n\n針對 Android 運行 React Native 優化的 JavaScript 引擎。從版本 0.69 起 Hermes 便被設為預設的 JavaScript 引擎。\n\n# 新架構（New Architecture）\n\n![https://ithelp.ithome.com.tw/upload/images/20230924/20162496oJzBAEMebk.png](https://ithelp.ithome.com.tw/upload/images/20230924/20162496oJzBAEMebk.png)\n以下透過從應用程式的建構到啟動說明新架構運作的流程。\n\n一. 應用程式建構階段 App Build time：\n當開發人員將 React Native 打包為 APK 檔案或 IPA 檔案時，透過 build 指令將 JavaScript 編譯成 bytecode，同時透過 Codegen 將 Javascript 程式碼轉換成 c++。\n\n二. 應用程式運行階段 App Run time：\n當使用者打開應用程式時\n\n1. 應用程式會讀取 bytecode 檔案，並透過 Hermes JavaScript 引擎執行。\n2. JavaScript 直接透過 JSI 跟原生模組溝通。\n3. Turbo Module 直接透過 JSI 與 JavaScript 溝通。\n4. JavaScript 中的 React 元件將會透過 Fabric 去渲染原生 UI 畫面，同時 Fabric 也是使用 JSI 跟原生模組、JavaScript 溝通。\n5. Fabric 會使用 Yoga 引擎去計算使用者介面的佈局。\n6. Fabric 使用 Fabric Renderer 在使用者螢幕上繪製用戶介面元素，並且呼叫原生圖形 API 去處理手勢、動畫..等功能。\n\n## 新架構的改變\n\n- JSI 取代了原來的 Bridge\n- Fabric 取代了原來的 UI manerger\n- Turbo Modules 取代了原來的 Native modules\n- JavaScript 引擎不再侷限於 JavaScriptCore\n\n## 新架構帶來的效益\n\n### JSI\n\n- 使用 JSI 接口讓 native code 可以更有效率地與 Javascript 通訊。\n\n### Fabric\n\n- 使 React Native 應用程式更好地與原生應用程式的視圖之間交互運作，這意味著 React Native 可以更輕鬆地嵌入並與原生視圖（host views）進行互動，使應用程式在不同平台上更具靈活性和一致性。\n- 透過整合 React Suspense 可以更有效地取得資料。\n\n### Turbo Modules\n\n- 使用強型別的接口在不同平台可以保持一致性。\n- 舊架構中，在應用程式啟動時就要載入全部的原生模組，但是 Turbo Modules 可以啟用模組 Lazy loading ，根據需求下載需要的原生模組，讓應用程式啟動的速度更快。\n\n### Hermes\n\n- 更快的 TTI（time to interactive）：TTI 就是只當點下應用程式圖示到第一個畫面 (screen) 渲染完成的時間。根據 Meta 的研究，iOS 花費的時間下降了 63%、Android 下降 51%。打開應用程式的速度變快了。\n- 更小的應用程式 bundle。\n- 記憶體耗用量(Memory consumption) 減少。\n- 促進 JavaScript 跟原生溝通的效率。\n\n# 小結\n\n- 靜態型別的檢查提升了 JavaScript 與原生的相容性。\n- 新架構藉由響應式與流暢的介面提升了使用者體驗。\n- 新架構更好的 debug 。\n- 新架構讓手機應用程式啟動變快。\n- 新架構可以同步地處理需要立即執行的任務，而不受非同步的不確定性影響。\n\n目前 React Native 雖然有加入新架構，但是必須再另外設定才能啟用，換句話說就是目前版本還是以現行的架構運行，但可以從 React Native 在 0.68 引入新架構，再到 React Native 0.71 預設使用 TypeScript ，不難發現 React Native 開發團隊正慢慢的把整體專案往符合新架構的方向去調整。或許，預設使用新架構的版本指日可待（？\n\n#### 參考資料\n\n- [React Native 新架构分析](https://juejin.cn/post/6893032764124168206#heading-2)\n- [Deep dive into React Native’s New Architecture](https://medium.com/coox-tech/deep-dive-into-react-natives-new-architecture-fb67ae615ccd)\n- [ADDING REACT NATIVE TO A COMPLEX APP — PART 2: UNDER THE HOOD](https://www.nearform.com/blog/adding-react-native-to-a-complex-app-part-2-under-the-hood/)\n- [React Native New Architecture in depth (Hermes, JSI, Fabric, Yoga, Turbo Module, Codegen)](https://medium.com/@anisurrahmanbup/react-native-new-architecture-in-depth-hermes-jsi-fabric-fabric-renderer-yoga-turbo-module-1284a192a82b#1f8e)\n- [Why a New Architecture](https://reactnative.dev/docs/the-new-architecture/why)\n- [React Native New Architecture](https://medium.com/@mishraabhishek.11/react-native-new-architecture-937c76547b29)\n- [React Native Architecture: A Conceptual Overview](https://medium.com/@kdsinghak47/react-native-architecture-a-conceptual-overview-7e2794400de)\n\n:::note\n\n本篇文章原先發佈於[ithome](https://ithelp.ithome.com.tw/articles/10326854)\n","createdAt":"2025-08-16T08:43:55.963Z","updatedAt":"2025-08-16T10:25:15.104Z","publishedAt":"2025-08-16T10:25:15.106Z","locale":null,"author":null}}
{"type":"api::post.post","id":180,"data":{"documentId":"gfjpxjgu282mvqd0x63omlch","slug":"react-native-versions","title":"react-native-versions","date":"2025-08-16T08:43:55.972Z","description":"React Native 各個版本更新摘要（更新至 0.74） 留意專案目前使用的 React Native 版本 React Native 版本很重要，根據 React Native 的版本號不同，所支援的功能、環境、套件相容性、渲染系統都有所不同，會大大影響後續開發的難易度。所以應去了解手上的版本的內容去設定開發環境的配置。 我整理了以下各版本的更新摘要： 由新版本至舊版本各個版本的更新摘要（0.74 ~ 0.60） React Native 0.74（2024年4月） - 推出 Yoga 3.0： 全新的 layout 引擎 - 支援 align-content:...","content":"\n# React Native 各個版本更新摘要（更新至 0.74）\n\n## 留意專案目前使用的 React Native 版本\n\nReact Native 版本很重要，根據 React Native 的版本號不同，所支援的功能、環境、套件相容性、渲染系統都有所不同，會大大影響後續開發的難易度。所以應去了解手上的版本的內容去設定開發環境的配置。\n我整理了以下各版本的更新摘要：\n\n## 由新版本至舊版本各個版本的更新摘要（0.74 ~ 0.60）\n\n### React Native 0.74（2024年4月）\n\n- 推出 Yoga 3.0： 全新的 layout 引擎\n  - 支援 `align-content: 'space-evenly'`\n  - 支援 `position: 'static'`: 只有在新架構才支援這個屬性\n- 新架構：\n  - [預設 Bridgeless 模式](https://github.com/reactwg/react-native-new-architecture/discussions/174)\n  - onLayout callback 支援 batch update :\n    本來在 onLayout callback 中的每更新一個狀態就會直接重新渲染，新版的 onLayout callback 採用 batch update 也就是將所有 onLayout callback 中的狀態都一次更新後再進行渲染提交，如此可以減少渲染的次數。\n- 新的專案預設使用 Yarn 3\n- Android 最小 SDK 版本提升至 23 (Android 6.0)\n- 刪除已經棄用的 `PropTypes`\n- 刪除已經棄用的 `PushNotificationIOS API`\n\n### React Native 0.73（2023年12月）\n\n- 提升 Debugging\n  - 在 Hermes 在後台捕獲所有 `console.log()` 調用\n- Metro 更穩定的支援 Symlink\n- 支援 Android 14\n- Kotlin 現在是官方使用 React Native 構建的 Android 應用程式的推薦語言。\n  - 快速遷移 Java 到 Kotlin：Android Studio `Code > Convert Java file to Kotlin File`\n- Android Gradle 外掛程式 (AGP) 版本從 7.4.x 更新至 8.1.x。\n- 建立 Android 應用程式必須使用 Java 17\n- Android 最小 SDK 版本提升至 21 (Android 5.0)\n- 新架構：\n  - 新增 Bridgeless 模式\n- 棄用 Flipper 與 React Native 整合: 棄用 Flipper 作為React Native debug 工具\n- 棄用 `@types/react-native`\n- ios 應用程式最低支援版本 13.4\n\n### React Native 0.72（2023年6月）\n\n- Metro 支援 Symlink：主要用來建立 monorepo\n- 開發者體驗提升：\n  - style 樣式錯誤不再以 Redbox 的形式顯示\n  - Hermes 提供可讀性更好的錯誤訊息\n  - 改進 React Native CLI 的錯誤輸出\n  - Hermes 更快編譯與加速 JSON 解析\n- 重新命名 react-native/packages：需要修改路徑、升級到 0.72\n- 移除棄用的元件：Slider、DatePickerIOS、ProgressViewIOS\n\n### React Native 0.71（2023年1月）\n\n- 預設使用 TypeScript\n- 新增 Flexbox gap 屬性\n- 修復 PropTypes： 0.66 的時候把這個屬性棄用，在這個版本又加回來（？\n- 新增 React DevTools 網頁 debug 工具\n- 優化 Hermes 性能：提升 JSON.parse 效能 30%\n- 優化新架構（New Architecture）：減少 build 的時間、Android 刪除大量 C++ 程式碼\n- 刪除 AsyncStorage and MaskedViewIOS\n\n### React Native 0.70（2022年9月）\n\n- 預設使用 Hermes 引擎\n- Codegen 配置修改\n- React Native CLI 更新至 9.0\n- 更新 Android Gradle Plugin 至 7.2.1\n- 更新 Android Gradle version 至 7.5.1\n- 更新 Metro 至 0.72\n\n### React Native 0.69（2022年6月）\n\n- 預設使用 React 18\n- 内建 Hermes\n- 更新 Android Gradle Plugin 至 7.1.1\n- React Native CLI 更新至 8.0\n- Ruby 更新至 2.7.5\n\n### React Native 0.68（2022年3月）\n\n- 更新至 Node 16 LTS ，最低支援到 Node 14\n- 更新 Android Gradle Plugin 至 7.0.1\n- 更新 Metro 至 0.67\n- 更新 Kotlin 至 1.6.10\n- 更新 Android Gradle version 至 7.3\n- 更新 Android compile and target SDK 至 31\n- 使用新架構（New Architecture）：此版開始使用 Fabric 渲染器和TurboModule 系統。有關新架構做了什麼改變可以看這篇 [DAY 21 解析 React Native 新架構（New Architecture） 原理](https://ithelp.ithome.com.tw/articles/10326854)。\n- 強制使用 JSDK 11\n\n### React Native 0.67（2022年1月）\n\n- 更新 Android Gradle version 至 7.2\n- 更新 Android Kotlin version 至 1.5.31\n- 棄用 DatePickerAndroid\n\n### React Native 0.66（2021年10月）\n\n- 支援 Android 12 、 iOS 15\n- 支援 Android 12 新的藍牙權限\n- 提供 Apple Silicon (M1) Mac、 Xcode 13、 iOS 15 更好的支援\n- Hermes 0.9.0\n- 棄用 PropTypes\n\n### React Native 0.65（2021年8月）\n\n- Hermes 0.8 支援：Hermes iOS 此版開始支援 Apple M1 晶片\n- 修正與更新無障礙功能(Accessibility)\n- JCenter 停用：不再使用 JCenter 來分發原生模組。\n- 支援 Android Gradle Plugin 7\n\n### React Native 0.64（2021年3月）\n\n- ios 支援 [Hermes](https://hermesengine.dev/)：藉由降低內存利用率、減少下載大小等方法，使用 Hermes Javascript 引擎可提升 React Native 效能。\n- Metro 配置選項 Inline Requires：縮短啟用時間\n- Hermes 支援 Proxy\n- React 17\n- 棄用 Android API levels 16-20.\n- 最低版本 Xcode 12、 CocoaPods 1.10\n- Node.js 版本支援Node 10 - Node 12\n\n### React Native 0.63（2020年7月）\n\n- LogBox 功能：改進了錯誤和警告的顯示方式，提高了可讀性。\n- Pressable 元件\n- 停止支援 iOS 9 和 Node.js 8\n\n### React Native 0.62（2020年3月）\n\n- 將 Flipper 設為預設 debugg 的開發者工具\n- 新增 dark mode 功能： Appearance module、useColorScheme hook\n\n- React Native 0.61（2019年9月）：\n\n  - Fast Refresh 功能：提高了開發體驗。\n\n- React Native 0.60（2019年7月）：\n  - 導入自動連結（Auto Linking）：取代原本的 rnpm，安裝套件將自動連結原生模組，減少連結過程的複雜性。\n  - AndroidX 支援：專案中有使用 Android 原生的程式碼或依賴的項目必須手動遷移。\n  - 預設使用 CocoaPods: ios 專案管理套件的工具\n\n如果你的接手專案低於 0.60 就要再好好考慮一下維護的成本，在升版本或維護的過程會比0.60 以上的版本難度更高，因為沒有 Auto Linking 你需要自己做好依賴與原生模組的連結。\n\n從上面各版更新的內容，我們可以從版本迭代中發現更動的幅度很大，所以在接手專案時，應該根據版號去設置環境，甚至了解該版號支援哪些內容，才可以更快上手，避免在環境建置的時候踩坑。\n\n## 根據版號內容去檢查目前專案的環境\n\n### 幫你檢查目前專案建置情況\n\n在終端機輸入：\n\n```\nnpx @react-native-community/cli doctor\n```\n\n![https://ithelp.ithome.com.tw/upload/images/20230909/201624969pz9MA36hi.png](https://ithelp.ithome.com.tw/upload/images/20230909/201624969pz9MA36hi.png)\n透過這個指令，它會幫你檢查環境是否相容，並且列出錯誤訊息，當下即可修正。但，即使修正了這些錯誤，你的專案還是開不起來？可能就需要檢查更細節的內容了。\n\n### 取得目前專案的環境\n\n在終端機輸入：\n\n```\nnpx react-native info\n```\n\n會取得你目前的專案的環境，他會詳細地列出所有有關這個專案的環境：\n\n```\ninfo Fetching system and libraries information...\nSystem:\n  OS: macOS 13.5.1\n  CPU: (10) arm64 Apple M2 Pro\n  Memory: 614.67 MB / 32.00 GB\n  Shell:\n    version: \"5.9\"\n    path: /bin/zsh\nBinaries:\n  Node:\n    version: 16.19.1\n    path: ~/.nvm/versions/node/v16.19.1/bin/node\n  Yarn:\n    version: 1.22.19\n    path: /opt/homebrew/bin/yarn\n  npm:\n    version: 8.19.3\n    path: ~/.nvm/versions/node/v16.19.1/bin/npm\n  Watchman:\n    version: 2023.07.24.00\n    path: /opt/homebrew/bin/watchman\nManagers:\n  CocoaPods:\n    version: 1.12.1\n    path: /Users/ashely/.rvm/gems/ruby-2.7.6/bin/pod\nSDKs:\n  iOS SDK:\n    Platforms:\n      - DriverKit 22.4\n      - iOS 16.4\n      - macOS 13.3\n      - tvOS 16.4\n      - watchOS 9.4\n  Android SDK:\n    API Levels:\n      - \"27\"\n      - \"28\"\n      - \"30\"\n      - \"33\"\n      - \"33\"\n      - \"34\"\n    Build Tools:\n      - 30.0.2\n      - 30.0.3\n      - 33.0.0\n      - 33.0.1\n      - 33.0.2\n      - 34.0.0\n    System Images:\n      - android-21 | ARM 64 v8a\n      - android-21 | Google APIs ARM 64 v8a\n      - android-23 | ARM 64 v8a\n      - android-24 | ARM 64 v8a\n      - android-26 | ARM 64 v8a\n      - android-28 | ARM 64 v8a\n      - android-28 | Google ARM64-V8a Play ARM 64 v8a\n      - android-29 | ARM 64 v8a\n      - android-33 | Google APIs ARM 64 v8a\n      - android-33 | Google APIs Intel x86_64 Atom\n      - android-34 | Android TV ARM 64 v8a\n      - android-34 | Android TV Intel x86 Atom\n      - android-34 | Google TV ARM 64 v8a\n      - android-34 | Google TV Intel x86 Atom\n      - android-34 | Google APIs ARM 64 v8a\n    Android NDK: Not Found\nIDEs:\n  Android Studio: Not Found\n  Xcode:\n    version: 14.3.1/14E300c\n    path: /usr/bin/xcodebuild\nLanguages:\n  Java:\n    version: 20.0.2\n    path: /usr/bin/javac\n  Ruby:\n    version: 2.7.6\n    path: /Users/ashely/.rvm/rubies/ruby-2.7.6/bin/ruby\nnpmPackages:\n  \"@react-native-community/cli\": Not Found\n  react:\n    installed: 18.2.0\n    wanted: 18.2.0\n  react-native:\n    installed: 0.72.4\n    wanted: 0.72.4\n  react-native-macos: Not Found\nnpmGlobalPackages:\n  \"*react-native*\": Not Found\nAndroid:\n  hermesEnabled: true\n  newArchEnabled: false\niOS:\n  hermesEnabled: true\n  newArchEnabled: false\n```\n\n根據筆者經驗，其中有幾個版號需要特別注意的，常常應用程式 build 失敗都跟這些版號設定有關：\n\n- Node.js\n- CocoaPods\n- iOS SDK\n- Android SDK\n- Java\n- Xcode\n\n通常專案無法編譯，有可能是因為環境與當前 React Native 版本不相容，如果真的建置專案環境時遇到困難，使用 `npx react-native info` 把你的環境列出來會對於你在社群發問時有幫助的。\n\n### 參考資料\n\n[React Native 官方 blog](https://reactnative.dev/blog)\n","createdAt":"2025-08-16T08:43:55.976Z","updatedAt":"2025-08-16T10:25:15.113Z","publishedAt":"2025-08-16T10:25:15.115Z","locale":null,"author":null}}
{"type":"api::post.post","id":181,"data":{"documentId":"zys0aaevc7h803fdwqlioxyv","slug":"call-apply","title":".call 和 .apply 的差異","date":"2025-08-16T08:43:54.617Z","description":".call 和 .apply 的差異 .call跟.apply 都可以直接呼叫函式並且改變函式內 this 的指向，兩者最主要的差異是傳入的參數形式不同。 .call - 定義：.call 方法會立即執行函式，並將 this 指向傳入的第一個參數，接下來的參數是要傳給函式的具體值，一個一個地傳入。 - 參數形式：.call是 逐個傳入參數的。 - fn.call(thisArg, arg1, arg2, ...) - 使用時機：所有參數的數量，並且想逐個傳遞。 在這個例子中，this 被設定為 person，並且 food 和 count 是逐個傳入的。","content":"\n# .call 和 .apply 的差異\n\n`.call`跟`.apply` 都可以直接呼叫函式並且改變函式內 this 的指向，兩者最主要的差異是傳入的參數形式不同。\n\n## `.call`\n\n- 定義：`.call` 方法會立即執行函式，並將 this 指向傳入的第一個參數，接下來的參數是要傳給函式的具體值，一個一個地傳入。\n- 參數形式：`.call`是 逐個傳入參數的。\n- `fn.call(thisArg, arg1, arg2, ...)`\n- 使用時機：所有參數的數量，並且想逐個傳遞。\n\n```js\nfunction order(food, count) {\n  console.log(this.name, \"點了\", food, count);\n  //Ashley 點了 豚骨拉麵 一份\n}\nconst person = {\n  name: \"Ashley\",\n};\norder.call(person, \"豚骨拉麵\", \"一份\");\n```\n\n在這個例子中，this 被設定為 person，並且 food 和 count 是逐個傳入的。\n\n## `.apply`\n\n- 定義：`.apply` 與 `.call` 類似，也會立即執行函式，並將 this 指向傳入的第一個參數。但是，接下來的參數必須以陣列的形式傳遞。\n- 參數形式：`.apply` 是用 **陣列** 傳遞參數的。\n- `fn.apply(thisArg, [arg1, arg2, ...])`\n- 使用時機：參數是以陣列的形式存在，或者數量不確定時。\n\n```js\nfunction order(food, count) {\n  console.log(this.name, \"點了\", food, count);\n  //Andy 點了 沾麵 兩份\n}\nconst person = {\n  name: \"Andy\",\n};\norder.apply(person, [\"沾麵\", \"兩份\"]);\n```\n\n在這個例子中，this 被設定為 person，而參數 food 和 count 是以陣列的形式傳遞。\n","createdAt":"2025-08-16T08:43:46.661Z","updatedAt":"2025-08-16T10:25:15.121Z","publishedAt":"2025-08-16T10:25:15.124Z","locale":null,"author":null}}
{"type":"api::post.post","id":182,"data":{"documentId":"chbr8aan2a16owyena95y8el","slug":"translate","title":"為什麼實作 CSS 動畫位移效果使用 translate() 比 absolute 絕對定位更好？","date":"2025-08-16T08:43:54.116Z","description":"為什麼實作 CSS 動畫位移效果使用 translate() 比 absolute 絕對定位更好？ 剛好在最近工作上有遇到這個問題，在這裡我們會討論到 translate() 和 absolute 的差異，以及為什麼我們應該使用 translate() 來移動元素。 translate()的優勢 translate() 是 CSS transform 的一個屬性，用來移動元素的位置。它是一個 2D 或 3D 的函數，可以在 x, y, z 軸上移動元素。","content":"\n# 為什麼實作 CSS 動畫位移效果使用 `translate()` 比 `absolute` 絕對定位更好？\n\n剛好在最近工作上有遇到這個問題，在這裡我們會討論到 `translate()` 和 `absolute` 的差異，以及為什麼我們應該使用 `translate()` 來移動元素。\n\n## `translate()`的優勢\n\n`translate()` 是 CSS `transform` 的一個屬性，用來移動元素的位置。它是一個 2D 或 3D 的函數，可以在 x, y, z 軸上移動元素。\n\n```css\n.element {\n  position: relative;\n  transform: translate(100px, 100px);\n}\n```\n\n當使用 `translate()` 移動元素的時候，元素仍然保持在原本的位置，只是視覺上移動了，瀏覽器不會重新計算元素的佈局，也就是說，不會觸發 `reflow`。取而代之的是，`translate()` 只會觸發瀏覽器的 合成階段（compositing），這是在 GPU 而非主執行緒中執行的操作，因此效能更佳，並能產生流暢的動畫效果。\n\n## `absolute` 絕對定位的問題\n\n絕對定位會將元素超脫原來的頁面流，並且會根據最近的父元素或是 `body` 來定位。\n\n```css\n.element {\n  position: absolute;\n  top: 100px;\n  left: 100px;\n}\n```\n\n使用 `absolute` 絕對定位該元素然後透過 `top` 、 `left`、 `bottom`、`right` 來移動元素，但是當元素被移動後會觸發 **reflow**，這樣會造成效能問題，這個過程會導致瀏覽器重新繪製 (repaint) 整個畫面或部分畫面，從而增加效能負擔，尤其在複雜的網頁中，這可能會導致畫面卡頓或掉幀。\n\n## 瀏覽器的渲染過程\n\n這要從瀏覽器如渲染出一個網頁開始：\n\n### (一)、解析階段\n\n1. 瀏覽器會解析 HTML 並建立 DOM Tree\n2. 瀏覽器會解析 CSS Link tag 並建立 CSSOM Tree\n\n### (二)、Render 階段\n\n1. 在主執行緒中，DOM Tree 和 CSSOM Tree 會合併成 Render Tree。\n2. **Layout**: 在主執行緒中，瀏覽器根據 **Render Tree** 生成 **Layout Tree**，計算每個元素的位置和大小。\n\n   - 這個過程瀏覽器會將頁面進行分層產生 **Layer tree**，每一層都是一個獨立的圖層。\n   - 在這個階段瀏覽器會計算每個圖層的位置和大小，產生一個繪製的指令與塗層疊加的順序。\n   - 最終這些圖層疊加在一起會形成頁面。\n   - **Reflow 回流**：當元素的幾何位置和大小發生變化時，瀏覽器會重新計算 Layout Tree中的元素物理屬性，這個過程稱為 Reflow，例如：\n     height、padding、position...等。\n\n3. **Paint**: 在主執行緒中，瀏覽器根據 Layout Tree 進行繪製。\n   - **Repaint 重繪**：當元素的外觀發生變化時，瀏覽器會重新繪製元素，這個過程稱為 Repaint，例如：\n     color、background-color...等。\n4. **合成 Compositing**：在 Compositor thread 和 Raster thread 中，瀏覽器將繪製好的圖層進行合成。\n   - 各個 Layer 圖層會進行柵格化 rasterize，將圖層轉換成 Pixel 顯示在螢幕上。\n   - 在 Compositor thread 將這些經過柵格化的圖層進行合成，將這些圖層合成一個整體的畫面。\n   - Compositor thread 會將 layer 切成一個個的 tile，然後將這些 tile 送到 Raster thread，將tile 進行柵格化後存到瀏覽器的 GPU 。\n   - Compositor thread 根據 draw quads 資訊產生 Compositor frame，然後將這些 Compositor frame 送到 browser 階段 。\n\n### (三) Browser 階段\n\n1. 瀏覽器將 Compositor frame 送到 GPU 。\n2. 瀏覽器將渲染好的畫面顯示在螢幕上。\n\n無論是 Reflow 或 Repaint ，當觸發了上方渲染的某一個階段後，後續的階段也都會跟著被觸發。\n\n## 總結\n\n所以回到這個問題的本質，當使用 `absolute` 絕對定位移動元素時，會觸發 **reflow**，這時候瀏覽器會重新計算元素的位置然後產生新的 Layout Tree，接著進行 Repaint 和 Compositing。\n但是使用 `translate()` 移動元素時，不會觸發 **reflow** 和 **repaint**，只會觸發合成階段。此外還有另外一個好處是合成階段不是在主執行緒中進行的，這樣就不會影響到主執行緒的效能，因此使用 `translate()` 移動元素的效果比 `absolute` 絕對定位更可以縮短瀏覽器繪製的時間，還能讓動畫在 GPU 上進行處理讓動畫更加流暢。\n","createdAt":"2025-08-16T08:43:45.743Z","updatedAt":"2025-08-16T10:25:15.136Z","publishedAt":"2025-08-16T10:25:15.141Z","locale":null,"author":null}}
{"type":"api::post.post","id":183,"data":{"documentId":"ealem383tko6x7u45yzl1l7s","slug":"this","title":"this 如何在 JavaScript 中運作？","date":"2025-08-16T08:43:54.430Z","description":"this 如何在 JavaScript 中運作？ 在 JavaScript 中this的指向會根據不同呼叫的方式而有不同的結果，以下分別列出幾種this的運作方式： 全域環境 在全域的環境下： - 瀏覽器中：this指向的是window物件 - Node.js: this指向一個空的模組作用域內的物件 直接呼叫函式 當直接呼叫函式，在函式中的this均指向的是window物件。 new 運算子 使用new運算子會建立一個新的物件實例，此時的this的指向為該物件。 物件的方法 當呼叫物件中的方法時，此時的this指向的是呼叫該方法的物件。","content":"\n# this 如何在 JavaScript 中運作？\n\n在 JavaScript 中`this`的指向會根據不同呼叫的方式而有不同的結果，以下分別列出幾種`this`的運作方式：\n\n## 全域環境\n\n在全域的環境下：\n\n- 瀏覽器中：`this`指向的是`window`物件\n- Node.js: `this`指向一個空的模組作用域內的物件\n\n```js\nconsole.log(this === window); //true\n```\n\n## 直接呼叫函式\n\n當直接呼叫函式，在函式中的`this`均指向的是`window`物件。\n\n```js\nfunction hiThis() {\n  console.log(this === window); // true (在瀏覽器中，非嚴格模式)\n}\n\nhiThis();\n\n(\"use strict\");\nfunction hiStrict() {\n  console.log(this === undefined); // true (嚴格模式)\n}\n\nhiStrict();\n```\n\n## new 運算子\n\n使用`new`運算子會建立一個新的物件實例，此時的`this`的指向為該物件。\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nconst person = new Person(\"Ashley\");\nconsole.log(person.name); // \"Ashley\"\n```\n\n## 物件的方法\n\n當呼叫物件中的方法時，此時的`this`指向的是呼叫該方法的物件。\n\n```js\nconst person = {\n  name: \"Ashley\",\n  sayHi: function () {\n    console.log(`Hi!${this.name}.`); //Hi!Ashley.\n  },\n};\n\nperson.sayHi();\n```\n\n在這個例子中，`this`指向的是 person\n\n## class constructor\n\n在 class 中 `this` 是自動綁定到 `class` 的實例，在 class 函式建構子中使用`this`呼叫函式，這裡的`this`指向的是 class 的實例。\n\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getPersonName() {\n    console.log(this);\n  }\n}\n\nconst person = new Person(\"Ashley\");\nconsole.log(person.getPersonName()); //Person{name:'Ashley'}\n```\n\n`this` 指向 class 的物件實例，也就是 Person 的實例。\n\n## 箭頭函式\n\n箭頭函式沒有自己的`this`，是繼承外層作用域的 `this`，因此即使在物件內使用箭頭函式，`this` 也不會指向該物件，而是指向箭頭函式定義時的外層環境。\n\n```js\nconst person = {\n  name: \"Ashley\",\n  sayHi: () => {\n    console.log(`Hi!${this.name}`); //Hi!undefined\n  },\n};\n\nperson.sayHi();\n```\n\n因為箭頭函式中的 `this` 是從外層作用域繼承，而不是指向 `person`，因為箭頭函式中的 this 指向外層的`window`，所以此例中 `this.name` 是 `undefined`。\n\n```js\nconst person = {\n  name: \"Ashley\",\n  sayHi: function () {\n    const arrowFn = () => {\n      console.log(`Hi!${this.name}`); //Hi!Ashley\n    };\n    arrowFn();\n  },\n};\n\nperson.sayHi();\n```\n\n在這個例子中，`arrowFn` 繼承了 `sayHi` 函式中的 `this`，因此指向 `person`。\n\n## 使用 `.call()`、.`apply()`、`.bind()`\n\n使用`.call`、`.apply`、`.bind.`可以傳入物件改變`this`的指向。\n\n```js\nfunction greet() {\n  console.log(this.name);\n}\n\nconst person = { name: \"Ashley\" };\n\ngreet.call(person); // Ashley\ngreet.apply(person); // Ashley\n\nconst boundGreet = greet.bind(person);\nboundGreet(); // Ashley\n```\n\n`call()` 和 `apply()` 會立即執行函式，並將 `this` 設定為傳入的物件。\n`bind()` 則會返回一個新的函式，並永久綁定 `this` 到傳入的物件。\n\n---\n\n## 實例練習 1\n\n[41. `this` III](https://bigfrontend.dev/quiz/this-III)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: this.a + 1,\n  c: () => this.a + 1,\n  d() {\n    return this.a + 1;\n  },\n  e() {\n    return (() => this.a + 1)();\n  },\n};\nconsole.log(obj.b);\nconsole.log(obj.c());\nconsole.log(obj.d());\nconsole.log(obj.e());\n```\n\n## 解題 1\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: this.a + 1,\n  c: () => this.a + 1,\n  d() {\n    return this.a + 1;\n  },\n  e() {\n    return (() => this.a + 1)();\n  },\n};\nconsole.log(obj.b); //NaN; 因為這裡this指的是window物件，undefined + 1\nconsole.log(obj.c()); //NaN; 因為這裡this指的是window物件，undefined + 1\nconsole.log(obj.d()); //2;因為這裡this指的是obj,1+1\nconsole.log(obj.e()); //2;因為匿名函式的this指向是上一層的作用域，上一層的指向是obj,1+1\n```\n\n## 實例練習 2\n\n[19. `this`](https://bigfrontend.dev/quiz/this)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: function () {\n    console.log(this.a);\n  },\n  c() {\n    console.log(this.a);\n  },\n  d: () => {\n    console.log(this.a);\n  },\n  e: (function () {\n    return () => {\n      console.log(this.a);\n    };\n  })(),\n  f: function () {\n    return () => {\n      console.log(this.a);\n    };\n  },\n};\n\nconsole.log(obj.a);\nobj.b();\nobj.b();\nconst b = obj.b;\nb();\nobj.b.apply({ a: 2 });\nobj.c();\nobj.d();\nobj.d();\nobj.d.apply({ a: 2 });\nobj.e();\nobj.e();\nobj.e.call({ a: 2 });\nobj.f()();\nobj.f()();\nobj.f().call({ a: 2 });\n```\n\n## 解題 2\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconst obj = {\n  a: 1,\n  b: function () {\n    console.log(this.a);\n  },\n  c() {\n    console.log(this.a);\n  },\n  d: () => {\n    console.log(this.a);\n  },\n  e: (function () {\n    return () => {\n      console.log(this.a);\n    };\n  })(),\n  f: function () {\n    return () => {\n      console.log(this.a);\n    };\n  },\n};\n\nconsole.log(obj.a); //1\nobj.b(); //1，this指向為obj\nobj.b(); //1，this指向為obj\nconst b = obj.b;\nb(); //undefined，b 被賦值給變數 b，這時 this 是 undefined\nobj.b.apply({ a: 2 }); //2，因為使用apply指定this為{ a: 2 }\nobj.c(); //1，this指向為obj\nobj.d(); //undefined，因為是箭頭函式，綁到上一層的作用域也就是全域\nobj.d(); //undefined\nobj.d.apply({ a: 2 }); //undefined，因為是箭頭函式，參考上一層\nobj.e(); //undefined，因為是箭頭函式，參考上一層\nobj.e(); //undefined，因為是箭頭函式，參考上一層\nobj.e.call({ a: 2 }); //undefined，箭頭函數的 this 不會被 call 改變\nobj.f()(); //1，f 返回一個箭頭函數，this 綁定到 f 的 this，即 obj\nobj.f()(); //1\nobj.f().call({ a: 2 }); //1，箭頭函數的 this 不會被 call 改變\n```\n","createdAt":"2025-08-16T08:43:46.340Z","updatedAt":"2025-08-16T10:25:15.165Z","publishedAt":"2025-08-16T10:25:15.167Z","locale":null,"author":null}}
{"type":"api::post.post","id":184,"data":{"documentId":"jeak9qszvhk56u45t8ysrs2d","slug":"reconciliation","title":"React 畫面更新的流程機制：reconcilliation","date":"2025-08-16T08:43:55.594Z","description":"在 component 畫面管理機制中， component 的渲染機制可以分成兩個階段，分別是 render phase 和 commit phase。 Render phase 在 Render 階段，component 會進行渲染，並且產生 react element。 Commit phase 在 Commit 階段，component 會把產生的 react element 畫面結構提交並處理到實際的瀏覽器 DOM 上面。","content":"\n在 component 畫面管理機制中， component 的渲染機制可以分成兩個階段，分別是 render phase 和 commit phase。\n\n## Render phase\n\n在 Render 階段，component 會進行渲染，並且產生 react element。\n\n## Commit phase\n\n在 Commit 階段，component 會把產生的 react element 畫面結構提交並處理到實際的瀏覽器 DOM 上面。\n\n### 第一次 render component\n\n#### Render phase\n\n1. 執行 component function 產生以 props 和 state 描述 component 畫面的 react element。\n2. 接著將生成的 react element 交到 Commit phase 處理。\n\n#### Commit phase\n\n1. mount:\n   這時由於是第一次 render，因此瀏覽器中並沒有 component 相對應的 DOM element，因此會將 react element 全部轉成相對應的實際 DOM element。\n2. mounted:\n   使用瀏覽器的 DOM API `appendChild()` 將生成的 DOM element 掛載到實際的瀏覽器。\n\n### re-render component\n\n#### Render phase\n\n1. 執行 component function 以新版本的 props 和 state 產生描述 component 畫面的 react element。\n2. 將新版本所產生的 react element 與上一次 render 的舊版 react element 進行樹狀結構的比較，找出差異。\n3. 將差異的部分交到 Commit phase 處理。\n\n#### Commit phase\n\n1. 只操作新舊 react element 差異所對應的 DOM element。\n\n## React reconciliation\n\n當呼叫 `setState` 後會發起 component re-render，React 會啟動 reconciliation 流程，最終更新瀏覽器的 DOM 並反映在畫面上。這個過程分為兩個主要階段：Render phase 和 Commit phase。component 內的子孫 component 也會連帶觸發 re-render：\n\n1. 呼叫 `setState` 更新資料\n   當呼叫 `setState` 時，React 並不會立即更新狀態。`setState` 是一個非同步操作，React 會將這個狀態更新加入一個任務隊列中，並且會自動將多個 `setState` 操作合併進行批次更新（batch update）。\n\n2. 檢查 state 是否有變化\n   React 會執行 [Object.is()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)，檢查 state 新舊資料是否有變化。\n   - 如果沒有變化，代表資料沒有更新也就不需要更新畫面，接下來的流程就會中斷。\n   - 如果有變化，就是資料有更新，接著就會進行 re-render。\n\n### Render phase\n\n3. 重新執行 Component function\n   re-render 會執行 component function 並以新版本的 props 和 state 產生新的 react element。\n4. Diffing\n   接著，react 會將前一份產生的舊版 react element 與新版 react element 使用 diffing 演算法來找出樹狀結構差異之處。\n\n### Commit phase\n\n5. 更新 DOM\n   比較完成後，根據差異的的部分所對應的 DOM element 進行操作， 這個更新過程會在瀏覽器的主執行緒上進行，包括更新 DOM 樹和應用 CSS 樣式，最後更新到瀏覽器 DOM 上。\n\n## `Object.is()` 拿掉會影響 reconciliation 嗎？\n\n並不會，`Object.is()`就只是個讓效能優化、減少 re-render 的檢查機制，沒有使用 `Object.is()` 檢查 state 就是直接讓 component 直接進行 re-render。\n","createdAt":"2025-08-16T08:43:55.619Z","updatedAt":"2025-08-16T10:25:15.178Z","publishedAt":"2025-08-16T10:25:15.181Z","locale":null,"author":null}}
{"type":"api::post.post","id":185,"data":{"documentId":"ti8gt789nbnwnp903s2b9ts1","slug":"variables","title":"let, var ,const 的差異","date":"2025-08-16T08:43:54.276Z","description":"JavaScript 中 let, var , const 的差異 使用 let、var 和 const 宣告變數時分別在：作用域、初始化、重複宣告、重新賦值、提升時有不同的行為。 作用域 scope var 的作用域是全域或是在 function 中，var 宣告的變數會被提升到整個函式的頂端; let 跟 const 則是區塊(block)作用域，這裡的 block 指的是 function 中或 if-else block 或 for-loop block，let 跟 const 只在它們所在的區塊內有效，使它們更具預測性，減少變數意外被覆蓋的可能性。","content":"\n# JavaScript 中 `let`, `var` , `const` 的差異\n\n使用 `let`、`var` 和 `const` 宣告變數時分別在：作用域、初始化、重複宣告、重新賦值、提升時有不同的行為。\n\n## 作用域 scope\n\n`var` 的作用域是全域或是在 function 中，`var` 宣告的變數會被提升到整個函式的頂端;\n\n`let` 跟 `const` 則是區塊(block)作用域，這裡的 block 指的是 function 中或 if-else block 或 for-loop block，`let` 跟 `const` 只在它們所在的區塊內有效，使它們更具預測性，減少變數意外被覆蓋的可能性。\n\n## 初始化 Initialization\n\n初始化就是指變數第一次的賦值。使用 `var` 跟 `let` 宣告的變數初始化可以不需要賦值;\n\n使用 `const` 初始化則需要必須賦值，否則會拋出: SyntaxError: Missing initializer in const declaration 的錯誤。\n\n```js\nvar a;\nlet b;\nconst c; // SyntaxError: Missing initializer in const declaration\n```\n\n## 重複宣告\n\n`var` 可以重複宣告，`var` 重複宣告時會覆蓋前面的變數; `let` 跟 `const` 則不可以。\n\n## 重新賦值\n\n`var` 跟 `let` 可以重新賦值; `const` 則不行，`const` 代表的是參考 (reference) 的不可變性 (immutable)，當物件和陣列被指派給 `const` 時，參考的是其記憶體的位置，物件和陣列的內容屬性是可以修改的，但不能重新指派為新的物件或陣列。\n\n```js\nvar a = 1;\na = 2;\n\nlet b = 3;\nb = 4;\n\nconst c = 5;\nc = 6; //error 因為 'c' 為常數，所以無法指派至 'c'。\n\nconst person = {\n    id:1 ;\n    name:'Ashley';\n}\nperson.id = 2; //可以修改 person 的 id ，因為仍是參考同一個記憶體位置。\nconsole.log(person.id); // 2\n\nperson  = {\n    id:5 ;\n    name:'Andy';\n}; // TypeError: Assignment to constant variable. 這時試圖指派一個全新的物件給 person（也就代表參考的記憶位置改變了），因參考不可變性所以報錯。\n```\n\n## 提升\n\n`var` 宣告的變數會自動初始化，初始值為 `undefined`;\n`let` 跟 `const` 宣告的變數會進到暫時死區 （TDZ, Temporal Dead Zone），直到執行到宣告的那一行。\n\n---\n\n## 實例練習\n\n[100. `var` vs `let`](https://bigfrontend.dev/quiz/var-vs-let)\n\n```js\nvar a = \"BFE\";\nlet b = \"bigfrontend\";\nconsole.log(this.a);\nconsole.log(this.b);\n```\n\n## 解題\n\n```js\nvar a = \"BFE\";\nlet b = \"bigfrontend\";\nconsole.log(this.a); //\"BFE\"\nconsole.log(this.b); //undefined\n```\n\n因為 `var` 的作用域是全域，`var` 的變數會被加到全域物件，在瀏覽器中是 `window` 物件，`this` 通常指向全域物件，因此 `this.a` 等同於 `window.a` 也就是\"BFE\"。\n\n`let` 則是區塊的作用域，`let` 的變數無法被加到全域物件，因此 `this.b` 是 `undefined`。\n","createdAt":"2025-08-16T08:43:46.081Z","updatedAt":"2025-08-16T10:25:15.190Z","publishedAt":"2025-08-16T10:25:15.192Z","locale":null,"author":null}}
{"type":"api::post.post","id":186,"data":{"documentId":"ckytvb2llrbgd5xlg0d8iwak","slug":"null-undefined-undeclared","title":"null, undefined 和 undeclared 的差異","date":"2025-08-16T08:43:54.557Z","description":"null, undefined 和 undeclared 的差異 null - 變數被宣告並且被指定爲有意義的空值 null，通常用來明確地表示「沒有值」或「空物件」的狀態。null 的型別是物件。 - 型別: null 的型別是物件。 - 使用場景：當你明確地想表示某個變數不應該有任何值時，可以將其設為 null。 undefined - 變數被宣告已經被宣告但是並沒有指派一個值，當 JavaScript 初始化變數或找不到某個物件的屬性時，會自動給它賦值為 undefined。 - 型別: undefined。","content":"\n# null, undefined 和 undeclared 的差異\n\n## `null`\n\n- 變數被宣告並且被指定爲有意義的空值 `null`，通常用來明確地表示「沒有值」或「空物件」的狀態。`null` 的型別是物件。\n- 型別: `null` 的型別是物件。\n- 使用場景：當你明確地想表示某個變數不應該有任何值時，可以將其設為 `null`。\n\n```js\nlet obj = null;\nconsole.log(typeof obj); // \"object\"\n```\n\n## `undefined`\n\n- 變數被宣告已經被宣告但是並沒有指派一個值，當 JavaScript 初始化變數或找不到某個物件的屬性時，會自動給它賦值為 `undefined`。\n- 型別: `undefined`。\n- 使用場景：當沒有給變數賦值，或者函數沒有返回值時，JavaScript 會自動給它 `undefined`。\n\n在鬆散的比較中， `null` == `undefined`，但在嚴格比較中 === 它們是不相等的。\n\n```js\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\n```\n\n```js\nlet x;\nconsole.log(x); // undefined\nconsole.log(typeof x); // \"undefined\"\n```\n\n## undeclared\n\n- undeclared 就是從未被宣告過的變數。如果在嚴格模式下嘗試使用未宣告的變數，會拋出 ReferenceError 錯誤。\n- 使用場景：undeclared 通常是由於變數使用前未宣告造成的錯誤，這在嚴格模式下尤其會被檢測出來。\n\n```js\n\"use strict\";\n\nx = 1; //會在嚴格模式下拋出 ReferenceError 錯誤，因為變數沒有被宣告\nconsole.log(x);\n```\n\n在非嚴格模式下，這種行為會自動在全域範圍創建變數，這可能導致意想不到的副作用。\n\n```\nx = 1; // 非嚴格模式下會隱式創建全域變數 x\nconsole.log(x); // 1\n\n```\n\n---\n\n## 實例練習 1\n\n[Type Utilities](https://www.greatfrontend.com/questions/javascript/type-utilities)\nIn this question, we will implement the following utility functions to determine the types of primitive values.\n\n- isBoolean(value): Return true if value is a boolean, false otherwise.\n- isNumber(value): Return true if value is a number, false otherwise. Note that NaN is considered a number.\n- isNull(value): Return true if value is null, false otherwise.\n- isString(value): Return true if value is a String, else false.\n- isSymbol(value): Return true if value is a Symbol primitive, else false.\n- isUndefined(value): Return true if value is undefined, else false.\n\n## 解題 1\n\n```js\nexport function isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n\nexport function isNumber(value) {\n  return typeof value === \"number\";\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isString(value) {\n  return typeof value === \"string\";\n}\n\nexport function isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\nexport function isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n```\n\n## 實例練習 2\n\n[9. null and undefined](https://bigfrontend.dev/quiz/null-and-undefined)\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(JSON.stringify([1, 2, null, 3]));\nconsole.log(JSON.stringify([1, 2, undefined, 3]));\nconsole.log(null === undefined);\nconsole.log(null == undefined);\nconsole.log(null == 0);\nconsole.log(null < 0);\nconsole.log(null > 0);\nconsole.log(null <= 0);\nconsole.log(null >= 0);\nconsole.log(undefined == 0);\nconsole.log(undefined < 0);\nconsole.log(undefined > 0);\nconsole.log(undefined <= 0);\nconsole.log(undefined >= 0);\n```\n\n## 解題 2\n\n```js\n// This is a JavaScript Quiz from BFE.dev\n\nconsole.log(JSON.stringify([1, 2, null, 3])); //\"[1,2,null,3]\"\nconsole.log(JSON.stringify([1, 2, undefined, 3])); //\"[1,2,null,3]\"，undefined 被轉換為 null，因為 JSON 不支持 undefined 作為有效值\nconsole.log(null === undefined); //false\nconsole.log(null == undefined); //true\nconsole.log(null == 0); //false\nconsole.log(null < 0); //false\nconsole.log(null > 0); //false\nconsole.log(null <= 0); //true，null 會被轉換為 0\nconsole.log(null >= 0); //true，null 會被轉換為 0\nconsole.log(undefined == 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined < 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined > 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined <= 0); //false，undefined 會被轉換為 NaN\nconsole.log(undefined >= 0); //false，undefined 會被轉換為 NaN\n```\n","createdAt":"2025-08-16T08:43:46.605Z","updatedAt":"2025-08-16T10:25:15.201Z","publishedAt":"2025-08-16T10:25:15.203Z","locale":null,"author":null}}
{"type":"api::post.post","id":188,"data":{"documentId":"n4tfyed6eyx968i9qhh4g4kj","slug":"2024-react-conf","title":"從 2024 React Conf 看 React Native 發展","date":"2025-08-16T08:43:54.020Z","description":"從 2024 React Conf 看 React Native 發展 今年的 React Conf 除了眾所矚目的 React 19 ，同時以 meta 開發團隊開發的 React Native 也帶來了不少亮點。有關於 React Native 的討論都集中在第二天的議程。 New Architecture 上 beta 了 截至 2024 年 3 月 React Native 的在 npm 上的每週下載數突破了220萬，越來越多的開發者使用;同時 React Native 開發團隊也宣布 New Architecture 終於上 beta 了，從 0.68 版本 2022 年 3 月在...","content":"\n# 從 2024 React Conf 看 React Native 發展\n\n今年的 React Conf 除了眾所矚目的 React 19 ，同時以 meta 開發團隊開發的 React Native 也帶來了不少亮點。有關於 React Native 的討論都集中在[第二天的議程](https://www.youtube.com/watch?v=0ckOUBiuxVY)。\n\n### New Architecture 上 beta 了\n\n截至 2024 年 3 月 React Native 的在 npm 上的每週下載數突破了220萬，越來越多的開發者使用;同時 React Native 開發團隊也宣布 New Architecture 終於上 beta 了，從 0.68 版本 2022 年 3 月在 React Native 加入了 New Architecture 到現在升級到 0.74 版本後使用 react-native-cli 可以分別在 Android 的 `gradle.properties` 啟用、iOS 則是在 iOS 的位置執行 `bundle install && RCT_NEW_ARCH_ENABLED=1 bundle exec pod install`、使用 Expo 則可以 Expo 51 的設定檔案分別開啟 iOS 跟 Android 是否支援 New Architecture。官方是建議大家可以先玩看看新架構，然後如果有遇到問題的話幫忙回報一下 issue。\n\n<!--truncate-->\n\n至於為什麼要改整個大改呢？這就要回歸到現在 React Native 的架構，目前的 Javascript 用 bridge 的方式和原生構通，透過 JSON 反序列化和序列化經由 bridge 來傳遞訊息，但使用 bridge 來溝通一次只能有一端通過，而且每傳遞一次就要用 JSON 反序列化和序列化來轉換資料，是相當耗費的效能的。\n\n那麼 New Architecture 是如何改善這個問題呢？主要使用 JavaScript Interface（簡稱 JSI ）讓 JavaScript 與原生進行溝通，JSI 是用 C++ 寫的，他使用 memory sharing 的方式讓 JavaScript 層與 native 層溝通，也可以讓 JavaScript 同步運行在 native 層，直接讓 JavaScript 程式碼呼叫原生程式碼的函數，更有效率地去直接溝通原生層。\n\n### 官方建議使用 React native framework - Expo\n\n這次官方也宣布他們改了 [React native 的官網](https://reactnative.dev/docs/environment-setup)，從 0.75 開始版本開始，直接建議開發者使用 Framework 來開發，例如：Expo，先針對先前對於 Expo 的原生支援度不足等原因而採用 react-native-cli 作為開發選項的痛點，Expo 這次更新了一些功能以提升開發者體驗：\n\n#### 原生的支援\n\n對於原生的支援 Expo 提供了\n\n- Expo sdk : 提供了一些原生的 api，例如：camera、location、notification...等\n  ![Expo sdk ](./expo-sdk.png)\n\n- Expo module api : 使用 Expo module api 可以寫自己原生 kotlin、swift 的 module 引入 React-Native 專案\n\n![Expo module api](./expo-module-api.png)\n\n#### expo router\n\n採取 file system-based routing 的設計，分別針對 iOS 跟 Android、web 、 tv OS 給出不同的 UX 設計。\n\n#### 管理原生程式碼\n\n使用 continuous native generation 管理原生程式碼\n![cng](./cng.png)\n\n整體看下來，如果 Expo 這些功能可以解決原生支援度不足、可以整合自己寫原生的引入專案、再加上整合 build 跟 deploy 的平台，整體的開發者體驗相較使用 react-native-cli 來的好很多，如果有用過 Xcode build ipa 檔案或 android command line build apk 檔案、aab 檔案就可以心領神會其中的痛苦～但是我覺得這背後有一個隱憂就是 Expo 是一間私人的公司，會不會當使用者累積到一個量後，使用 Expo 的服務就會新增一些要考量的開發成本？\n\n順道一提，React Conf 的 App 就是使用了 Expo 開發的，當然也有包含上方提及的新功能，都可以在 https://github.com/expo/react-conf-app 的 repo 中看到實際的應用。\n\n### 多元的開發應用\n\nReact native 除了可開發出支援 iOS 、 Android、 Mac OS 、Window 系統的應用程式，React 可以開發這麼多不同的系統，就是基於 react 可以在 Render 階段則是將 Reconciler 時定義好的描述結構轉換使用專屬的 Render 去轉成 Native 的元件。\n\n在這一次的 conf 中可以看到 React native 也可以開發出支援 Apple vision pro 的應用程式，又 Amazon 的工程師也分享了如何 React native 去開發支援 TV OS 系統應用程式的經驗。\n\n### React native 未來的發展\n\n最後 Meta 的 React native 開發團隊分享了未來十年 React native 的開發藍圖：提升 React native 與 Web 的相容性與一致性，確保在不同的平台都有相同開發的體驗，以降低學習曲線。例如：ˋflexboxˋ 這個屬性在 React native 的 styleSheet 跟 CSS 在 web 瀏覽器的應用有一些不同。\n\n![](./1.png)\n\n#### React Native core\n\n現行的 React Native 使用 React Native Core 將 React Element 轉換成原生的元素。\n\n![](./2.png)\n\n在 React Native core 中，Yoga 這個 layout 引擎負責計算 React Native layout 跟 styling 位置，後經過 React Native Runtime 後交由 React Native Renderer 去負責渲染各個平台的視圖，例如： Webview 、UI kit 、 Android ...等。\n\n#### React DOM\n\n![](./3.png)\n\nReact 則是使用 React DOM 將 React Element 繪製成瀏覽器實際 DOM 元素。\n\n#### React strict DOM\n\n![React strict DOM](./4.png)\n\n為了要提升 React code sharing 以整合 codebase 在 UI 上支援 web 瀏覽器和 VR 介面...等，React strict DOM 就是基於這個目的而開發的，它可以整合 React Native 和 React ，讓 web api 也可以在 React Native 中使用。\n\n例如：\n\n##### Unified Styling\n\n```jsx\nimport { css } from \"react-strict-dom\";\nconst styles = css.create({\n  container: { borderTopWidth: 1 },\n  h1: {\n    padding: 10,\n    backgroundColor: \"#EEE\",\n  },\n  content: {\n    padding: 10,\n  },\n  div: {\n    paddingTop: 50,\n    backgroundColor: \"#000\",\n  },\n});\n```\n\n可以把 web css api 支援到 React Native ，像是偽元素、 media query。\n\n##### Unified markup\n\n```jsx\nimport { html } from \"react-strict-dom\";\n<html.div style={style.container}>\n  <html.h1 style={style.h1}>{title}</html.h1>\n  <html.div style={style.content}>{children}</html.div>\n</html.div>;\n```\n\n可以在 React Native 中去使用 HTML 開發 web 。\n\n![](https://user-images.githubusercontent.com/239676/205388313-e58f8793-51cd-4a6e-86e7-89425fd2d0e1.png)\n\n#### 結論\n\nReact strict DOM 最終的目的是讓 codebase 整合成一個，但是共享整個 codebase 跨平台並非主要的目標，應該是合理的去共享這些 code，這樣才可以花更多時間在處理各個平台的不同 UI 細節，而未來新的 web 功能將隨著時間的推移發佈到 React Native ，以提升 web 的相容性。\n\n目前使用 React 開發 web 跟使用 React Native 開發 app 的體驗是截然不同的，在樣式方面 web 使用 css api、React Native 則是使用 styleSheet；同樣是寫 JSX 的標籤 react 不需要引用、React Native 則是需要從 React Native module 引入 component ，再加上其實有很多支援瀏覽器的屬性現階段在 React Native 是不支援的。\n\n透過 React strict DOM 的開發可以看見開發團隊欲將 React 的生態系整合的決心，如果真的可以將 web 的 api 都可以整合到 React Native 中，那麼就可以真正的實踐 Learn once, write anywhere. ，目前看起來整合的複雜度很高、要解決的問題也不少，還需要一段時間等待。\n\n有關於 React strict DOM 的討論可以參考這個 [RFC: React DOM for Native (reduce API fragmentation) ]https://github.com/react-native-community/discussions-and-proposals/pull/496\n","createdAt":"2025-08-16T08:43:45.570Z","updatedAt":"2025-08-16T10:25:15.225Z","publishedAt":"2025-08-16T10:25:15.227Z","locale":null,"author":null}}
{"type":"api::post.post","id":190,"data":{"documentId":"jzv0a8xos3p4x49azm7ghxvt","slug":"2024-web-conf","title":"Web Conf 2024 心得與回顧","date":"2025-08-16T08:43:54.083Z","description":" 第二次 參加 Web Conf ，這次的議程一樣精彩豐富，甚至有幾個議程同時排在一起讓我一時難以抉擇。兩天的聽完的心得大致上是覺得有些收穫的，對於技術迭代的知識焦慮倒是還好，因為平常就有在看這些東西，所以這次議程有些內容對我來說也算是複習，當然也還是有得到一些新的知識與觀點。 回顧 以下就我有聽的議程且較有印象的內容做一個回顧： !2024 WebConf 1. 有限狀態機與 RxJS - 奶綠茶 有限狀態機與 RxJS 這兩個題目剛好我都不熟。","content":"\nimport { HTMLPreview } from \"../../src/components/mdx/index.js\";\n\n![2024 WebConf](./360855.jpg)\n\n## 2024 WebConf\n\n第二次 參加 Web Conf ，這次的議程一樣精彩豐富，甚至有幾個議程同時排在一起讓我一時難以抉擇。兩天的聽完的心得大致上是覺得有些收穫的，對於技術迭代的知識焦慮倒是還好，因為平常就有在看這些東西，所以這次議程有些內容對我來說也算是複習，當然也還是有得到一些新的知識與觀點。\n\n<!--truncate-->\n\n![](./360858.jpg)\n\n## 回顧\n\n以下就我有聽的議程且較有印象的內容做一個回顧：\n\n![2024 WebConf](./360856.jpg)\n\n### 1. 有限狀態機與 RxJS - 奶綠茶\n\n有限狀態機與 RxJS 這兩個題目剛好我都不熟。\n在前端的開發中很常會需要實作狀態的管理，在這個議程中講者用紅綠燈的案例很清楚的說明了什麼是有限狀態機。\n\n有限狀態機（Finite State Machine, FSM）包括以下幾個特色：\n\n- 同一時間點，只會出存在一種狀態\n- 有限數量的狀態 state\n- 有限數量的事件 event 一定在時間內轉換到下一個狀態\n- 一個 initial state\n- 一個轉換的函式，傳入當下事件跟狀態去轉換狀態\n- n 個 final state\n\n就紅綠燈來說基本上同時間只會有一個狀態，綠、黃、紅，而且燈號的轉換事件數量是有限的且有規則可循的。\n\n使用有限狀態機的目的就是用來收斂需求的規格，讓狀態結構更加清晰，提升可維護性，而且使用現成的有限狀態機 library [xstate](https://github.com/statelyai/xstate)可以讓狀態圖易於視覺化，有助於工程師與設計師理解整個邏輯流程。\n\n[RxJS](https://rxjs.dev/) 則是一個基於 functional programming 精神設計的 library，透過 Observable 來處理複雜的非同步事件流，可以將多個運算符組合再一起，讓程式碼更加簡潔，也更容易閱讀。\n\n適合用來實作拖拉的功能，例如：拖拉的過程中會有 mousemove 事件，這個事件會不斷觸發，透過 RxJS 可以很容易的處理這個事件流，並且可以透過運算符來過濾掉不必要的事件。\n\n稍微看了一下 RxJS 文件，看起來要使用需要花一點時間學習，感覺有點複雜。對了，除了技術上的知識，講者有提到建議大家去閱讀熱門開源專案的程式碼。\n\n### 2. 個人專案到產品：善用 AI 工具打造可盈利產品 - 王鵬傑 PJ Wang\n\n這場是 Explian this 的作者，我很常閱讀他們家的文章，甚至曾有想付費訂閱，但是覺得要讀的東西太多，感覺負荷不了就作罷。講者分享他們怎麼去選擇 side project 的題目，還有打造產品的流程與思路。\n\n[product hunt](https://www.producthunt.com/) 是個適合參考選題的地方。\n\n雖然我沒有要做 side project 的打算，但是整場我必須說最有共鳴的應該是寫 side project 還是要找價值觀跟個性接近的同伴一起，當然不只是寫 side project ，很多時候都是。\n\n### 3. 如何撰寫具彈性的測試程式 - Summer\n\n[如何撰寫具彈性的測試程式逐字稿](https://www.cythilya.tw/2024/12/27/webconf2024-ui-causes-testing-to-fail/)\n\n這場內容本身很棒，但是這些內容已經有在他的書裡面寫過，我也剛好讀過了...。\n\n### 4. 十年回首：React 的過去、現在與未來發展 - Zet\n\n[簡報](https://slides.com/tz5514/react-webconf2024)\n\n這場我覺得有點可惜的是前面講者花了太多時間在描述 React 的渲染策略，這些他的書裡面都有，我也讀過了:[《React 思維進化》讀書筆記](https://wintersprouter.github.io/frontend-notes/docs/category/react-%E6%80%9D%E7%B6%AD%E9%80%B2%E5%8C%96%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98)\n。\n\n最有收穫的部分是 React Fiber 底層架構，由於多任務處理能力的需求增加：CPU、data data fetch，在改成 React Fiber 之前，React component 在 render 階段會產生的一個遞迴 stack 的 virtual dom tree，這個過程是不可中斷的，又 Javascript 是單執行緒的，所以當 React component 在 render 階段遇到一個很大的 component 就會佔用瀏覽器的 main thread，這樣就會造成瀏覽器的畫面卡住。\n\n在有了 React Fiber 之後，React component 在 render 階段改成使用 Linked list 代替一般的樹狀結構的儲存畫面結構，而且可以透過 scheduler 機制去調度產生畫面的流程。\n\n至於 Server Components 的部分，因為一直沒有機會實作，所以對於這個部分的內容還是有點模糊，這就留到以後有時間再來研究吧。\n\n後面談到了一些今年發表的 React 19 和 React Compiler 的部分，剛好今年 react conf 我剛好有看完，所以焦慮感沒那麼重 ＸＤ ，react conf 的內容很精彩關於新的特性講了非常多細節，這邊就不多贅述了。\n\n### 5. 《天下》如何思考數位敘事？從流程到技術大公開 - 李郁欣／楊時鈞 Steven Yeo\n\n這場主要是分享天下雜誌他們家的前端怎麼應用 blender 3d 建模將圖資結合新聞敘述打造一篇數位的專題報導，他們的專題報導是真的蠻炫砲的，完全是跟我不同的前端領域，聽完我就在想這樣的產生一篇新聞的成本好重，可是敘事的手法真的很不錯。\n\n當然除了技術上覺得佩服，還有一個是我覺得厲害的地方，就是需要跟中央的研究單位專家索取適合應用在 3D 建模的資料，那中間的溝通真的很難，通常外部的人不太懂前端技術上需要的資料結構，還必續要花時間去解釋。\n\n### 6. 從商業策略出發的產品、服務體驗設計：以 USPACE 產品為例 - 郭丞哲 Doppler kuo\n\n這家做的產品跟我現在做的很雷同，聽完覺得果然痛點都差不多，但某些想法是可以參考的。\n\n### 7. AI+商業思維：軟體工程師如何擁抱趨勢，提升職場價值 - 游舒帆\n\n[AI+商業思維：軟體工程師如何擁抱趨勢，提升職場價值](https://gipi.tw/webconf-2024-ai-and-business-thinking/?fbclid=PAZXh0bgNhZW0CMTEAAaY5PcBALpCOpZD5RzIadmhqLa7Kf_7frPdLOImYHiSh5HZhTYYRSgtnJo4_aem_Fc3cQo6Us5KC8MXHxoa5Lw)\n\n比較軟一點的職涯分享內容，講的蠻好的，讓人重新思考在自己職涯與市場的定位，雖然這些內容我好像在以前在曼陀號聽過。\n\n### 8. 擁抱漸進式體驗 — 設計驅動企業改革動能 - 郭藺瑩 Lydia Kuo\n\n很精彩的一場，無論是敘事或是簡報設計都是很舒服的一場，前面開頭分享了很多小故事很吸引人，透過這些故事讓人了解到只有實際走入使用者的生活，才能夠設計出動人人心的產品。接著是我覺得最有幫助的是改版專案，專案改版其實是實務上很常見的狀況，講者以改版 Yahoo! 股市 APP 為例，分享他們團隊進行 APP 改版的思路。\n\n![擁抱漸進式體驗 — 設計驅動企業改革動能 ](./1.png)\n\n透過前期的使用者訪談研究，先盤點出 APP 功能對使用者重要性的順序，接著從中度使用頻率的功能而且影響營收的功能進行改版，除了讓使用者可以漸漸接受改版，進而藉由改版後的營收彰顯改版的成效，讓專案可以獲得穩定的投資與支持，才有資源接著下一階段的改版，畢竟能活下去是才是最重要的。\n\n另外一個有收穫的地方是，講者提到一個可以幫助設計師與前端工程師提升開發效率的工具，就是使用 figma 的 Global token，讓設計的 UI 可以被清楚的定義好規格，再加上 [style-dictionary](https://github.com/amzn/style-dictionary?tab=readme-ov-file#installation) 可以把定義好的 JSON 規格檔案轉換成相對應的 CSS、SCSS、或者 Android 、IOS程式碼，這樣就可以讓設計師與前端工程師之間的溝通更加順暢，也可以節省掉前期定義設計規格的時間，更重要的是，當設計需要改版時只要調整前面的定義規格檔案，就可以自動更新到所有的程式碼，節省了很多時間，讓工程師與設計師可以更專注於開發與設計上。\n\n### 9. ESLint One for All Made Easy - Anthony Fu\n\n[ESLint One for All Made Easy 簡報](https://talks.antfu.me/2024/webconf-tw/1)\n他的簡報超酷，除了簡報內容本身，還有為簡報講解開發的功能。\n\nEslint Flat Config 是 eslint 9.0.0 版本重大的改版，在聽到這場之前我已經花了一些時間把目前維護的專案的 eslint 遷移到 Flat Config，所以對我來說還算是不陌生，但是在聽完這場後有發現更多可以玩的東西。\n\n![Eslint Flat Config](./2.png)\n\nFlat Config 相較傳統的設定檔好處在於扁平化的設定大大的提升靈活性與可以擴展化的彈性，讓多個專案可以共享同一份設定檔，覆蓋所有不同類型的專案。\n\n![Eslint Flat Config](./3.png)\n後面講者介紹了一些 library 、還有一些 eslint 9.0.0 的功能。\n\n![Eslint Flat Config](./4.png)\nESLint Config Inspector 這個工具超酷，可以幫你把目前專案的 eslint 設定檔轉換成可視化的開發工具，檢視目前專案哪些檔案應用了哪些規則，哪些規則已經被棄用。\n\n#### eslint 應用多樣性\n\n1. linter\n2. 遷移工具： [eslint-plugin-command](https://github.com/antfu/eslint-plugin-command)\n3. 格式化工具: [ESLint Stylistic](https://eslint.style/)\n4. 多種語言的 linter\n\n### 10. Flex out！ CSS Grid 玩起來！ - 李建杭 Amos\n\n[簡報下載](https://drive.google.com/file/d/1ZgN-oDsIazHd3kYt-bPWM1tOap7VGBLF/view)\n\nGrid 其實對我來說不陌生，有時候用 Grid 排版超好用，當然還是有一些我不知道 CSS 技巧，以下就講者的提供範例做一個回顧：\n\n[範例程式碼](https://drive.google.com/file/d/1aaH7wncnXp1ydu-C_V9_ez19oPG_j08D/view)\n\n#### 使用 details 製作純 CSS 手風琴式版面\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>keywords auto height transition - by Amos</title>\n    <style>\n      :root {\n        interpolate-size: allow-keywords;\n      }\n      .accordion-item {\n        margin: 30px;\n        border: 1px solid #aaa;\n      }\n      .accordion-item .detail-title {\n        background-color: #ccc;\n        padding: 10px;\n      }\n      .accordion-item .detail-title::marker {\n        content: \"\";\n      }\n      .accordion-item .detail-content {\n        padding: 10px;\n      }\n      /* Animation */\n\n      /* 選擇所有具有 accordion-item 類別的元素內的 details-content 偽元素。 */\n      .accordion-item::details-content {\n        /* 設定 height 和 content-visibility 屬性的過渡效果，持續時間為 0.5 秒，使用 ease 過渡效果。 */\n        transition:\n          height 0.5s ease,\n          content-visibility 0.5s ease allow-discrete;\n        height: 0;\n        /* 內容超出範圍時裁剪。 */\n        overflow: clip;\n        /* 強制內容可見。 */\n        content-visibility: visible !important;\n      }\n      /* 選擇所有具有 accordion-item 類別且有 open 屬性的元素內的 details-content 偽元素。 */\n      .accordion-item[open]::details-content {\n        /* details-content 偽元素的高度設為 auto，並使用 calc-size(auto) 來計算自動高度。 */\n        height: auto;\n        height: calc-size(auto);\n      }\n      /* 這樣當 accordion-item 被打開時，details-content 的高度會從 0 過渡到自動計算的高度，實現手風琴效果的展開動畫。 */\n    </style>\n  </head>\n  <body>\n    <h1>使用 details 製作純 CSS 手風琴式版面</h1>\n\n    <div class=\"accordion\">\n      <details class=\"accordion-item\" name=\"item\">\n        <summary class=\"detail-title\">Q : 金魚都能懂什麼？</summary>\n        <div class=\"detail-content\">\n          <p>\n            「金魚都能懂」的教學系列是由 Amos\n            創立，目的是為了讓大家在學習過程可以更加輕鬆自在且愉快...\n          </p>\n        </div>\n      </details>\n      <details class=\"accordion-item\" name=\"item\">\n        <summary class=\"detail-title\">Q : 這段秀什麼？</summary>\n        <div class=\"detail-content\">\n          <p>\n            這段展現「不」使用 grid 也能夠實現不確定容器高度時的動畫轉換效果\n          </p>\n          <p>\n            使用 HTML Details 和 interpolate-size: allow-keywords; 實現 height\n            auto。\n          </p>\n        </div>\n      </details>\n      <details class=\"accordion-item\" name=\"item\">\n        <summary class=\"detail-title\">\n          Q : 實現自動高度動畫真的不難，對吧\n        </summary>\n        <div class=\"detail-content\">\n          <p>來個長假文吧</p>\n          <p>\n            我個人認為義大利麵就應該拌42號混泥土，因為這個螺絲釘\n            的長度很容易直接影響到挖掘機的扭矩。你往裡砸的時候，一瞬間它就會產生大量\n            的高能蛋白，俗稱UFO，會嚴重影響經濟的發展，以至於對整個太平洋，和充電器的核污\n            染。再或者說透過這勾股定理很容易推斷出人工飼養的東條英雞，他是可以捕獲野生\n            的三角函數，所以說不管這秦始皇的切面是否具有放射性，川普的N次方是否有沈澱物，\n            都不會影響到沃爾瑪跟維爾康在南極匯合。\n          </p>\n        </div>\n      </details>\n    </div>\n  </body>\n</html>\n```\n\n<HTMLPreview\nshowCode={false}\n\ncode={`     <h1>使用 details 製作純 CSS 手風琴式版面</h1>\n    <div class=\"accordion\">\n        <details class=\"accordion-item\" name=\"item\">\n            <summary class=\"detail-title\">Q : 金魚都能懂什麼？</summary>\n            <div class=\"detail-content\">\n                <p>「金魚都能懂」的教學系列是由 Amos 創立，目的是為了讓大家在學習過程可以更加輕鬆自在且愉快...</p>\n            </div>\n        </details>\n        <details class=\"accordion-item\" name=\"item\">\n            <summary class=\"detail-title\">Q : 這段秀什麼？</summary>\n            <div class=\"detail-content\">\n                <p>這段展現「不」使用 grid 也能夠實現不確定容器高度時的動畫轉換效果</p>\n                <p>使用 HTML Details 和 interpolate-size: allow-keywords; 實現 height auto。</p>\n            </div>\n        </details>\n        <details class=\"accordion-item\" name=\"item\">\n            <summary class=\"detail-title\">Q : 實現自動高度動畫真的不難，對吧</summary>\n            <div class=\"detail-content\">\n                <p>來個長假文吧</p>\n                <p>我個人認為義大利麵就應該拌42號混泥土，因為這個螺絲釘 的長度很容易直接影響到挖掘機的扭矩。你往裡砸的時候，一瞬間它就會產生大量 的高能蛋白，俗稱UFO，會嚴重影響經濟的發展，以至於對整個太平洋，和充電器的核污 染。再或者說透過這勾股定理很容易推斷出人工飼養的東條英雞，他是可以捕獲野生 的三角函數，所以說不管這秦始皇的切面是否具有放射性，川普的N次方是否有沈澱物， 都不會影響到沃爾瑪跟維爾康在南極匯合。</p>\n            </div>\n        </details>\n    </div>\n  `}\n\nstyle={ `\n        :root{\n            interpolate-size: allow-keywords;\n        }\n        .accordion-item {\n            margin: 30px;\n            border: 1px solid #aaa;\n        }\n        .accordion-item .detail-title {\n            background-color: #ccc;\n            padding: 10px;\n        }\n        .accordion-item .detail-title::marker {\n            content: '';\n        }\n        .accordion-item .detail-content {\n            padding: 10px;\n        }\n        /* Animation */\n        .accordion-item::details-content {\n            transition: height 0.5s ease, content-visibility 0.5s ease allow-discrete;\n            height: 0;\n            overflow: clip;\n            content-visibility: visible!important;\n        }\n        .accordion-item[open]::details-content {\n            height: auto;\n            height: calc-size(auto);\n        }` }\nheight=\"300px\"\n/>\n\n##### [interpolate-size](https://developer.mozilla.org/en-US/docs/Web/CSS/interpolate-size)\n\n```css\n:root {\n  interpolate-size: allow-keywords;\n}\n```\n\n是一個 實驗性 CSS 屬性，它允許在 length-percentage（例如具體數值如 50% 或 200px）和內在尺寸值（例如 auto、fit-content 或 max-content）之間進行動畫或過渡（interpolation）。\n\nallow-keywords：\n開啟 length-percentage 和內在尺寸值（例如 auto）之間的插值動畫。\n適用於動畫場景，例如容器在「折疊（closed）」和「展開（open）」狀態之間平滑過渡。\n\n##### [details](https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/details)\n\ndetails 元素，可以用來包裹一段內容，並且可以透過 summary 元素來控制內容的顯示與隱藏。\n\n#### 使用 ch 代替 em 讓尺寸控制更精確\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>CSS Grid table - by Amos</title>\n    <style>\n      .table {\n        display: grid;\n        /* 第一列的寬度為 calc(3em + 9ch)，即 3 個字母寬度加上 9 個字符寬度。\n接下來的兩列寬度為 1fr，即各佔剩餘空間的 1 份。*/\n        grid-template-columns: calc(3em + 9ch) repeat(2, 1fr);\n        /* grid-template-columns: 12em repeat(2, 1fr); */\n        gap: 2px;\n      }\n      .row {\n        display: grid;\n        /* 使用 subgrid 來繼承父網格容器（即 .table）的列定義。*/\n        grid-template-columns: subgrid;\n        grid-column: 1/-1;\n      }\n      .col {\n        border: 1px solid #aaa;\n        /* 設定內邊距為上下 1ex（字體高度的 x 高度），左右 1em（字母寬度）。*/\n        padding: 1ex 1em;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>使用 ch 代替 em 讓尺寸控制更精確</h1>\n    <div class=\"table\">\n      <div class=\"row\">\n        <div class=\"col\">A123456789</div>\n        <div class=\"col\">Amos</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">K123456789</div>\n        <div class=\"col\">Alvee</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">G123456789</div>\n        <div class=\"col\">Ray</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">M123456789</div>\n        <div class=\"col\">Eason</div>\n        <div class=\"col\">sample@gmail.com</div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\n<HTMLPreview\nshowCode={false}\ncode={`\n\n    <h1>使用 ch 代替 em 讓尺寸控制更精確</h1>\n\n    <div class=\"table\">\n        <div class=\"row\">\n            <div class=\"col\">A123456789</div>\n            <div class=\"col\">Amos</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col\">K123456789</div>\n            <div class=\"col\">Alvee</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col\">G123456789</div>\n            <div class=\"col\">Ray</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n        <div class=\"row\">\n            <div class=\"col\">M123456789</div>\n            <div class=\"col\">Eason</div>\n            <div class=\"col\">sample@gmail.com</div>\n        </div>\n    </div>\n\n`}\n    style={\n    ` .table {\ndisplay: grid;\ngrid-template-columns: calc(3em + 9ch) repeat(2, 1fr);\ngap: 2px;\n}\n.row {\ndisplay: grid;\ngrid-template-columns: subgrid;\ngrid-column: 1/-1;\n}\n.col {\nborder: 1px solid #aaa;\npadding: 1ex 1em;\n}` }\nheight=\"300px\"\n/>\n\n##### em\n\n是相對於父元素的字體大小，英文字母最寬的寬度。\n\n##### ex\n\n是一種相對單位，表示相對於當前元素字體中小寫字母 \"x\" 的高度（也稱為 \"x-height\"）。（字體高度的 x 高度）。\n\n##### ch\n\n是一種相對長度單位，用於表示與字體中數字 \"0\" 的寬度相關的尺寸。這個單位主要用於設計需要字寬基準的布局，例如表格、輸入框或排版。\n\n#### color-mix 函式 - by Amos\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>color-mix 函式 - by Amos</title>\n    <style>\n      :root {\n        --btn-bg: #fa0;\n        --btn-hover-bg: #fff;\n      }\n      html,\n      body {\n        height: 100%;\n        place-content: center;\n        text-align: center;\n      }\n      .btn {\n        display: inline-block;\n        padding: 1ex 3em;\n        background-color: var(--btn-bg);\n        color: #fff;\n        font-size: 22px;\n        margin: 6px;\n        border: none;\n      }\n      .btn:nth-child(1):hover {\n        background-color: color-mix(\n          in srgb,\n          var(--btn-bg),\n          var(--btn-hover-bg) 20%\n        );\n      }\n      .btn:nth-child(2):hover {\n        background-color: color-mix(\n          in srgb,\n          var(--btn-bg),\n          var(--btn-hover-bg) 50%\n        );\n      }\n      .btn:nth-child(3):hover {\n        background-color: color-mix(\n          in srgb,\n          var(--btn-bg),\n          var(--btn-hover-bg) 80%\n        );\n      }\n    </style>\n  </head>\n  <body>\n    <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n  </body>\n</html>\n```\n\n<HTMLPreview\nshowCode={false}\n\ncode={`     <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n    <button class=\"btn\">按鈕色彩控制</button>\n  `}\n\nstyle={ `:root {\n            --btn-bg: #fa0;\n            --btn-hover-bg: #fff;\n        }\n        html,body{\n            height: 100%;\n            place-content: center;\n            text-align: center;\n        }\n        .btn {\n            display: inline-block;\n            padding: 1ex 3em;\n            background-color: var(--btn-bg);\n            color: #fff;\n            font-size: 22px;\n            margin: 6px;\n            border: none;\n        }\n        .btn:nth-child(1):hover {\n            background-color: color-mix(in srgb, var(--btn-bg), var(--btn-hover-bg) 20%);\n        }\n        .btn:nth-child(2):hover {\n            background-color: color-mix(in srgb, var(--btn-bg), var(--btn-hover-bg) 50%);\n        }\n        .btn:nth-child(3):hover {\n            background-color: color-mix(in srgb, var(--btn-bg), var(--btn-hover-bg) 80%);\n        }` }\nheight=\"300px\"\n/>\n\n##### [color-mix](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color-mix)\n\n用於混合兩種顏色，根據指定的比例生成一種新的顏色。這個函式對於設計需要漸變、對比或平滑過渡效果的場景非常有用。\n\n### 11. 當 Vue 與 View 分手之後⋯ - Kuro Hsu\n\n講者在這場介紹了 Vue 的一個實驗性的功能: **Vue Vapor Mode**\n\n現行的 Vue 更新渲染策略是生成 Virtual Dom ，可以避免開發者直接去修改 DOM element，但是這樣同時也產生一些缺點，產生 Virtual Dom 會影響記憶體與執行的效率，也會增加了打包後的大小，在大型的專案特別明顯。\n\n![Vue Vapor Mode](./6.png)\n\nVue Vapor Mode 是可以讓 Vue 不用生成 Virtual Dom，而是直接使用 DOM API 去更新畫面，如此一來可以讓 Vue 更快更輕量。\n\n- Vue Vapor Mode 實作 template 模板\n\n[vuejs/vue-vapor 原始碼](https://github.com/vuejs/vue-vapor/blob/db140a1e37f89590e52d788a8d12308f53c7f3f1/packages/runtime-vapor/src/dom/template.ts)\n\n```js\n/*! #__NO_SIDE_EFFECTS__ */\nexport function template(html: string) {\n  let node: ChildNode\n  const create = () => {\n    // eslint-disable-next-line no-restricted-globals\n    //highlight-next-line\n    const t = document.createElement('template')\n    //這裡可以看到 Template 是一個使用 DOM API document.createElement('template') 的實例\n    t.innerHTML = html\n    return t.content.firstChild!\n  }\n  return () => (node || (node = create())).cloneNode(true)\n}\n```\n\n- Vue Vapor Mode 實作 \\_setText 和 \\_setHtml\n\n[vuejs/vue-vapor 原始碼](https://github.com/vuejs/vue-vapor/blob/db140a1e37f89590e52d788a8d12308f53c7f3f1/packages/runtime-vapor/src/dom/prop.ts#L188)\n\n簡單來說就是透過檢查舊的 DOM 節點的值，如果新的值和舊的值不同，就更新 DOM 節點的值。\n\n```js\nexport function setText(el: Node, ...values: any[]) {\n  const text = values.map(v => toDisplayString(v)).join('')\n  //舊的 textContent 值 oldVal\n  const oldVal = recordPropMetadata(el, 'textContent', text)\n  if (text !== oldVal) {\n    //更新 el.textContent 為新的 text 值\n    el.textContent = text\n  }\n}\n\nexport function setHtml(el: Element, value: any) {\n  //舊的 innerHTML 值 oldVal\n  const oldVal = recordPropMetadata(el, 'innerHTML', value)\n  if (value !== oldVal) {\n    el.innerHTML = value\n  }\n}\n```\n\n![Vue Vapor Mode](./5.png)\n\nVue Vapor Mode 的實作是基於 @vue/reactivity ，@vue/reactivity 則是由 vue 將其響應式系統抽出來變成獨立套件，即使沒有安裝 Vue 也可以使用響應式的api，甚至可以在後端處理 websocket 事件的狀態管理，更支援深層物件結構。\n\n響應式系統核心在於首次使用 effect 函式時會去自動追蹤內部所有響應式狀態，狀態被修改時，更新並且執行 side effect 並且移除 render()。\n\n至於無 virtual dom 的會不會是前端的趨勢?我個人覺得除非 React 使用量被 Vue 超越很多或哪天 react 放棄了 react native，不然 virtual dom 對於 react 來說是很重要的，畢竟 react 同時要支援多個跨平台 ex: android、ios、web，而 virtual dom 連接跨平台原生元件的重要橋樑。\n\n不過說真的如果 Vue 的 Vapor Mode 真的上線之後，看起來效能會比 React 好很多。\n","createdAt":"2025-08-16T08:43:45.669Z","updatedAt":"2025-08-16T10:26:08.868Z","publishedAt":"2025-08-16T10:26:08.874Z","locale":null,"author":null}}
{"type":"api::post.post","id":191,"data":{"documentId":"um9uhccsuzjp2vws27hnpw2i","slug":"2023-web-conf","title":"Web Conf 2023 心得與收穫","date":"2025-08-16T08:43:53.949Z","description":" 一直以來沒有參加過這種大型付費的 conference，又聽說這是睽違十年後再次舉辦 的 webConf ，所以就算現在幾乎都在開發 APP 還是想來看看，畢竟 Web 領域是我剛轉職時主要學的。況且學習前端技術的過程中，讀過不少這次議程講者的書籍或文章，甚至是課程，參加這個活動某種程度上是偶像見面會的概念（？另外，就是想透過這次的 conf 知道現在外面主流開發的方式與技術是什麼？","content":"\n---\n\n![2023 Web Conf](./20230811_131223.jpg)\n\n## 參加的動機\n\n一直以來沒有參加過這種大型付費的 conference，又聽說這是睽違十年後再次舉辦 的 webConf ，所以就算現在幾乎都在開發 APP 還是想來看看，畢竟 Web 領域是我剛轉職時主要學的。況且學習前端技術的過程中，讀過不少這次議程講者的書籍或文章，甚至是課程，參加這個活動某種程度上是偶像見面會的概念（？另外，就是想透過這次的 conf 知道現在外面主流開發的方式與技術是什麼？\n\n<!--truncate-->\n\n![2023 Web Conf](./20230811_084509.jpg)\n\n![](./20230813_162936.jpg)\n\n<small>\n  剛好之前買過的書都有擔任這次活動的講者，另外 PJ 、Summer\n  的文章在我學習前端的過程中也幫助我不少\n</small>\n\n---\n\n## 會後的感受\n\n_可以說是既興奮又焦慮，但焦慮的部分多了一些。_\n\n得到了很多新的觀點跟技術，以及開發想法的啟發，這些都讓我感到很興奮，前端的講者都很有料！3400 元值回票價！但同時又覺得憂慮，這兩天議程下來得到技術和工具超多，越知道更多的新知識，越覺得自己對這個領域的認知好渺小（能力也是，一時之間不知道可不可以吸收完這些大神的精華？AI 目前在程式開發的應用，所增進的開發體驗有限，但未來的發展可以說是指日可待，會不會哪一天就不需要工程師了？哇～原來別的開發團隊原來都是利用這些 CICD工具去提升開發的效率，增進團隊溝通，為啥自己待的開發團隊什麼都沒做？\n\n---\n\n## 收穫\n\n### 前端工程師的不同樣貌\n\n雖然職稱都掛著前端工程師，但每一個前端工程師所著重的技術都不太一樣，在這次議程的主講者中，有的就是著重於網頁互動設計、WebGL、動態特效 ; 有的著重於 Frontend Infra 前端基礎建設，也就是前端架構師 ; 有的則是網頁產品開發 ; 我自己也算是個蠻異類的前端，主要的技能樹都點在 React Native APP 跨平台開發。\n\n### 開發者體驗(Dev Experience)的重要性\n\n兩天的議程下來，不同的講者分別都強調了開發者體驗的重要性，很多時候我們在開發產品時很重視使用者體驗(User Experience)，往往忽略了開發者體驗(Dev Experience) ，然而開發者體驗可以帶給開發團隊的好處是提升開發效率和產品產量，當然也可以減少重複造輪子。在 Kyle 和 PJ 的分享中分享了不少關於如何在產品開發的過程中加入工具去提升團隊開發的品質，例如：CI/CD pipeline 優化的工具、利用透過 Script 或 Hooks 去自動化團隊專案的 Coding Style 讓機器人去擋下不符合規範的提交，也可以減少直接對人糾正的尷尬。在 Summer 的分享中則是怎麼樣去衡量網頁效能，並且利用 Sentry 去追蹤與記錄問題、觀察使用者的操作情況，進而打造一個自動化的效能系統，提升產品的穩定度。（以上的內容都很精彩，詳細的分享文章我整理在下方。）\n\n不過，要如何去應用這些工具和制定流程，主要還是要看開發團隊的文化和業務情況，依照不同的情境導入相對合適的工具，才會對整體開發體驗產生良好的影響，否則就失去了提升開發效率的美意了。\n我也要好好的去思考有哪些工具可以放入我的專案中了～\n\n### 前端技術迭代速度好快，快到學不動了\n\n剛轉職時有寫過一段時間的 Vue2 + Vuex ，後來都在寫 React 就快把 Vue 忘光了，趁著這次 Kuro 分享 Vue.js 的狀態管理模式，稍微的快速複習了 Vue ，發現 Vue 3 的 compostion api 在處理狀態和重用邏輯的部分與 React 的 hook 相似，看起來貌似比 Vue2 好寫多了。在狀態管理的部分以前用 Vuex 處理全域狀態都要透過從 Vuex 的 store state 拿出存放資料拿出來至vue compomnent => 若有非同步處理則還需要從 compomnent 更新觸發 Action =>Action 函數中調用 commit 方法來觸發 Mutations=> 更新 Vuex 中的狀態，一連串的要更新一個狀態需要很多繁瑣的步驟，反之，在 Vue 3 官文文件中直接將全域的狀態更新工具改成了 Pinia ，語法操作更簡單，取消了 mutation，跟 TypeScript 整合度更好。真是感嘆前端技術迭代太快了～沒想到不到兩年的時間又有更新更好用的東西，也不知道多久後又會有新的技術出來取而代之呢？\n\n剛好聽到幾個講者在講十年前專精於 Flash 的技術（老實說我是第一次聽到，原來十年前的前端是要點的技能是這個），但現在的瀏覽器的都不支援了，就更有感。或許，身為開發者都要有這樣的覺悟：這一行本來就是沒辦法只學某幾種技術就能一輩子以此為生，也不是說舊的技術不好，一定會有公司需要人維護（除非就像 flash 死透了），但如果能 open mind 去學習新的技術，在職涯的路上選擇會比較寬闊。\n\n### 原生 HTML element + Web api + CSS 就很好用\n\n做表單 Form 一直是我覺得前端處理很麻煩的部分，又要透過 DOM 取值做資料驗證，又要顧及使用者體驗。Paul 在分享中，展示了許多用 HTML 原生 element 、CSS 、web api 的就可以處理的功能。例如：\n\n- [CSS: accent-color](https://developer.mozilla.org/en-US/docs/Web/CSS/accent-color) 可以直接改某些 HTML element 的顏色\n\n```html title=\"HTML\"\n<input type=\"checkbox\" />\n<input type=\"range\" />\n<progress></progress>\n```\n\n- form 驗證可以使用[ValidityState web api](https://developer.mozilla.org/en-US/docs/Web/API/ValidityState)處理\n\n- [CSS > :has()](https://developer.mozilla.org/en-US/docs/Web/CSS/:has)可以判斷是否顯示 element ，不需要透過 Javascript event 監聽\n\nHTML 本身的屬性就可以做到基本 Type 檢查，搭配 Web api ，就可以避免使用 Javascript 去處理，減少效能浪費，更讚的是，可以輕鬆的延續使用者的體驗。\n\n---\n\n## 逛攤位的戰利品\n\n![](./20230811_132426.JPG)\n\n我蠻喜歡去搜集貼紙的，趁機搜刮了一些貼紙～還在六角的攤位玩了一個心理測驗，測出來的結果是：\n\n![](./20230811_130550.jpg)\n\n![](./20230813_165751.jpg)\n\n在天瓏的攤位用便宜的價錢入手了這本書，對這本書的印象是在星巴哥的技術專欄上看到有關這本書重構技巧的分享，希望我有時間可以看完它。\n\n---\n\n最後，分享覺得整場最有道理的一句話：\n\n## ![](./20230811_155716.jpg)\n\n---\n\n## 講者分享連結整理\n\n- [大會共筆](https://hackmd.io/@webconf/BkImQ0Ds3/%2FwHBNj8NPQamxPecU9VXoHQ)\n\n- [Will 保哥/活用 GitHub Copilot 開發 Web 應用程式 PPT](https://drive.google.com/file/d/1W7KZ2vwsZyyIC_iMdCxgadXWodWkrU6u/view?fbclid=IwAR0lAS-jXIksFcd08w9gGWJnZGPvHKTN_7n_z1fQDf8koHyQ52EiRawRpmk)\n\n- [Ruddy 老師/AI 驅動下的開發者體驗 PPT](https://onedrive.live.com/?authkey=%21APB1fAuO9FcMusg&id=68B24674607C69D9%21349589&cid=68B24674607C69D9)\n\n- [奶綠茶/WebComponent 的好，用過的都知道 PPT](https://speakerdeck.com/milkmidi/webcomponent)\n- [莫力全(Kyle Mo)/成為前端建築師吧！透過 Frontend Infra 為前端應用打造穩健且高效率的開發體驗 PPT](https://slides.com/oldmo860617/minimal)、[文章](https://oldmo860617.medium.com/%E6%88%90%E7%82%BA%E5%89%8D%E7%AB%AF%E5%BB%BA%E7%AF%89%E5%B8%AB%E5%90%A7-%E9%80%8F%E9%81%8E-frontend-infra-%E7%82%BA%E5%89%8D%E7%AB%AF%E6%87%89%E7%94%A8%E6%89%93%E9%80%A0%E7%A9%A9%E5%81%A5%E4%B8%94%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E9%96%8B%E7%99%BC%E9%AB%94%E9%A9%97-21566b5c95d3)\n- [李明/穿越互動特效網站演化的軌跡 參考文章](https://blockstudio.tw/blog/blog-web-animation-sop)\n- [Paul Li / 鳳‧極意？！](https://blog.lalacube.com/mei/Reveal_phoenix_the_gokui.php?page=1)\n- [Summer Tang/從零打造前端效能監測系統逐字稿](https://www.cythilya.tw/2023/08/12/build-front-end-performance-monitoring-mechanism-from-scratch-webconf-tw-2023/)\n- [小賴/【工作坊】Docker Container 是什麼？可以吃嗎？](https://hackmd.io/@webconf/BkImQ0Ds3/%2FhOq4Qte_TnSy0z8-dcCuig?utm_source=badge&utm_medium=badge&utm_campaign=webconf2023&fbclid=IwAR2DzggADz_M6lyBoJl8Bd87iJmjTYbzJeFvL-wJj3k3YuuszgxdmwSc4rc)\n- [Soking/資訊架構設計新體驗：在需求情境中運用領域事件分析描述結構化內容](https://drive.google.com/file/d/1MXtx08mLPB4_VTRmMr6Bp9pRKY3V2fWm/view?ck_subscriber_id=2283616400&pli=1)\n  以上是我自己有聽的場次＆講者有分享資料的\n\n:::note\n\n本篇文章原先發佈於[Medium](https://wwwwwwwe.medium.com/2023-web-conf-%E5%BF%83%E5%BE%97%E8%88%87%E6%94%B6%E7%A9%AB-e1dba2cb5909)，之後會陸續將 Medium 撰寫的內容慢慢遷移到這個網站。\n","createdAt":"2025-08-16T08:43:45.489Z","updatedAt":"2025-08-16T10:26:29.700Z","publishedAt":"2025-08-16T10:26:29.706Z","locale":null,"author":null}}
{"type":"api::subcategory.subcategory","id":1,"data":{"documentId":"xrpaemqakq2m3no9yhd4nd2f","name":"React","slug":"react","createdAt":"2025-08-16T08:18:00.556Z","updatedAt":"2025-08-16T09:00:46.275Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":3,"data":{"documentId":"obkv1rql1wabmv7c0qb5fu1r","name":"JavaScript","slug":"javascript","createdAt":"2025-08-16T08:29:58.929Z","updatedAt":"2025-08-16T09:00:40.892Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":5,"data":{"documentId":"otrpdd9gzdje4ykowu4oe14c","name":"TypeScript","slug":"typescript","createdAt":"2025-08-16T08:29:58.945Z","updatedAt":"2025-08-16T09:01:04.301Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":7,"data":{"documentId":"mru80jbhz73mes5sl0retejs","name":"CSS","slug":"css","createdAt":"2025-08-16T08:29:58.961Z","updatedAt":"2025-08-16T08:59:29.937Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":9,"data":{"documentId":"syu5pbhlodv5l96onm4xkt1d","name":"Functional Programming","slug":"functional-programming","createdAt":"2025-08-16T08:29:58.975Z","updatedAt":"2025-08-16T09:00:33.985Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":11,"data":{"documentId":"e8e4hxrhku2r01gi4l493f94","name":"React Native","slug":"react-native","createdAt":"2025-08-16T08:29:58.986Z","updatedAt":"2025-08-16T09:00:53.995Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":13,"data":{"documentId":"kn04wau4nfrkz92s5uhy2uvy","name":"DOM","slug":"dom","createdAt":"2025-08-16T08:29:58.997Z","updatedAt":"2025-08-16T09:00:03.373Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":15,"data":{"documentId":"clj5260dpqjnf14e0q12hamp","name":"React思維進化讀書筆記","slug":"react-zet-book","createdAt":"2025-08-16T08:29:59.007Z","updatedAt":"2025-08-16T09:00:58.789Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":17,"data":{"documentId":"g745kxr4188nd3x4cai3dhe6","name":"活動","slug":"activity","createdAt":"2025-08-16T08:29:59.018Z","updatedAt":"2025-08-16T08:59:23.914Z","publishedAt":null,"locale":null}}
{"type":"api::subcategory.subcategory","id":56,"data":{"documentId":"g745kxr4188nd3x4cai3dhe6","name":"活動","slug":"activity","createdAt":"2025-08-16T08:29:59.018Z","updatedAt":"2025-08-16T08:59:23.914Z","publishedAt":"2025-08-16T08:59:23.920Z","locale":null}}
{"type":"api::subcategory.subcategory","id":57,"data":{"documentId":"mru80jbhz73mes5sl0retejs","name":"CSS","slug":"css","createdAt":"2025-08-16T08:29:58.961Z","updatedAt":"2025-08-16T08:59:29.937Z","publishedAt":"2025-08-16T08:59:29.944Z","locale":null}}
{"type":"api::subcategory.subcategory","id":58,"data":{"documentId":"kn04wau4nfrkz92s5uhy2uvy","name":"DOM","slug":"dom","createdAt":"2025-08-16T08:29:58.997Z","updatedAt":"2025-08-16T09:00:03.373Z","publishedAt":"2025-08-16T09:00:03.376Z","locale":null}}
{"type":"api::subcategory.subcategory","id":59,"data":{"documentId":"syu5pbhlodv5l96onm4xkt1d","name":"Functional Programming","slug":"functional-programming","createdAt":"2025-08-16T08:29:58.975Z","updatedAt":"2025-08-16T09:00:33.985Z","publishedAt":"2025-08-16T09:00:33.992Z","locale":null}}
{"type":"api::subcategory.subcategory","id":60,"data":{"documentId":"obkv1rql1wabmv7c0qb5fu1r","name":"JavaScript","slug":"javascript","createdAt":"2025-08-16T08:29:58.929Z","updatedAt":"2025-08-16T09:00:40.892Z","publishedAt":"2025-08-16T09:00:40.899Z","locale":null}}
{"type":"api::subcategory.subcategory","id":61,"data":{"documentId":"xrpaemqakq2m3no9yhd4nd2f","name":"React","slug":"react","createdAt":"2025-08-16T08:18:00.556Z","updatedAt":"2025-08-16T09:00:46.275Z","publishedAt":"2025-08-16T09:00:46.282Z","locale":null}}
{"type":"api::subcategory.subcategory","id":62,"data":{"documentId":"e8e4hxrhku2r01gi4l493f94","name":"React Native","slug":"react-native","createdAt":"2025-08-16T08:29:58.986Z","updatedAt":"2025-08-16T09:00:53.995Z","publishedAt":"2025-08-16T09:00:54.002Z","locale":null}}
{"type":"api::subcategory.subcategory","id":63,"data":{"documentId":"clj5260dpqjnf14e0q12hamp","name":"React思維進化讀書筆記","slug":"react-zet-book","createdAt":"2025-08-16T08:29:59.007Z","updatedAt":"2025-08-16T09:00:58.789Z","publishedAt":"2025-08-16T09:00:58.797Z","locale":null}}
{"type":"api::subcategory.subcategory","id":64,"data":{"documentId":"otrpdd9gzdje4ykowu4oe14c","name":"TypeScript","slug":"typescript","createdAt":"2025-08-16T08:29:58.945Z","updatedAt":"2025-08-16T09:01:04.301Z","publishedAt":"2025-08-16T09:01:04.306Z","locale":null}}
{"type":"api::tag.tag","id":1,"data":{"documentId":"oymww426me83w0ar8cz91wej","name":"2023 WebConf","slug":"2023-webconf","createdAt":"2025-08-16T08:31:27.326Z","updatedAt":"2025-08-16T08:31:27.326Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":2,"data":{"documentId":"oymww426me83w0ar8cz91wej","name":"2023 WebConf","slug":"2023-webconf","createdAt":"2025-08-16T08:31:27.326Z","updatedAt":"2025-08-16T08:31:27.326Z","publishedAt":"2025-08-16T08:31:27.327Z","locale":null}}
{"type":"api::tag.tag","id":3,"data":{"documentId":"bdd95rhgjbpla2vfq8x541mv","name":"event","slug":"event","createdAt":"2025-08-16T08:31:27.335Z","updatedAt":"2025-08-16T08:31:27.335Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":4,"data":{"documentId":"bdd95rhgjbpla2vfq8x541mv","name":"event","slug":"event","createdAt":"2025-08-16T08:31:27.335Z","updatedAt":"2025-08-16T08:31:27.335Z","publishedAt":"2025-08-16T08:31:27.337Z","locale":null}}
{"type":"api::tag.tag","id":5,"data":{"documentId":"nh7upk5qd6keweajv8vyh9mx","name":"conference","slug":"conference","createdAt":"2025-08-16T08:31:27.345Z","updatedAt":"2025-08-16T08:31:27.345Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":6,"data":{"documentId":"nh7upk5qd6keweajv8vyh9mx","name":"conference","slug":"conference","createdAt":"2025-08-16T08:31:27.345Z","updatedAt":"2025-08-16T08:31:27.345Z","publishedAt":"2025-08-16T08:31:27.346Z","locale":null}}
{"type":"api::tag.tag","id":7,"data":{"documentId":"ry39cldzayaxs2hawbad5uxy","name":"2023iT鐵人賽","slug":"2023it","createdAt":"2025-08-16T08:34:19.048Z","updatedAt":"2025-08-16T08:34:19.048Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":8,"data":{"documentId":"ry39cldzayaxs2hawbad5uxy","name":"2023iT鐵人賽","slug":"2023it","createdAt":"2025-08-16T08:34:19.048Z","updatedAt":"2025-08-16T08:34:19.048Z","publishedAt":"2025-08-16T08:34:19.049Z","locale":null}}
{"type":"api::tag.tag","id":9,"data":{"documentId":"yr0lcgj0ckqvcox689pyfdm8","name":"2024 ReactConf","slug":"2024-reactconf","createdAt":"2025-08-16T08:34:19.098Z","updatedAt":"2025-08-16T08:34:19.098Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":10,"data":{"documentId":"yr0lcgj0ckqvcox689pyfdm8","name":"2024 ReactConf","slug":"2024-reactconf","createdAt":"2025-08-16T08:34:19.098Z","updatedAt":"2025-08-16T08:34:19.098Z","publishedAt":"2025-08-16T08:34:19.099Z","locale":null}}
{"type":"api::tag.tag","id":11,"data":{"documentId":"mp2vury12j7l3oc4pq3y2u3g","name":"React Native","slug":"react-native","createdAt":"2025-08-16T08:34:19.111Z","updatedAt":"2025-08-16T08:34:19.111Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":12,"data":{"documentId":"mp2vury12j7l3oc4pq3y2u3g","name":"React Native","slug":"react-native","createdAt":"2025-08-16T08:34:19.111Z","updatedAt":"2025-08-16T08:34:19.111Z","publishedAt":"2025-08-16T08:34:19.112Z","locale":null}}
{"type":"api::tag.tag","id":13,"data":{"documentId":"wdpaxheov081y1uiqx3yywxw","name":"2024iT鐵人賽","slug":"2024it","createdAt":"2025-08-16T08:34:19.199Z","updatedAt":"2025-08-16T08:34:19.199Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":14,"data":{"documentId":"wdpaxheov081y1uiqx3yywxw","name":"2024iT鐵人賽","slug":"2024it","createdAt":"2025-08-16T08:34:19.199Z","updatedAt":"2025-08-16T08:34:19.199Z","publishedAt":"2025-08-16T08:34:19.200Z","locale":null}}
{"type":"api::tag.tag","id":15,"data":{"documentId":"zfznmvn6k6j2c5u2yd3tc2qm","name":"2024 WebConf","slug":"2024-webconf","createdAt":"2025-08-16T08:34:19.241Z","updatedAt":"2025-08-16T08:34:19.241Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":16,"data":{"documentId":"zfznmvn6k6j2c5u2yd3tc2qm","name":"2024 WebConf","slug":"2024-webconf","createdAt":"2025-08-16T08:34:19.241Z","updatedAt":"2025-08-16T08:34:19.241Z","publishedAt":"2025-08-16T08:34:19.242Z","locale":null}}
{"type":"api::tag.tag","id":17,"data":{"documentId":"uo2jrbw534tzb10b1luvdhjx","name":"css","slug":"css","createdAt":"2025-08-16T08:43:45.696Z","updatedAt":"2025-08-16T08:43:45.696Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":18,"data":{"documentId":"uo2jrbw534tzb10b1luvdhjx","name":"css","slug":"css","createdAt":"2025-08-16T08:43:45.696Z","updatedAt":"2025-08-16T08:43:45.696Z","publishedAt":"2025-08-16T08:43:45.696Z","locale":null}}
{"type":"api::tag.tag","id":19,"data":{"documentId":"aor2g56by4x6hiv3ztu65w7q","name":"translate","slug":"translate","createdAt":"2025-08-16T08:43:45.702Z","updatedAt":"2025-08-16T08:43:45.702Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":20,"data":{"documentId":"aor2g56by4x6hiv3ztu65w7q","name":"translate","slug":"translate","createdAt":"2025-08-16T08:43:45.702Z","updatedAt":"2025-08-16T08:43:45.702Z","publishedAt":"2025-08-16T08:43:45.703Z","locale":null}}
{"type":"api::tag.tag","id":21,"data":{"documentId":"qw49d825xck33gq7cjmn5we7","name":"reflow","slug":"reflow","createdAt":"2025-08-16T08:43:45.710Z","updatedAt":"2025-08-16T08:43:45.710Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":22,"data":{"documentId":"qw49d825xck33gq7cjmn5we7","name":"reflow","slug":"reflow","createdAt":"2025-08-16T08:43:45.710Z","updatedAt":"2025-08-16T08:43:45.710Z","publishedAt":"2025-08-16T08:43:45.711Z","locale":null}}
{"type":"api::tag.tag","id":23,"data":{"documentId":"sippqlxztmfk9qgm3lg8sose","name":"getElementsByClassName","slug":"getelementsbyclassname","createdAt":"2025-08-16T08:43:45.766Z","updatedAt":"2025-08-16T08:43:45.766Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":24,"data":{"documentId":"sippqlxztmfk9qgm3lg8sose","name":"getElementsByClassName","slug":"getelementsbyclassname","createdAt":"2025-08-16T08:43:45.766Z","updatedAt":"2025-08-16T08:43:45.766Z","publishedAt":"2025-08-16T08:43:45.767Z","locale":null}}
{"type":"api::tag.tag","id":25,"data":{"documentId":"qeuur3qjr2pfhzh654w694hb","name":"DOM","slug":"dom","createdAt":"2025-08-16T08:43:45.773Z","updatedAt":"2025-08-16T08:43:45.773Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":26,"data":{"documentId":"qeuur3qjr2pfhzh654w694hb","name":"DOM","slug":"dom","createdAt":"2025-08-16T08:43:45.773Z","updatedAt":"2025-08-16T08:43:45.773Z","publishedAt":"2025-08-16T08:43:45.774Z","locale":null}}
{"type":"api::tag.tag","id":27,"data":{"documentId":"t5jh90ekuedt3368dq0vqfqa","name":"JavaScript","slug":"javascript","createdAt":"2025-08-16T08:43:45.781Z","updatedAt":"2025-08-16T08:43:45.781Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":28,"data":{"documentId":"t5jh90ekuedt3368dq0vqfqa","name":"JavaScript","slug":"javascript","createdAt":"2025-08-16T08:43:45.781Z","updatedAt":"2025-08-16T08:43:45.781Z","publishedAt":"2025-08-16T08:43:45.782Z","locale":null}}
{"type":"api::tag.tag","id":29,"data":{"documentId":"ho4356dl1khqfgexi4mr3qa5","name":"recursion","slug":"recursion","createdAt":"2025-08-16T08:43:45.788Z","updatedAt":"2025-08-16T08:43:45.788Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":30,"data":{"documentId":"ho4356dl1khqfgexi4mr3qa5","name":"recursion","slug":"recursion","createdAt":"2025-08-16T08:43:45.788Z","updatedAt":"2025-08-16T08:43:45.788Z","publishedAt":"2025-08-16T08:43:45.788Z","locale":null}}
{"type":"api::tag.tag","id":31,"data":{"documentId":"za6hojqyllv2q3egl3hveqgh","name":"getElementsByTagName","slug":"getelementsbytagname","createdAt":"2025-08-16T08:43:45.880Z","updatedAt":"2025-08-16T08:43:45.880Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":32,"data":{"documentId":"za6hojqyllv2q3egl3hveqgh","name":"getElementsByTagName","slug":"getelementsbytagname","createdAt":"2025-08-16T08:43:45.880Z","updatedAt":"2025-08-16T08:43:45.880Z","publishedAt":"2025-08-16T08:43:45.884Z","locale":null}}
{"type":"api::tag.tag","id":33,"data":{"documentId":"uu4nftft8lvczz73cxeco63n","name":"hosting","slug":"hosting","createdAt":"2025-08-16T08:43:45.946Z","updatedAt":"2025-08-16T08:43:45.946Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":34,"data":{"documentId":"uu4nftft8lvczz73cxeco63n","name":"hosting","slug":"hosting","createdAt":"2025-08-16T08:43:45.946Z","updatedAt":"2025-08-16T08:43:45.946Z","publishedAt":"2025-08-16T08:43:45.947Z","locale":null}}
{"type":"api::tag.tag","id":35,"data":{"documentId":"cm0etoxs5au4eiareo9svcjq","name":"variables","slug":"variables","createdAt":"2025-08-16T08:43:45.998Z","updatedAt":"2025-08-16T08:43:45.998Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":36,"data":{"documentId":"cm0etoxs5au4eiareo9svcjq","name":"variables","slug":"variables","createdAt":"2025-08-16T08:43:45.998Z","updatedAt":"2025-08-16T08:43:45.998Z","publishedAt":"2025-08-16T08:43:45.999Z","locale":null}}
{"type":"api::tag.tag","id":37,"data":{"documentId":"aks685tvw86zp196ohglhvc5","name":"let","slug":"let","createdAt":"2025-08-16T08:43:46.011Z","updatedAt":"2025-08-16T08:43:46.011Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":38,"data":{"documentId":"aks685tvw86zp196ohglhvc5","name":"let","slug":"let","createdAt":"2025-08-16T08:43:46.011Z","updatedAt":"2025-08-16T08:43:46.011Z","publishedAt":"2025-08-16T08:43:46.012Z","locale":null}}
{"type":"api::tag.tag","id":39,"data":{"documentId":"ly80bi143vyskhz12bxdglks","name":"var","slug":"var","createdAt":"2025-08-16T08:43:46.019Z","updatedAt":"2025-08-16T08:43:46.019Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":40,"data":{"documentId":"ly80bi143vyskhz12bxdglks","name":"var","slug":"var","createdAt":"2025-08-16T08:43:46.019Z","updatedAt":"2025-08-16T08:43:46.019Z","publishedAt":"2025-08-16T08:43:46.020Z","locale":null}}
{"type":"api::tag.tag","id":41,"data":{"documentId":"bl8dl8roc8kyzi6tr7jf0ur3","name":"const","slug":"const","createdAt":"2025-08-16T08:43:46.028Z","updatedAt":"2025-08-16T08:43:46.028Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":42,"data":{"documentId":"bl8dl8roc8kyzi6tr7jf0ur3","name":"const","slug":"const","createdAt":"2025-08-16T08:43:46.028Z","updatedAt":"2025-08-16T08:43:46.028Z","publishedAt":"2025-08-16T08:43:46.029Z","locale":null}}
{"type":"api::tag.tag","id":43,"data":{"documentId":"huglih8azowe7a600hngpr05","name":"operator","slug":"operator","createdAt":"2025-08-16T08:43:46.114Z","updatedAt":"2025-08-16T08:43:46.114Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":44,"data":{"documentId":"huglih8azowe7a600hngpr05","name":"operator","slug":"operator","createdAt":"2025-08-16T08:43:46.114Z","updatedAt":"2025-08-16T08:43:46.114Z","publishedAt":"2025-08-16T08:43:46.115Z","locale":null}}
{"type":"api::tag.tag","id":45,"data":{"documentId":"k056l01tixkgjii3z3x6tegk","name":"type coercion","slug":"type-coercion","createdAt":"2025-08-16T08:43:46.124Z","updatedAt":"2025-08-16T08:43:46.124Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":46,"data":{"documentId":"k056l01tixkgjii3z3x6tegk","name":"type coercion","slug":"type-coercion","createdAt":"2025-08-16T08:43:46.124Z","updatedAt":"2025-08-16T08:43:46.124Z","publishedAt":"2025-08-16T08:43:46.125Z","locale":null}}
{"type":"api::tag.tag","id":47,"data":{"documentId":"yewz6hg9eyxb1it2vqoc14ux","name":"equality","slug":"equality","createdAt":"2025-08-16T08:43:46.131Z","updatedAt":"2025-08-16T08:43:46.131Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":48,"data":{"documentId":"yewz6hg9eyxb1it2vqoc14ux","name":"equality","slug":"equality","createdAt":"2025-08-16T08:43:46.131Z","updatedAt":"2025-08-16T08:43:46.131Z","publishedAt":"2025-08-16T08:43:46.131Z","locale":null}}
{"type":"api::tag.tag","id":49,"data":{"documentId":"n8zd0m3163ftwgbvjaat0tor","name":"strict equality","slug":"strict-equality","createdAt":"2025-08-16T08:43:46.137Z","updatedAt":"2025-08-16T08:43:46.137Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":50,"data":{"documentId":"n8zd0m3163ftwgbvjaat0tor","name":"strict equality","slug":"strict-equality","createdAt":"2025-08-16T08:43:46.137Z","updatedAt":"2025-08-16T08:43:46.137Z","publishedAt":"2025-08-16T08:43:46.138Z","locale":null}}
{"type":"api::tag.tag","id":51,"data":{"documentId":"swwigjsurp1v5apmi9wl3jte","name":"event-loop","slug":"event-loop","createdAt":"2025-08-16T08:43:46.211Z","updatedAt":"2025-08-16T08:43:46.211Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":52,"data":{"documentId":"swwigjsurp1v5apmi9wl3jte","name":"event-loop","slug":"event-loop","createdAt":"2025-08-16T08:43:46.211Z","updatedAt":"2025-08-16T08:43:46.211Z","publishedAt":"2025-08-16T08:43:46.211Z","locale":null}}
{"type":"api::tag.tag","id":53,"data":{"documentId":"y9a4xzjqs7sanxeqie1bpd2m","name":"event delegation","slug":"event-delegation","createdAt":"2025-08-16T08:43:46.261Z","updatedAt":"2025-08-16T08:43:46.261Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":54,"data":{"documentId":"y9a4xzjqs7sanxeqie1bpd2m","name":"event delegation","slug":"event-delegation","createdAt":"2025-08-16T08:43:46.261Z","updatedAt":"2025-08-16T08:43:46.261Z","publishedAt":"2025-08-16T08:43:46.262Z","locale":null}}
{"type":"api::tag.tag","id":55,"data":{"documentId":"b8ijm3zgwxu5mnsdg2nqjutf","name":"this","slug":"this","createdAt":"2025-08-16T08:43:46.318Z","updatedAt":"2025-08-16T08:43:46.318Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":56,"data":{"documentId":"b8ijm3zgwxu5mnsdg2nqjutf","name":"this","slug":"this","createdAt":"2025-08-16T08:43:46.318Z","updatedAt":"2025-08-16T08:43:46.318Z","publishedAt":"2025-08-16T08:43:46.319Z","locale":null}}
{"type":"api::tag.tag","id":57,"data":{"documentId":"kt2s5cuied2x7kat9qxu0utp","name":"cookie","slug":"cookie","createdAt":"2025-08-16T08:43:46.363Z","updatedAt":"2025-08-16T08:43:46.363Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":58,"data":{"documentId":"kt2s5cuied2x7kat9qxu0utp","name":"cookie","slug":"cookie","createdAt":"2025-08-16T08:43:46.363Z","updatedAt":"2025-08-16T08:43:46.363Z","publishedAt":"2025-08-16T08:43:46.363Z","locale":null}}
{"type":"api::tag.tag","id":59,"data":{"documentId":"t6kuy0z6409xf6alrp3pdni0","name":"localStorage","slug":"localstorage","createdAt":"2025-08-16T08:43:46.370Z","updatedAt":"2025-08-16T08:43:46.370Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":60,"data":{"documentId":"t6kuy0z6409xf6alrp3pdni0","name":"localStorage","slug":"localstorage","createdAt":"2025-08-16T08:43:46.370Z","updatedAt":"2025-08-16T08:43:46.370Z","publishedAt":"2025-08-16T08:43:46.371Z","locale":null}}
{"type":"api::tag.tag","id":61,"data":{"documentId":"ed6i2fwip2czo28q8lj2x91q","name":"sessionStorage","slug":"sessionstorage","createdAt":"2025-08-16T08:43:46.376Z","updatedAt":"2025-08-16T08:43:46.376Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":62,"data":{"documentId":"ed6i2fwip2czo28q8lj2x91q","name":"sessionStorage","slug":"sessionstorage","createdAt":"2025-08-16T08:43:46.376Z","updatedAt":"2025-08-16T08:43:46.376Z","publishedAt":"2025-08-16T08:43:46.377Z","locale":null}}
{"type":"api::tag.tag","id":63,"data":{"documentId":"esci8j3evqumvcw7rolpb5m0","name":"browser","slug":"browser","createdAt":"2025-08-16T08:43:46.388Z","updatedAt":"2025-08-16T08:43:46.388Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":64,"data":{"documentId":"esci8j3evqumvcw7rolpb5m0","name":"browser","slug":"browser","createdAt":"2025-08-16T08:43:46.388Z","updatedAt":"2025-08-16T08:43:46.388Z","publishedAt":"2025-08-16T08:43:46.389Z","locale":null}}
{"type":"api::tag.tag","id":65,"data":{"documentId":"sxlkiarsfjoj0won5h55m0bx","name":"script","slug":"script","createdAt":"2025-08-16T08:43:46.445Z","updatedAt":"2025-08-16T08:43:46.445Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":66,"data":{"documentId":"sxlkiarsfjoj0won5h55m0bx","name":"script","slug":"script","createdAt":"2025-08-16T08:43:46.445Z","updatedAt":"2025-08-16T08:43:46.445Z","publishedAt":"2025-08-16T08:43:46.446Z","locale":null}}
{"type":"api::tag.tag","id":67,"data":{"documentId":"gt7l0d8snyhzpwr3y27ajcyj","name":"defer","slug":"defer","createdAt":"2025-08-16T08:43:46.462Z","updatedAt":"2025-08-16T08:43:46.462Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":68,"data":{"documentId":"gt7l0d8snyhzpwr3y27ajcyj","name":"defer","slug":"defer","createdAt":"2025-08-16T08:43:46.462Z","updatedAt":"2025-08-16T08:43:46.462Z","publishedAt":"2025-08-16T08:43:46.463Z","locale":null}}
{"type":"api::tag.tag","id":69,"data":{"documentId":"s5ejcqajabcb1lrl64djj8yf","name":"null","slug":"null","createdAt":"2025-08-16T08:43:46.535Z","updatedAt":"2025-08-16T08:43:46.535Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":70,"data":{"documentId":"s5ejcqajabcb1lrl64djj8yf","name":"null","slug":"null","createdAt":"2025-08-16T08:43:46.535Z","updatedAt":"2025-08-16T08:43:46.535Z","publishedAt":"2025-08-16T08:43:46.536Z","locale":null}}
{"type":"api::tag.tag","id":71,"data":{"documentId":"f9jlrs2me75beh65v4vfp9br","name":"undefined","slug":"undefined","createdAt":"2025-08-16T08:43:46.559Z","updatedAt":"2025-08-16T08:43:46.559Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":72,"data":{"documentId":"f9jlrs2me75beh65v4vfp9br","name":"undefined","slug":"undefined","createdAt":"2025-08-16T08:43:46.559Z","updatedAt":"2025-08-16T08:43:46.559Z","publishedAt":"2025-08-16T08:43:46.560Z","locale":null}}
{"type":"api::tag.tag","id":73,"data":{"documentId":"byt3438l311jerhmmhcot3sv","name":"undeclared","slug":"undeclared","createdAt":"2025-08-16T08:43:46.568Z","updatedAt":"2025-08-16T08:43:46.568Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":74,"data":{"documentId":"byt3438l311jerhmmhcot3sv","name":"undeclared","slug":"undeclared","createdAt":"2025-08-16T08:43:46.568Z","updatedAt":"2025-08-16T08:43:46.568Z","publishedAt":"2025-08-16T08:43:46.569Z","locale":null}}
{"type":"api::tag.tag","id":75,"data":{"documentId":"p3e1pwxyk5f247jg6gn9m8bi","name":"call","slug":"call","createdAt":"2025-08-16T08:43:46.631Z","updatedAt":"2025-08-16T08:43:46.631Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":76,"data":{"documentId":"p3e1pwxyk5f247jg6gn9m8bi","name":"call","slug":"call","createdAt":"2025-08-16T08:43:46.631Z","updatedAt":"2025-08-16T08:43:46.631Z","publishedAt":"2025-08-16T08:43:46.632Z","locale":null}}
{"type":"api::tag.tag","id":77,"data":{"documentId":"jfem7r5i59uwtmr7jsey7av5","name":"apply","slug":"apply","createdAt":"2025-08-16T08:43:46.637Z","updatedAt":"2025-08-16T08:43:46.637Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":78,"data":{"documentId":"jfem7r5i59uwtmr7jsey7av5","name":"apply","slug":"apply","createdAt":"2025-08-16T08:43:46.637Z","updatedAt":"2025-08-16T08:43:46.637Z","publishedAt":"2025-08-16T08:43:46.637Z","locale":null}}
{"type":"api::tag.tag","id":79,"data":{"documentId":"mauv3h899vaxjgq7pf4nf52u","name":"closure","slug":"closure","createdAt":"2025-08-16T08:43:46.692Z","updatedAt":"2025-08-16T08:43:46.692Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":80,"data":{"documentId":"mauv3h899vaxjgq7pf4nf52u","name":"closure","slug":"closure","createdAt":"2025-08-16T08:43:46.692Z","updatedAt":"2025-08-16T08:43:46.692Z","publishedAt":"2025-08-16T08:43:46.693Z","locale":null}}
{"type":"api::tag.tag","id":81,"data":{"documentId":"bklhkf58yz1wbukqxnhwc09t","name":"prototype","slug":"prototype","createdAt":"2025-08-16T08:43:46.731Z","updatedAt":"2025-08-16T08:43:46.731Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":82,"data":{"documentId":"bklhkf58yz1wbukqxnhwc09t","name":"prototype","slug":"prototype","createdAt":"2025-08-16T08:43:46.731Z","updatedAt":"2025-08-16T08:43:46.731Z","publishedAt":"2025-08-16T08:43:46.732Z","locale":null}}
{"type":"api::tag.tag","id":83,"data":{"documentId":"gs94kap9rr5fm4hip4yf9rpj","name":"prototype chain","slug":"prototype-chain","createdAt":"2025-08-16T08:43:46.740Z","updatedAt":"2025-08-16T08:43:46.740Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":84,"data":{"documentId":"gs94kap9rr5fm4hip4yf9rpj","name":"prototype chain","slug":"prototype-chain","createdAt":"2025-08-16T08:43:46.740Z","updatedAt":"2025-08-16T08:43:46.740Z","publishedAt":"2025-08-16T08:43:46.741Z","locale":null}}
{"type":"api::tag.tag","id":85,"data":{"documentId":"q125vzk9xtdanxbpnt946iou","name":"Map","slug":"map","createdAt":"2025-08-16T08:43:46.789Z","updatedAt":"2025-08-16T08:43:46.789Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":86,"data":{"documentId":"q125vzk9xtdanxbpnt946iou","name":"Map","slug":"map","createdAt":"2025-08-16T08:43:46.789Z","updatedAt":"2025-08-16T08:43:46.789Z","publishedAt":"2025-08-16T08:43:46.789Z","locale":null}}
{"type":"api::tag.tag","id":87,"data":{"documentId":"odfpi313t5njusoqrx5qcpm7","name":"WeakMap","slug":"weakmap","createdAt":"2025-08-16T08:43:46.794Z","updatedAt":"2025-08-16T08:43:46.794Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":88,"data":{"documentId":"odfpi313t5njusoqrx5qcpm7","name":"WeakMap","slug":"weakmap","createdAt":"2025-08-16T08:43:46.794Z","updatedAt":"2025-08-16T08:43:46.794Z","publishedAt":"2025-08-16T08:43:46.795Z","locale":null}}
{"type":"api::tag.tag","id":89,"data":{"documentId":"wnpp78oh9c3972e6h901kp37","name":"Set","slug":"set","createdAt":"2025-08-16T08:43:46.801Z","updatedAt":"2025-08-16T08:43:46.801Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":90,"data":{"documentId":"wnpp78oh9c3972e6h901kp37","name":"Set","slug":"set","createdAt":"2025-08-16T08:43:46.801Z","updatedAt":"2025-08-16T08:43:46.801Z","publishedAt":"2025-08-16T08:43:46.801Z","locale":null}}
{"type":"api::tag.tag","id":91,"data":{"documentId":"ii5qt68oc4r1ddlahe9n15iz","name":"WeakSet","slug":"weakset","createdAt":"2025-08-16T08:43:46.807Z","updatedAt":"2025-08-16T08:43:46.807Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":92,"data":{"documentId":"ii5qt68oc4r1ddlahe9n15iz","name":"WeakSet","slug":"weakset","createdAt":"2025-08-16T08:43:46.807Z","updatedAt":"2025-08-16T08:43:46.807Z","publishedAt":"2025-08-16T08:43:46.808Z","locale":null}}
{"type":"api::tag.tag","id":93,"data":{"documentId":"lcv04tkmo782r3wzjf2ugvb7","name":"synchronous","slug":"synchronous","createdAt":"2025-08-16T08:43:54.859Z","updatedAt":"2025-08-16T08:43:54.859Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":94,"data":{"documentId":"lcv04tkmo782r3wzjf2ugvb7","name":"synchronous","slug":"synchronous","createdAt":"2025-08-16T08:43:54.859Z","updatedAt":"2025-08-16T08:43:54.859Z","publishedAt":"2025-08-16T08:43:54.860Z","locale":null}}
{"type":"api::tag.tag","id":95,"data":{"documentId":"qy9wbeqm689c0zd6ir7yrgw4","name":"asynchronous","slug":"asynchronous","createdAt":"2025-08-16T08:43:54.872Z","updatedAt":"2025-08-16T08:43:54.872Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":96,"data":{"documentId":"qy9wbeqm689c0zd6ir7yrgw4","name":"asynchronous","slug":"asynchronous","createdAt":"2025-08-16T08:43:54.872Z","updatedAt":"2025-08-16T08:43:54.872Z","publishedAt":"2025-08-16T08:43:54.873Z","locale":null}}
{"type":"api::tag.tag","id":97,"data":{"documentId":"zuaps6wjl6gv7v5bxfx7kjzq","name":"anonymous function","slug":"anonymous-function","createdAt":"2025-08-16T08:43:54.936Z","updatedAt":"2025-08-16T08:43:54.936Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":98,"data":{"documentId":"zuaps6wjl6gv7v5bxfx7kjzq","name":"anonymous function","slug":"anonymous-function","createdAt":"2025-08-16T08:43:54.936Z","updatedAt":"2025-08-16T08:43:54.936Z","publishedAt":"2025-08-16T08:43:54.937Z","locale":null}}
{"type":"api::tag.tag","id":99,"data":{"documentId":"fux86jx586yk0ld0ga6r0adc","name":"debounce","slug":"debounce","createdAt":"2025-08-16T08:43:54.990Z","updatedAt":"2025-08-16T08:43:54.990Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":100,"data":{"documentId":"fux86jx586yk0ld0ga6r0adc","name":"debounce","slug":"debounce","createdAt":"2025-08-16T08:43:54.990Z","updatedAt":"2025-08-16T08:43:54.990Z","publishedAt":"2025-08-16T08:43:54.991Z","locale":null}}
{"type":"api::tag.tag","id":101,"data":{"documentId":"kkzysjtsb7byu1yjid5r2dd4","name":"throttle","slug":"throttle","createdAt":"2025-08-16T08:43:54.998Z","updatedAt":"2025-08-16T08:43:54.998Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":102,"data":{"documentId":"kkzysjtsb7byu1yjid5r2dd4","name":"throttle","slug":"throttle","createdAt":"2025-08-16T08:43:54.998Z","updatedAt":"2025-08-16T08:43:54.998Z","publishedAt":"2025-08-16T08:43:54.999Z","locale":null}}
{"type":"api::tag.tag","id":103,"data":{"documentId":"ji4bm2if4s8efxn36m6gax8o","name":"Typescript","slug":"typescript","createdAt":"2025-08-16T08:43:55.088Z","updatedAt":"2025-08-16T08:43:55.088Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":104,"data":{"documentId":"ji4bm2if4s8efxn36m6gax8o","name":"Typescript","slug":"typescript","createdAt":"2025-08-16T08:43:55.088Z","updatedAt":"2025-08-16T08:43:55.088Z","publishedAt":"2025-08-16T08:43:55.089Z","locale":null}}
{"type":"api::tag.tag","id":105,"data":{"documentId":"iaxg9gmzzf3qu8n4m0kwimbn","name":"interface","slug":"interface","createdAt":"2025-08-16T08:43:55.095Z","updatedAt":"2025-08-16T08:43:55.095Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":106,"data":{"documentId":"iaxg9gmzzf3qu8n4m0kwimbn","name":"interface","slug":"interface","createdAt":"2025-08-16T08:43:55.095Z","updatedAt":"2025-08-16T08:43:55.095Z","publishedAt":"2025-08-16T08:43:55.096Z","locale":null}}
{"type":"api::tag.tag","id":107,"data":{"documentId":"z05qtkahmalie0f9g7zocjrz","name":"type","slug":"type","createdAt":"2025-08-16T08:43:55.101Z","updatedAt":"2025-08-16T08:43:55.101Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":108,"data":{"documentId":"z05qtkahmalie0f9g7zocjrz","name":"type","slug":"type","createdAt":"2025-08-16T08:43:55.101Z","updatedAt":"2025-08-16T08:43:55.101Z","publishedAt":"2025-08-16T08:43:55.102Z","locale":null}}
{"type":"api::tag.tag","id":109,"data":{"documentId":"cfri1xprpzgt5r9rujvk5qjw","name":"React","slug":"react","createdAt":"2025-08-16T08:43:55.293Z","updatedAt":"2025-08-16T08:43:55.293Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":110,"data":{"documentId":"cfri1xprpzgt5r9rujvk5qjw","name":"React","slug":"react","createdAt":"2025-08-16T08:43:55.293Z","updatedAt":"2025-08-16T08:43:55.293Z","publishedAt":"2025-08-16T08:43:55.293Z","locale":null}}
{"type":"api::tag.tag","id":111,"data":{"documentId":"yu1s6t5oxkjlx7vswqfr6z3z","name":"useContext","slug":"usecontext","createdAt":"2025-08-16T08:43:55.299Z","updatedAt":"2025-08-16T08:43:55.299Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":112,"data":{"documentId":"yu1s6t5oxkjlx7vswqfr6z3z","name":"useContext","slug":"usecontext","createdAt":"2025-08-16T08:43:55.299Z","updatedAt":"2025-08-16T08:43:55.299Z","publishedAt":"2025-08-16T08:43:55.299Z","locale":null}}
{"type":"api::tag.tag","id":113,"data":{"documentId":"stavaarz7sn637s0qizd2kbf","name":"React-MobX","slug":"react-mobx","createdAt":"2025-08-16T08:43:55.304Z","updatedAt":"2025-08-16T08:43:55.304Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":114,"data":{"documentId":"stavaarz7sn637s0qizd2kbf","name":"React-MobX","slug":"react-mobx","createdAt":"2025-08-16T08:43:55.304Z","updatedAt":"2025-08-16T08:43:55.304Z","publishedAt":"2025-08-16T08:43:55.305Z","locale":null}}
{"type":"api::tag.tag","id":115,"data":{"documentId":"dair1rg5nwc2g1ovubibg23l","name":"virtual dom","slug":"virtual-dom","createdAt":"2025-08-16T08:43:55.436Z","updatedAt":"2025-08-16T08:43:55.436Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":116,"data":{"documentId":"dair1rg5nwc2g1ovubibg23l","name":"virtual dom","slug":"virtual-dom","createdAt":"2025-08-16T08:43:55.436Z","updatedAt":"2025-08-16T08:43:55.436Z","publishedAt":"2025-08-16T08:43:55.436Z","locale":null}}
{"type":"api::tag.tag","id":117,"data":{"documentId":"va0gftyxa6g19n8w3jc3nshj","name":"jsx","slug":"jsx","createdAt":"2025-08-16T08:43:55.506Z","updatedAt":"2025-08-16T08:43:55.506Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":118,"data":{"documentId":"va0gftyxa6g19n8w3jc3nshj","name":"jsx","slug":"jsx","createdAt":"2025-08-16T08:43:55.506Z","updatedAt":"2025-08-16T08:43:55.506Z","publishedAt":"2025-08-16T08:43:55.507Z","locale":null}}
{"type":"api::tag.tag","id":119,"data":{"documentId":"kv3un35uglx5hlqjs1hnlojo","name":"reconciliation","slug":"reconciliation","createdAt":"2025-08-16T08:43:55.603Z","updatedAt":"2025-08-16T08:43:55.603Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":120,"data":{"documentId":"kv3un35uglx5hlqjs1hnlojo","name":"reconciliation","slug":"reconciliation","createdAt":"2025-08-16T08:43:55.603Z","updatedAt":"2025-08-16T08:43:55.603Z","publishedAt":"2025-08-16T08:43:55.604Z","locale":null}}
{"type":"api::tag.tag","id":121,"data":{"documentId":"df3jxvbuzalz0bfclae5sbyi","name":"immutable update","slug":"immutable-update","createdAt":"2025-08-16T08:43:55.674Z","updatedAt":"2025-08-16T08:43:55.674Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":122,"data":{"documentId":"df3jxvbuzalz0bfclae5sbyi","name":"immutable update","slug":"immutable-update","createdAt":"2025-08-16T08:43:55.674Z","updatedAt":"2025-08-16T08:43:55.674Z","publishedAt":"2025-08-16T08:43:55.675Z","locale":null}}
{"type":"api::tag.tag","id":123,"data":{"documentId":"oi6za8qcov637udr36wvb3c2","name":"shallow clone","slug":"shallow-clone","createdAt":"2025-08-16T08:43:55.679Z","updatedAt":"2025-08-16T08:43:55.679Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":124,"data":{"documentId":"oi6za8qcov637udr36wvb3c2","name":"shallow clone","slug":"shallow-clone","createdAt":"2025-08-16T08:43:55.679Z","updatedAt":"2025-08-16T08:43:55.679Z","publishedAt":"2025-08-16T08:43:55.680Z","locale":null}}
{"type":"api::tag.tag","id":125,"data":{"documentId":"kr3opwoqtbiubmtoznm3im12","name":"deep clone","slug":"deep-clone","createdAt":"2025-08-16T08:43:55.684Z","updatedAt":"2025-08-16T08:43:55.684Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":126,"data":{"documentId":"kr3opwoqtbiubmtoznm3im12","name":"deep clone","slug":"deep-clone","createdAt":"2025-08-16T08:43:55.684Z","updatedAt":"2025-08-16T08:43:55.684Z","publishedAt":"2025-08-16T08:43:55.684Z","locale":null}}
{"type":"api::tag.tag","id":127,"data":{"documentId":"pzb3zbj6dvpbfrrindqssayh","name":"component","slug":"component","createdAt":"2025-08-16T08:43:55.729Z","updatedAt":"2025-08-16T08:43:55.729Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":128,"data":{"documentId":"pzb3zbj6dvpbfrrindqssayh","name":"component","slug":"component","createdAt":"2025-08-16T08:43:55.729Z","updatedAt":"2025-08-16T08:43:55.729Z","publishedAt":"2025-08-16T08:43:55.730Z","locale":null}}
{"type":"api::tag.tag","id":129,"data":{"documentId":"lc1fddu3agbrg2putzk1yvrz","name":"mount","slug":"mount","createdAt":"2025-08-16T08:43:55.734Z","updatedAt":"2025-08-16T08:43:55.734Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":130,"data":{"documentId":"lc1fddu3agbrg2putzk1yvrz","name":"mount","slug":"mount","createdAt":"2025-08-16T08:43:55.734Z","updatedAt":"2025-08-16T08:43:55.734Z","publishedAt":"2025-08-16T08:43:55.735Z","locale":null}}
{"type":"api::tag.tag","id":131,"data":{"documentId":"x1qs0o673c8e1gbcdma81378","name":"unmount","slug":"unmount","createdAt":"2025-08-16T08:43:55.740Z","updatedAt":"2025-08-16T08:43:55.740Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":132,"data":{"documentId":"x1qs0o673c8e1gbcdma81378","name":"unmount","slug":"unmount","createdAt":"2025-08-16T08:43:55.740Z","updatedAt":"2025-08-16T08:43:55.740Z","publishedAt":"2025-08-16T08:43:55.741Z","locale":null}}
{"type":"api::tag.tag","id":133,"data":{"documentId":"odr2us4qq92ncn4ii0kfafvg","name":"update","slug":"update","createdAt":"2025-08-16T08:43:55.746Z","updatedAt":"2025-08-16T08:43:55.746Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":134,"data":{"documentId":"odr2us4qq92ncn4ii0kfafvg","name":"update","slug":"update","createdAt":"2025-08-16T08:43:55.746Z","updatedAt":"2025-08-16T08:43:55.746Z","publishedAt":"2025-08-16T08:43:55.747Z","locale":null}}
{"type":"api::tag.tag","id":135,"data":{"documentId":"rz7p37etd2v5gbqd1enbmqxz","name":"side-effect","slug":"side-effect","createdAt":"2025-08-16T08:43:55.798Z","updatedAt":"2025-08-16T08:43:55.798Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":136,"data":{"documentId":"rz7p37etd2v5gbqd1enbmqxz","name":"side-effect","slug":"side-effect","createdAt":"2025-08-16T08:43:55.798Z","updatedAt":"2025-08-16T08:43:55.798Z","publishedAt":"2025-08-16T08:43:55.799Z","locale":null}}
{"type":"api::tag.tag","id":137,"data":{"documentId":"i74ue2vygu75e5rkg4juupp8","name":"useEffect","slug":"useeffect","createdAt":"2025-08-16T08:43:55.803Z","updatedAt":"2025-08-16T08:43:55.803Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":138,"data":{"documentId":"i74ue2vygu75e5rkg4juupp8","name":"useEffect","slug":"useeffect","createdAt":"2025-08-16T08:43:55.803Z","updatedAt":"2025-08-16T08:43:55.803Z","publishedAt":"2025-08-16T08:43:55.804Z","locale":null}}
{"type":"api::tag.tag","id":139,"data":{"documentId":"l61alkgoq48fbn9nuyfcamof","name":"useCallback","slug":"usecallback","createdAt":"2025-08-16T08:43:55.875Z","updatedAt":"2025-08-16T08:43:55.875Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":140,"data":{"documentId":"l61alkgoq48fbn9nuyfcamof","name":"useCallback","slug":"usecallback","createdAt":"2025-08-16T08:43:55.875Z","updatedAt":"2025-08-16T08:43:55.875Z","publishedAt":"2025-08-16T08:43:55.876Z","locale":null}}
{"type":"api::tag.tag","id":141,"data":{"documentId":"rcscuz9r2blf6ehj0ow2njyi","name":"useMemo","slug":"usememo","createdAt":"2025-08-16T08:43:55.880Z","updatedAt":"2025-08-16T08:43:55.880Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":142,"data":{"documentId":"rcscuz9r2blf6ehj0ow2njyi","name":"useMemo","slug":"usememo","createdAt":"2025-08-16T08:43:55.880Z","updatedAt":"2025-08-16T08:43:55.880Z","publishedAt":"2025-08-16T08:43:55.881Z","locale":null}}
{"type":"api::tag.tag","id":143,"data":{"documentId":"gosf8djqwawzajap9ydo2ole","name":"useRef","slug":"useref","createdAt":"2025-08-16T08:43:55.917Z","updatedAt":"2025-08-16T08:43:55.917Z","publishedAt":null,"locale":null}}
{"type":"api::tag.tag","id":144,"data":{"documentId":"gosf8djqwawzajap9ydo2ole","name":"useRef","slug":"useref","createdAt":"2025-08-16T08:43:55.917Z","updatedAt":"2025-08-16T08:43:55.917Z","publishedAt":"2025-08-16T08:43:55.918Z","locale":null}}